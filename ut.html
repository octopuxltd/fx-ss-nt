<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>New Tab (search prototype)</title>
    <link rel="icon" type="image/png" href="icons/Fx-Browser-icon-fullColor-64.png">
    <link rel="stylesheet" href="suggestions.css">
    <style>
        /* Override hover for ut.html - only show selection state, not hover */
        .ut-page .search-suggestions-preview-item:hover:not(.is-selected),
        .ut-page .search-suggestions-preview-item:focus-within:not(.is-selected) {
            background-color: transparent;
        }

        /* Chair carrot should have hover style like regular suggestions */
        .ut-page .search-suggestions-preview-item.carrot--ad-marketplace:hover:not(.is-selected),
        .ut-page .search-suggestions-preview-item.carrot--ad-marketplace:focus-within:not(.is-selected) {
            background-color: #EBE7FF;
        }

        /* Chair carrot should have 4 rounded corners, not pill-shaped */
        .ut-page .search-suggestions-preview-item.carrot--ad-marketplace {
            border-radius: 10px;
        }
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: Arial, sans-serif;
            min-height: 100vh;
            background-image: url('bg.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
        }

        .server-selector {
            position: fixed;
            bottom: 16px;
            left: 16px;
            z-index: 100;
        }

        .server-selector select {
            padding: 8px 12px;
            font-size: 13px;
            font-family: Arial, sans-serif;
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
        }

        .server-selector select:hover {
            background-color: rgba(255, 255, 255, 1);
            border-color: rgba(0, 0, 0, 0.2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .server-selector select:focus {
            outline: none;
            border-color: #0060DF;
            box-shadow: 0 0 0 3px rgba(0, 96, 223, 0.1);
        }

        .pane {
            padding: 24px;
        }

        .search-container {
            flex: 1;
            overflow-y: hidden;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: var(--search-wrapper-offset, 240px);
            padding-bottom: 80px;
            transition: padding-top 0.45s ease;
        }

        .top-overlay.is-focused .search-container {
            overflow-y: auto;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }

        .top-overlay.is-focused .search-container::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        .top-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 10;
            background-color: rgba(255, 255, 255, 0);
            padding: 16px 24px;
            display: flex;
            justify-content: center;
            border-bottom: 1px solid rgba(0, 0, 0, 0);
            height: 130px;
            box-sizing: border-box;
            overflow: hidden;
            transition: background-color 0.6s ease, border-bottom-color 0.6s ease, height 0.6s ease, border-bottom-left-radius 0.6s ease, border-bottom-right-radius 0.6s ease;
            display: flex;
            flex-direction: column;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
            pointer-events: none; /* Allow pointer events to pass through when not focused */
        }

        .top-overlay > * {
            pointer-events: auto; /* Interactive elements can receive events */
        }

        .top-overlay.is-scrolled {
            background-color: rgba(255, 255, 255, 0.95);
            border-bottom-color: rgba(0, 0, 0, 0.05);
        }

        .top-overlay.is-focused {
            height: 85vh;
            background-color: rgba(255, 255, 255, 0.85);
            border-bottom-color: rgba(0, 0, 0, 0.05);
            border-bottom-left-radius: 50px;
            border-bottom-right-radius: 50px;
            overflow-y: auto;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }

        .top-overlay.is-focused::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        /* Make overlay background transparent to pointer events, but keep scrolling working via JS */
        .top-overlay.is-focused {
            pointer-events: none;
        }

        /* Ensure all interactive elements in focused overlay can receive pointer events */
        .top-overlay.is-focused > * {
            pointer-events: auto;
        }


        /* Ensure bottom content can receive pointer events */
        .bottom-content {
            pointer-events: auto;
            position: relative;
            z-index: 1;
        }

        .top-overlay.is-focused.winter-olympics {
            position: relative;
        }

        /* Prevent scrolling when winter olympics is active */
        body.winter-olympics-active,
        html.winter-olympics-active {
            overflow: hidden;
            height: 100%;
            position: fixed;
            width: 100%;
        }

        .winter-olympics-background {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: url('icons/espn2.jpg');
            background-size: 100% auto;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            z-index: -1;
            pointer-events: none;
        }

        .top-overlay.is-focused.winter-olympics .winter-olympics-background {
            opacity: 1;
        }

        .top-overlay.no-transition {
            transition: none !important;
        }

        .top-overlay.no-transition .search-wrapper,
        .top-overlay.no-transition .search-description,
        .top-overlay.no-transition .search-suggestions-preview {
            transition: none !important;
        }

        .firefox-logo {
            position: fixed;
            top: 32px;
            left: 34px;
            width: 48px;
            height: 48px;
            z-index: 11;
        }

        .close-button {
            position: fixed;
            top: 32px;
            right: 34px;
            width: 48px;
            height: 48px;
            z-index: 11;
            background: none;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .top-overlay.is-focused .close-button {
            opacity: 0.5;
            pointer-events: auto;
        }

        .close-button:hover {
            opacity: 1 !important;
        }

        .close-button svg {
            width: 48px;
            height: 48px;
            stroke: #1F2933;
            stroke-width: 1;
            transition: stroke 0.2s ease, stroke-width 0.2s ease;
        }

        .close-button:hover svg {
            stroke: #000000;
            stroke-width: 1.5;
        }

        .vpn-indicator {
            position: fixed;
            top: 32px;
            right: 34px;
            display: none;
            align-items: center;
            gap: 8px;
            z-index: 11;
            font-size: 14px;
            font-weight: 600;
            color: #1F2933;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .vpn-indicator.is-active {
            display: flex;
        }

        .top-overlay.is-focused .vpn-indicator {
            top: 88px;
        }

        .vpn-indicator-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #10b981;
            flex-shrink: 0;
        }

        .demo-searches {
            position: fixed;
            top: 170px;
            left: 34px;
            font-size: 13px;
            color: #FFFFFF;
            line-height: 1.6;
            pointer-events: auto;
            transition: color 0.3s ease;
            z-index: 11;
            width: 150px;
        }

        .top-overlay.is-focused .demo-searches {
            color: #6B7280;
        }

        .demo-searches-title {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .demo-searches ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .demo-searches li {
            margin: 2px 0;
        }

        .demo-searches .not-implemented {
            text-decoration: line-through;
        }

        .info-icon-wrapper {
            position: fixed;
            bottom: 24px;
            left: 34px;
            z-index: 11;
        }

        .info-icon-button {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: transparent;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.2s ease;
            box-shadow: none;
            opacity: 0;
        }

        .info-icon-button:hover {
            background-color: transparent;
            transform: scale(1.05);
            opacity: 0;
        }

        .info-icon-button svg {
            width: 18px;
            height: 18px;
            stroke: transparent;
            fill: transparent;
            opacity: 0;
        }

        .demo-searches-card {
            position: absolute;
            bottom: 40px;
            left: 0;
            background-color: rgba(255, 255, 255, 0.98);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            min-width: 200px;
            max-width: 300px;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            z-index: 12;
        }

        .info-icon-wrapper.is-open .demo-searches-card {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        .demo-searches-earlier {
            font-size: 13px;
            color: #1F2933;
            line-height: 1.6;
        }

        .top-overlay.is-focused .demo-searches-earlier {
            color: #1F2933;
        }

        .demo-searches-earlier .demo-searches-title {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .demo-searches-earlier ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .demo-searches-earlier li {
            margin: 2px 0;
        }

        .search-wrapper {
            position: fixed;
            top: 32px;
            left: 50%;
            transform: translateX(-50%);
            width: 56%;
            margin: 0;
            transition: width 0.35s ease-in-out;
            border: 1px solid transparent;
            border-radius: 28px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            background-color: rgba(255, 255, 255, 0.7);
            box-shadow: 0 12px 12px rgba(15, 23, 42, 0.12);
            z-index: 100;
            isolation: isolate;
        }

        .search-wrapper::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 28px;
            padding: 2px;
            background: conic-gradient(from 0deg, #945AF2 0%, #F37E49 71%, #945AF2 100%);
            -webkit-mask: 
                linear-gradient(#fff 0 0) content-box, 
                linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.35s ease-in-out;
        }

        .search-wrapper:focus-within::before,
        .top-overlay.is-focused .search-wrapper::before {
            opacity: 1;
        }

        .search-wrapper.expanded {
            width: 70%;
        }

        .search-wrapper:focus-within {
            border: 1px solid transparent;
            background-color: rgba(255, 255, 255, 0.99);
        }

        .top-overlay.is-scrolled .search-wrapper,
        .top-overlay.is-focused .search-wrapper {
            border-color: rgba(15, 23, 42, 0.12);
        }

        .search-input-shell {
            position: relative;
            padding: 18px 18px 5px; padding-right: 50px;
            padding-left: 84px;
        }

        .search-input-shell {
            padding-right: 50px;
        }

        .search-clear-button {
            position: absolute;
            right: 18px;
            top: calc(50% + 7px);
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.5;
            transition: opacity 0.2s ease;
            z-index: 1;
        }

        .search-clear-button:hover {
            opacity: 1;
        }

        .search-clear-button svg {
            width: 16px;
            height: 16px;
            stroke: #1F2933;
        }

        .search-dropdown-button {
            position: absolute;
            left: 10px;
            top: calc(50% + 7px);
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            padding: 6px 8px;
            border-radius: 999px;
            background-color: #FFFFFF;
            transition: background-color 0.2s ease;
            z-index: 0;
        }
        
        /* When panel is open (is-focused), make the button grey */
        .top-overlay.is-focused .search-dropdown-button {
            background-color: #F3F4F6;
        }

        .circle-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            margin-right: 2px;
            border-radius: 50%;
            background-color: #FFFFFF;
            transition: background-color 0.2s ease;
        }
        
        /* When panel is open (is-focused), make the circle icon grey */
        .top-overlay.is-focused .circle-icon {
            background-color: #F3F4F6;
        }

        .circle-icon__image {
            width: 16px;
            height: 16px;
        }

        .chevron {
            width: 12px;
            height: 12px;
            margin-left: 2px;
            position: relative;
            top: 1px;
        }

        .search-box {
            width: 100%;
            padding: 0;
            border: none;
            background: transparent;
            font-size: 16px;
            color: #000000;
            position: relative;
            z-index: 1;
        }

        .search-box::placeholder {
            color: #000000;
        }

        .top-overlay.is-focused .search-box::placeholder {
            color: rgba(0, 0, 0, 0.5);
        }

        .search-box:focus {
            outline: none;
        }

        .search-description {
            width: 100%;
            margin: 0 auto;
            padding: 0 0 32px;
            position: relative;
            z-index: 1;
            pointer-events: auto;
        }

        .top-overlay.is-focused .search-description {
            width: 100%;
        }

        .overlay-product-grid {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 16px;
            width: 70%;
            max-width: 1200px;
            margin: 0 auto;
            opacity: 0;
            transition: opacity 0.6s ease;
            position: relative;
            z-index: -1;
        }

        .top-overlay.is-focused .overlay-product-grid {
            opacity: 1;
        }

        .overlay-product-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
            position: relative;
            z-index: 1;
            pointer-events: auto;
        }

        .overlay-product-heading {
            margin: 0;
            font-size: 12px;
            font-weight: 400;
            letter-spacing: normal;
            color: #6B7280;
            opacity: 0;
            transition: opacity 0.6s ease;
        }

        .top-overlay.is-focused .overlay-product-heading {
            opacity: 1;
        }

        .overlay-product-card {
            background: #FFFFFF;
            border-radius: 6px;
            overflow: hidden;
            display: flex;
            flex-direction: row;
            box-shadow: 0 4px 6px rgba(15, 23, 42, 0.12);
            text-decoration: none;
            color: inherit;
            height: auto;
            min-height: 50px;
            align-items: center;
            transition: background-color 0.2s ease, opacity 0.6s ease;
            opacity: 0;
            cursor: pointer;
            position: relative;
            z-index: 1;
            pointer-events: auto;
        }

        .top-overlay.is-focused .overlay-product-card {
            opacity: 1;
        }

        .overlay-product-card img:not(.overlay-product-favicon):not(.overlay-product-meta-favicon):not(.overlay-product-image-favicon) {
            width: 50px;
            height: 50px;
            object-fit: cover;
            flex-shrink: 0;
        }

        .overlay-product-favicon {
            width: 48px;
            height: 48px;
            object-fit: contain;
            flex-shrink: 0;
            border: 1px solid white;
            box-sizing: border-box;
            background-color: white;
        }

        .overlay-product-image-wrapper {
            position: relative;
            width: 50px;
            height: 50px;
            flex-shrink: 0;
        }

        .overlay-product-image-wrapper img:not(.overlay-product-image-favicon) {
            width: 50px;
            height: 50px;
            object-fit: cover;
        }

        .overlay-product-image-favicon {
            position: absolute;
            bottom: 9px;
            right: 9px;
            width: 20px !important;
            height: 20px !important;
            border-radius: 2px;
            background-color: rgba(255, 255, 255, 0.5);
            padding: 1px;
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.8);
            object-fit: contain;
        }

        .overlay-product-card--article img {
            width: 100% !important;
            height: 139px !important;
            object-fit: cover;
        }
        
        .overlay-product-card--article img[src*="kettle"] {
            object-position: center 20%;
        }

        .overlay-product-card-body {
            padding: 0 12px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            justify-content: center;
            width: 100%;
            min-width: 0;
            position: relative;
        }

        .overlay-product-title {
            font-size: 14px;
            font-weight: 400;
            margin: 0;
            color: #1F2933;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .overlay-product-meta {
            font-size: 9px;
            margin: 0;
            color: rgba(15, 23, 42, 0.6);
            display: flex;
            align-items: center;
            gap: 6px;
            width: 100%;
            position: relative;
        }

        .overlay-product-meta-left {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .overlay-product-meta-text {
            display: none;
        }

        .overlay-product-last-viewed {
            display: inline;
        }

        .overlay-product-card:hover .overlay-product-meta-text {
            display: inline;
        }

        .overlay-product-card:hover .overlay-product-last-viewed {
            display: none;
        }

        .overlay-product-section-icon {
            position: absolute;
            right: 0;
            flex-shrink: 0;
            color: rgba(15, 23, 42, 0.6);
            cursor: pointer;
            z-index: 1;
            transition: opacity 0.2s ease;
        }

        .overlay-product-card:hover .overlay-product-section-icon {
            opacity: 0;
        }

        .overlay-product-card-actions {
            display: none;
            align-items: center;
            gap: 8px;
            position: absolute;
            right: 12px;
            bottom: 0;
            z-index: 2;
        }

        .overlay-product-card:hover .overlay-product-card-actions {
            display: flex;
        }

        .overlay-product-menu-button,
        .overlay-product-close-button {
            background: transparent;
            border: none;
            padding: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6B7280;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .overlay-product-menu-button:hover,
        .overlay-product-close-button:hover {
            opacity: 1;
        }

        .overlay-product-menu-button svg,
        .overlay-product-close-button svg {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
        }

        .overlay-product-meta-favicon {
            width: 12px !important;
            height: 12px !important;
            flex-shrink: 0;
            object-fit: contain;
            max-width: 12px !important;
            max-height: 12px !important;
        }

        .overlay-product-card:hover,
        .overlay-product-card:focus {
            background-color: #EBE7FF;
        }

        /* Winter Olympics card hover colors - blue, yellow, green, red in order */
        .olympics-card-blue:hover {
            background-color: #0085C7 !important;
        }

        .olympics-card-blue:hover .overlay-product-title,
        .olympics-card-blue:hover div {
            color: #FFFFFF !important;
        }

        .olympics-card-black:hover {
            background-color: #F4C300 !important; /* Yellow */
        }

        .olympics-card-black:hover .overlay-product-title,
        .olympics-card-black:hover div {
            color: #000000 !important;
        }

        .olympics-card-red:hover {
            background-color: #009F3D !important; /* Green */
        }

        .olympics-card-red:hover .overlay-product-title,
        .olympics-card-red:hover div {
            color: #FFFFFF !important;
        }

        .olympics-card-yellow:hover {
            background-color: #DF0024 !important; /* Red */
        }

        .olympics-card-yellow:hover .overlay-product-title,
        .olympics-card-yellow:hover div {
            color: #FFFFFF !important;
        }

        .overlay-product-card--article {
            flex-direction: column;
            height: 200px;
            position: relative;
            z-index: 0;
            align-items: flex-start;
        }

        .overlay-product-card--article img {
            width: 100% !important;
            height: 139px !important;
            object-fit: cover;
        }

        .overlay-product-card--article .image-placeholder {
            width: 100%;
            height: 139px;
            background-color: #E5E7EB;
        }

        .overlay-product-card--article h2 {
            margin: 8px 16px 4px 16px;
            font-size: 14px;
            text-align: left;
            color: #333;
            font-weight: 500;
            flex-grow: 1;
            width: calc(100% - 32px);
            align-self: flex-start;
        }

        .overlay-product-card--article .overlay-product-meta {
            margin-left: 16px;
            margin-bottom: 16px;
            font-size: 9px;
            color: #333;
        }

        .overlay-product-card--article .sponsored-label {
            position: absolute;
            bottom: 8px;
            right: 16px;
            font-size: 9px;
            color: #64748B;
            font-weight: 500;
            letter-spacing: 0.5px;
            margin: 0;
            text-align: left;
        }

        .overlay-product-card--article:hover {
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        }

        .overlay-product-card--article:hover h2 {
            color: #333;
        }

        .overlay-product-card--article:hover,
        .overlay-product-card--article:focus {
            background-color: #EBE7FF;
        }





        .pane--bottom {
            min-height: 100vh;
            background: transparent;
            color: #4a3419;
            overflow-y: auto;
            padding: 0;
            position: relative;
        }

        .bottom-overlay {
            position: fixed;
            top: 130px;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0);
            pointer-events: none;
            z-index: 5;
            margin-top: -50px;
            transition: top 0.6s ease, background-color 0.6s ease;
        }

        .bottom-overlay.no-transition {
            transition: none !important;
        }

        .bottom-content {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 32px;
            padding: 24px;
            padding-top: calc(130px + 24px);
        }

        .quick-tiles {
            width: 70%;
            max-width: 1200px;
            display: flex;
            justify-content: space-between;
            gap: 16px;
        }

        .quick-tiles__tile {
            flex: 0 0 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 6px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(6px);
            padding: 12px 8px;
            text-decoration: none;
            color: inherit;
            transition: background-color 0.2s ease;
        }

        .quick-tiles__tile:hover {
            background: rgba(255, 255, 255, 0.7);
        }

        .quick-tiles__favicon {
            width: 36px;
            height: 36px;
            object-fit: contain;
        }

        .quick-tiles__label {
            font-size: 11px;
            color: rgba(31, 41, 51, 0.7);
            text-align: center;
            font-weight: 500;
        }

        .heading {
            font-size: 16px;
            font-weight: bold;
            text-align: left;
            margin: 0;
            padding-top: 16px;
            width: 70%;
            max-width: 1200px;
            color: #FFFFFF;
        }

        .footer-links {
            display: flex;
            gap: 32px;
            justify-content: space-between;
            margin-top: 48px;
            margin-bottom: 48px;
            width: 70%;
            max-width: 1200px;
        }

        .footer-links-right {
            display: flex;
            gap: 32px;
        }

        .footer-link {
            color: white;
            text-decoration: none;
            font-size: 14px;
            font-weight: bold;
        }

        .footer-link:hover {
            text-decoration: underline;
        }

        .articles-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 26px;
            width: 70%;
            max-width: 1200px;
            transition: opacity 0.6s ease;
            opacity: 1;
        }

        .top-overlay.is-focused ~ .bottom-content .articles-grid {
            opacity: 0.5;
        }

        .card {
            background-color: #FFFFFF;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 275px;
            transition: box-shadow 0.15s ease-in-out;
            position: relative;
        }

        .card h2 {
            margin: 16px;
            font-size: 18px;
            text-align: left;
            color: #333;
            font-weight: 500;
            flex-grow: 1;
        }

        .card p {
            margin-left: 16px;
            margin-bottom: 16px;
            font-size: 12px;
        }

        .card .sponsored-label {
            position: absolute;
            bottom: 12px;
            right: 16px;
            font-size: 9px;
            color: #64748B;
            font-weight: 500;
            letter-spacing: 0.5px;
            margin: 0;
        }

        .card:hover {
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        }

        .card:hover h2 {
            color: #1E90FF;
        }

        .card--pinned-flash {
            border: 5px solid #D41CC1 !important;
        }

        .card--world-clock {
            position: relative;
        }

        .card--world-clock .card-controls,
        .card--stock .card-controls,
        .card--sports .card-controls,
        .card--weather .card-controls {
            position: absolute;
            top: 8px;
            right: 8px;
            display: none;
            flex-direction: row;
            align-items: center;
            gap: 4px;
            z-index: 10;
        }

        .card--world-clock:hover .card-controls,
        .card--stock:hover .card-controls,
        .card--sports:hover .card-controls,
        .card--weather:hover .card-controls {
            display: flex;
        }

        .card-control-button {
            width: 24px;
            height: 24px;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            padding: 0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s ease;
        }

        .card-control-button:hover {
            background: rgba(255, 255, 255, 1);
        }

        .card-control-button svg {
            width: 16px;
            height: 16px;
        }

        a.card {
            text-decoration: none;
            color: inherit;
            display: block;
            height: 100%;
        }

        .image-placeholder {
            width: 100%;
            height: 160px;
            background-color: #CCC;
        }

        p {
            line-height: 1.6;
            margin-bottom: 16px;
        }

        .no-transition {
            transition: none !important;
        }

        .search-background-bottom-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            height: 54px;
            border: none;
            background-color: #EBE7FF;
            cursor: pointer;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out, background-color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .top-overlay.is-focused .search-background-bottom-overlay {
            opacity: 1;
            pointer-events: auto;
        }

        .search-background-bottom-overlay svg {
            display: block;
        }

        .search-background-bottom-overlay .chevron-shallow {
            opacity: 1;
            transition: opacity 0.2s ease-in-out;
        }

        .search-background-bottom-overlay .chevron-steep {
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        .search-background-bottom-overlay:hover {
            background-color: rgba(255, 255, 255, 1);
            opacity: 1;
        }

        .search-background-bottom-overlay:hover .chevron-shallow {
            opacity: 0;
        }

        .search-background-bottom-overlay:hover .chevron-steep {
            opacity: 1;
            stroke: #374151;
        }

        .debug-buttons {
            position: fixed;
            top: 32px;
            right: 24px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 2px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .top-overlay.is-focused .debug-buttons {
            opacity: 1;
            pointer-events: auto;
        }

        .debug-buttons-bottom {
            position: absolute;
            bottom: 62px;
            right: 24px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 2px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .top-overlay.is-focused .debug-buttons-bottom {
            opacity: 1;
            pointer-events: auto;
        }

        .debug-button {
            width: auto;
            height: auto;
            padding: 4px 8px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            background-color: rgba(255, 255, 255, 0.9);
            color: #374151;
            font-size: 8px;
            font-weight: 400;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            transition: background-color 0.15s ease, border-color 0.15s ease;
            white-space: nowrap;
            text-align: left;
        }

        .debug-button:hover {
            background-color: rgba(229, 231, 235, 0.95);
            border-color: rgba(0, 0, 0, 0.2);
        }

        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }

        .phase-toggle {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 10px;
        }

        .phase-toggle__link {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 1px 6px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.4);
            background: rgba(15, 23, 42, 0.4);
            color: #FFFFFF;
            font-size: 11px;
            font-weight: 600;
            text-decoration: none;
            transition: background 0.2s ease, border-color 0.2s ease;
        }

        .phase-toggle-heading {
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 6px;
            width: 100%;
        }

        .phase-toggle__link:hover,
        .phase-toggle__link:focus {
            background: rgba(15, 23, 42, 0.6);
            border-color: rgba(255, 255, 255, 0.7);
            outline: none;
        }

        .phase-toggle__link.is-active {
            background: rgba(15, 23, 42, 0.8);
            border-color: rgba(255, 255, 255, 0.9);
        }

        .phase-toggle__label {
            display: none;
        }

        .phase-toggle__link.is-active .phase-toggle__label {
            display: inline;
        }

        .phase-toggle__number {
            margin-left: 0;
        }

        .phase-toggle__link.is-active .phase-toggle__number {
            margin-left: 4px;
        }

        .local-carrot-row {
            display: none;
            width: 100%;
            padding: 0 8px;
            margin-top: 12px;
        }

        .local-carrot-row.is-visible {
            display: flex;
        }

        .local-carrot-grid {
            display: flex;
            gap: 12px;
            list-style: none;
            padding: 0;
            margin: 0;
            width: 100%;
        }

        .local-carrot-grid .search-suggestions-preview-item {
            flex: 1 1 0;
        }

        .search-suggestions-preview-column-container.local-horizontal .search-suggestions-preview-list:first-child {
            flex: 0 0 100%;
        }

        .search-suggestions-preview-column-container.local-horizontal .search-suggestions-preview-list:last-child {
            display: none;
        }
    </style>
    <script src="product-sections/product-history.js"></script>
    <script src="product-sections/product-bookmarks.js"></script>
    <script src="product-sections/product-open-tabs.js"></script>
    <script src="product-sections/product-articles.js"></script>
    <script src="product-content.js"></script>
    <script src="carrot-templates.js"></script>
    <script src="suggestion-words.js"></script>
    <script src="image-preload.js"></script>
    <!-- Load API configuration (config.js is gitignored) -->
    <script src="config.js" onerror="console.warn('config.js not found. Using example config. Please create config.js from config.example.js'); window.API_CONFIG = window.API_CONFIG || { OPENROUTER_API_KEY: '', PEXELS_API_KEY: '' };"></script>
    <script>
        // AI API Configuration
        // Load saved provider from localStorage, or default to OpenAI (Server 2)
        let AI_PROVIDER = localStorage.getItem('ai_provider') || 'openai';
        
        // Model mapping for different providers
        const MODEL_MAP = {
            'openrouter-haiku': 'anthropic/claude-3-haiku',
            'openai': 'gpt-4o-mini'
        };
        const OPENROUTER_API_KEY = window.API_CONFIG?.OPENROUTER_API_KEY || '';
        const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
        const CLAUDE_API_KEY = window.API_CONFIG?.CLAUDE_API_KEY || '';
        const CLAUDE_API_URL = 'https://api.anthropic.com/v1/messages';
        const OPENAI_API_KEY = window.API_CONFIG?.OPENAI_API_KEY || '';
        const OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';
        
        // Debounce timer for API calls
        let apiCallTimer = null;
        let lastApiQuery = '';
        
        // Track which suggestions are from AI (for icon assignment)
        let aiSuggestionsSet = new Set();
        
        // LocalStorage cache functions
        function getCacheKey(query) {
            return `ai_suggestions_${query.toLowerCase().trim()}`;
        }
        
        function getCachedSuggestions(query) {
            try {
                const cacheKey = getCacheKey(query);
                const cached = localStorage.getItem(cacheKey);
                if (cached) {
                    const parsed = JSON.parse(cached);
                    // Check if cache is still valid (24 hours)
                    const cacheAge = Date.now() - parsed.timestamp;
                    const maxAge = 24 * 60 * 60 * 1000; // 24 hours
                    if (cacheAge < maxAge) {
                        console.log('[API] Found cached suggestions:', parsed.suggestions);
                        // Filter cached suggestions to only include word-start matches
                        const queryLower = query.toLowerCase();
                        const filtered = parsed.suggestions.filter(suggestion => {
                            const suggestionLower = suggestion.toLowerCase();
                            // Check if suggestion starts with query
                            if (suggestionLower.startsWith(queryLower)) {
                                return true;
                            }
                            // Check if any word in the suggestion starts with the query
                            const words = suggestionLower.split(/\s+/);
                            return words.some(word => word.startsWith(queryLower));
                        });
                        console.log('[API] Filtered', parsed.suggestions.length, 'cached suggestions to', filtered.length, 'matching query');
                        return filtered.length > 0 ? filtered : null;
                    } else {
                        console.log('[API] Cache expired, removing old cache');
                        localStorage.removeItem(cacheKey);
                    }
                }
            } catch (error) {
                console.error('[API] Error reading from cache:', error);
            }
            return null;
        }
        
        function cacheSuggestions(query, suggestions) {
            try {
                const cacheKey = getCacheKey(query);
                const cacheData = {
                    suggestions: suggestions,
                    timestamp: Date.now()
                };
                localStorage.setItem(cacheKey, JSON.stringify(cacheData));
                console.log('[API] Cached suggestions for:', query);
            } catch (error) {
                console.error('[API] Error caching suggestions:', error);
                // localStorage might be full, try to clear old entries
                try {
                    const keysToRemove = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith('ai_suggestions_')) {
                            keysToRemove.push(key);
                        }
                    }
                    // Remove oldest 10 entries if cache is full
                    if (keysToRemove.length > 50) {
                        keysToRemove.slice(0, 10).forEach(key => localStorage.removeItem(key));
                        // Retry caching
                        localStorage.setItem(cacheKey, JSON.stringify(cacheData));
                    }
                } catch (e) {
                    console.error('[API] Could not clear cache:', e);
                }
            }
        }
        
        // Firefox suggestions cache functions
        function getFirefoxCacheKey(query) {
            return `firefox_suggestions_${query.toLowerCase().trim()}`;
        }
        
        function getCachedFirefoxSuggestions(query) {
            try {
                const cacheKey = getFirefoxCacheKey(query);
                const cached = localStorage.getItem(cacheKey);
                if (cached) {
                    const parsed = JSON.parse(cached);
                    // Check if cache is still valid (24 hours)
                    const cacheAge = Date.now() - parsed.timestamp;
                    const maxAge = 24 * 60 * 60 * 1000; // 24 hours
                    if (cacheAge < maxAge) {
                        console.log('[API-FIREFOX] Found cached Firefox suggestions:', parsed.selectedSuggestions ? parsed.selectedSuggestions.length : parsed.suggestions?.length, '| Count to show:', parsed.countToShow);
                        // Return both selected suggestions (the ones actually shown) and count to show
                        // Support both old format (suggestions array) and new format (selectedSuggestions array)
                        return {
                            selectedSuggestions: parsed.selectedSuggestions || parsed.suggestions,
                            countToShow: parsed.countToShow || (parsed.selectedSuggestions ? parsed.selectedSuggestions.length : parsed.suggestions?.length || 0)
                        };
                    } else {
                        console.log('[API-FIREFOX] Cache expired, removing old cache');
                        localStorage.removeItem(cacheKey);
                    }
                }
            } catch (error) {
                console.error('[API-FIREFOX] Error reading from cache:', error);
            }
            return null;
        }
        
        function cacheFirefoxSuggestions(query, selectedSuggestions, countToShow) {
            try {
                if (!selectedSuggestions || selectedSuggestions.length === 0) {
                    return; // Don't cache empty results
                }
                const cacheKey = getFirefoxCacheKey(query);
                const cacheData = {
                    selectedSuggestions: selectedSuggestions, // Cache the actual suggestions that were shown
                    countToShow: countToShow || selectedSuggestions.length,
                    timestamp: Date.now()
                };
                localStorage.setItem(cacheKey, JSON.stringify(cacheData));
                console.log('[API-FIREFOX] Cached', selectedSuggestions.length, 'Firefox suggestions for:', query, '| Count to show:', countToShow);
            } catch (error) {
                console.error('[API-FIREFOX] Error caching Firefox suggestions:', error);
                // localStorage might be full, try to clear old entries
                try {
                    const keysToRemove = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith('firefox_suggestions_')) {
                            keysToRemove.push(key);
                        }
                    }
                    // Remove oldest entries first (simple approach: remove first 10)
                    keysToRemove.slice(0, 10).forEach(key => localStorage.removeItem(key));
                    // Retry caching
                    localStorage.setItem(cacheKey, JSON.stringify(cacheData));
                } catch (e) {
                    console.error('[API-FIREFOX] Could not clear cache:', e);
                }
            }
        }
        
        // Helper function to make a search suggestions request attempt
        async function makeSearchSuggestionsRequest(query, attemptNumber, delayMs = 0, providerOverride = null) {
            const provider = providerOverride || AI_PROVIDER;
            const modelName = MODEL_MAP[provider] || provider;
            console.log(`[API-SEARCH] ===== Starting search suggestions attempt ${attemptNumber} for query: "${query}" (provider: ${provider}, model: ${modelName}) =====`);
            console.log(`[API-SEARCH] Provider value: "${provider}" | Model: "${modelName}" | Type: ${typeof provider}`);
            if (delayMs > 0) {
                console.log(`[API-SEARCH] Waiting ${delayMs}ms before attempt ${attemptNumber}...`);
                await new Promise(resolve => setTimeout(resolve, delayMs));
            }

            const startTime = Date.now();
            console.log(`[API-SEARCH] Making request attempt ${attemptNumber} for query: "${query}"`);
            
            // Determine which API to use based on provider
            const isOpenRouter = provider.startsWith('openrouter-');
            const isOpenAI = provider === 'openai';
            
            // Check API key based on provider
            if (provider === 'claude' && !CLAUDE_API_KEY) {
                console.error('[API-SEARCH] ✗ Claude API key not set');
                throw new Error('Claude API key not set');
            } else if (provider.startsWith('openrouter-') && !OPENROUTER_API_KEY) {
                console.error('[API-SEARCH] ✗ OpenRouter API key not set');
                throw new Error('OpenRouter API key not set');
            } else if (isOpenAI && !OPENAI_API_KEY) {
                console.error('[API-SEARCH] ✗ OpenAI API key not set');
                throw new Error('OpenAI API key not set');
            }
            console.log('[API-SEARCH] ✓ API key is set');
            
            const systemPrompt = 'You are a search suggestion generator. Generate 10 popular search queries where at least one word starts with the user\'s query characters. Prioritize nouns - names of famous things like celebrities, bands, movies, places, politicians, news topics, or common questions (how to do things, why something happens). For example, if the user types "abc", return suggestions like "abc news", "abc store", "abc company" where words start with "abc". The query characters need not form a complete word - they are the beginning of words. Return ONLY a JSON array of 10 search queries, sorted by popularity. No explanations, just the JSON array.';
            const userPrompt = `Generate 10 popular search suggestions where at least one word starts with: "${query}". Prioritize nouns - famous people, places, movies, bands, news topics, or common questions (how to, why). Return only a JSON array of strings.`;
            
            const promptTimestamp = new Date().toISOString();
            console.log(`[API-SEARCH] [${promptTimestamp}] Prompt sent to ${provider}:`, userPrompt);
            
            let response, data, content;
            
            if (isOpenAI) {
                // OpenAI API request
                const requestBody = {
                    model: MODEL_MAP[provider],
                    messages: [
                        {
                            role: 'system',
                            content: systemPrompt
                        },
                        {
                            role: 'user',
                            content: userPrompt
                        }
                    ],
                    temperature: 0.7,
                    max_tokens: 200
                };
                
                response = await fetch(OPENAI_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENAI_API_KEY}`
                    },
                    body: JSON.stringify(requestBody)
                });
                
                const requestDuration = Date.now() - startTime;
                console.log(`[API-SEARCH] Attempt ${attemptNumber} response received:`, {
                    status: response.status,
                    duration: `${requestDuration}ms`
                });
                
                if (!response.ok) {
                    let errorText;
                    try {
                        errorText = await response.text();
                    } catch (e) {
                        errorText = 'Could not read error response';
                    }
                    
                    const error = new Error(`API error: ${response.status} - ${errorText}`);
                    error.hasResponse = true;
                    throw error;
                }
                
                data = await response.json();
                content = data.choices?.[0]?.message?.content?.trim();
            } else if (AI_PROVIDER === 'claude') {
                // Claude API request
                const requestBody = {
                    model: 'claude-3-5-haiku-20241022',
                    max_tokens: 200,
                    temperature: 0.7,
                    system: systemPrompt,
                    messages: [
                        {
                            role: 'user',
                            content: userPrompt
                        }
                    ]
                };
                
                response = await fetch(CLAUDE_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': CLAUDE_API_KEY,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                const requestDuration = Date.now() - startTime;
                console.log(`[API-SEARCH] Attempt ${attemptNumber} response received:`, {
                    status: response.status,
                    duration: `${requestDuration}ms`
                });
                
                if (!response.ok) {
                    let errorText;
                    try {
                        errorText = await response.text();
                    } catch (e) {
                        errorText = 'Could not read error response';
                    }
                    
                    const error = new Error(`API error: ${response.status} - ${errorText}`);
                    error.hasResponse = true;
                    throw error;
                }
                
                data = await response.json();
                content = data.content?.[0]?.text?.trim();
            } else {
                // OpenRouter API request
                const requestBody = {
                    model: MODEL_MAP[provider] || 'anthropic/claude-3-haiku',
                    messages: [
                        {
                            role: 'system',
                            content: systemPrompt
                        },
                        {
                            role: 'user',
                            content: userPrompt
                        }
                    ],
                    temperature: 0.7,
                    max_tokens: 200
                };
                
                response = await fetch(OPENROUTER_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
                        'HTTP-Referer': window.location.origin,
                        'X-Title': 'Search Suggestions'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                const requestDuration = Date.now() - startTime;
                console.log(`[API-SEARCH] Attempt ${attemptNumber} response received:`, {
                    status: response.status,
                    duration: `${requestDuration}ms`
                });
                
                if (!response.ok) {
                    let errorText;
                    try {
                        errorText = await response.text();
                    } catch (e) {
                        errorText = 'Could not read error response';
                    }
                    
                    const error = new Error(`API error: ${response.status} - ${errorText}`);
                    error.hasResponse = true;
                    throw error;
                }
                
                data = await response.json();
                content = data.choices[0]?.message?.content?.trim();
            }
            
            if (!content) {
                const error = new Error('Empty content in response');
                error.hasResponse = true;
                throw error;
            }
            
            // Parse JSON response - can be array or object with suggestions
            let suggestions = [];
            try {
                // Try to parse as JSON object first
                const jsonObjectMatch = content.match(/\{[\s\S]*\}/);
                if (jsonObjectMatch) {
                    const parsed = JSON.parse(jsonObjectMatch[0]);
                    if (parsed.suggestions && Array.isArray(parsed.suggestions)) {
                        suggestions = parsed.suggestions;
                    }
                }
                
                // If no object found or suggestions empty, try array
                if (suggestions.length === 0) {
                    const jsonArrayMatch = content.match(/\[.*\]/s);
                    if (jsonArrayMatch) {
                        suggestions = JSON.parse(jsonArrayMatch[0]);
                    } else {
                        suggestions = content.split('\n')
                            .map(line => line.trim().replace(/^[-•\d.\s"']+|[-•\d.\s"']+$/g, ''))
                            .filter(line => line.length > 0)
                            .slice(0, 9);
                    }
                }
            } catch (parseError) {
                const quotedMatches = content.match(/"([^"]+)"/g);
                if (quotedMatches) {
                    suggestions = quotedMatches.map(m => m.replace(/"/g, '')).slice(0, 9);
                }
            }
            
            const finalSuggestions = suggestions.filter(s => s && s.length > 0).slice(0, 9);
            
            const responseTimestamp = new Date().toISOString();
            console.log(`[API-SEARCH] [${responseTimestamp}] Response received:`, finalSuggestions);
            console.log(`[API-SEARCH] Attempt ${attemptNumber} succeeded with ${finalSuggestions.length} suggestions`);
            
            if (finalSuggestions.length === 0) {
                const error = new Error('No suggestions parsed');
                error.hasResponse = true;
                throw error;
            }
            
            return finalSuggestions;
        }

        // Helper function to make a Firefox suggestions request attempt
        async function makeFirefoxSuggestionsRequest(query, attemptNumber, delayMs = 0) {
            const modelName = MODEL_MAP[AI_PROVIDER] || AI_PROVIDER;
            console.log(`[API-FIREFOX] ===== Starting Firefox suggestions attempt ${attemptNumber} for query: "${query}" (provider: ${AI_PROVIDER}, model: ${modelName}) =====`);
            if (delayMs > 0) {
                console.log(`[API-FIREFOX] Waiting ${delayMs}ms before attempt ${attemptNumber}...`);
                await new Promise(resolve => setTimeout(resolve, delayMs));
            }

            const startTime = Date.now();
            console.log(`[API-FIREFOX] Making request attempt ${attemptNumber} for query: "${query}"`);
            
            // Determine which API to use based on provider
            const isOpenRouter = AI_PROVIDER.startsWith('openrouter-');
            const isOpenAI = AI_PROVIDER === 'openai';
            
            // Check API key based on provider
            if (AI_PROVIDER === 'claude' && !CLAUDE_API_KEY) {
                console.error('[API-FIREFOX] ✗ Claude API key not set');
                throw new Error('Claude API key not set');
            } else if (AI_PROVIDER.startsWith('openrouter-') && !OPENROUTER_API_KEY) {
                console.error('[API-FIREFOX] ✗ OpenRouter API key not set');
                throw new Error('OpenRouter API key not set');
            } else if (isOpenAI && !OPENAI_API_KEY) {
                console.error('[API-FIREFOX] ✗ OpenAI API key not set');
                throw new Error('OpenAI API key not set');
            }
            console.log('[API-FIREFOX] ✓ API key is set');
            
            const systemPrompt = 'You are a browser history suggestion generator. Generate 4 Firefox suggestions (page titles from simulated browser history related to the query). Each Firefox suggestion should be an object with "title" (page title), "url" (realistic full web address starting with "www." including a path, like "www.example.com/article/topic" or "www.site.com/page/subpage"), and "description" (exactly 60 characters, a simulated meta description). IMPORTANT: All 4 suggestions must come from different websites (different domains). Return ONLY a JSON array of 4 objects, each with title, url, description. No explanations, just the JSON array.';
            const userPrompt = `Generate 4 Firefox suggestions related to "${query}". Each Firefox suggestion should be an object with: "title" (page title), "url" (realistic full web address starting with "www." including a path, like "www.example.com/article/topic" or "www.site.com/page/subpage"), and "description" (exactly 60 characters, a simulated meta description). IMPORTANT: All 4 suggestions must come from different websites (different domains). Return only a JSON array.`;
            
            let response, data, content;
            
            if (isOpenAI) {
                // OpenAI API request
                const requestBody = {
                    model: 'gpt-4o-mini',
                    messages: [
                        {
                            role: 'system',
                            content: systemPrompt
                        },
                        {
                            role: 'user',
                            content: userPrompt
                        }
                    ],
                    temperature: 0.7,
                    max_tokens: 300
                };
                
                response = await fetch(OPENAI_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENAI_API_KEY}`
                    },
                    body: JSON.stringify(requestBody)
                });
                
                const requestDuration = Date.now() - startTime;
                console.log(`[API-FIREFOX] Attempt ${attemptNumber} response received:`, {
                    status: response.status,
                    duration: `${requestDuration}ms`
                });
                
                if (!response.ok) {
                    let errorText;
                    try {
                        errorText = await response.text();
                    } catch (e) {
                        errorText = 'Could not read error response';
                    }
                    
                    const error = new Error(`API error: ${response.status} - ${errorText}`);
                    error.hasResponse = true;
                    throw error;
                }
                
                data = await response.json();
                content = data.choices?.[0]?.message?.content?.trim();
            } else if (AI_PROVIDER === 'claude') {
                // Claude API request
                const requestBody = {
                    model: 'claude-3-5-haiku-20241022',
                    max_tokens: 300,
                    temperature: 0.7,
                    system: systemPrompt,
                    messages: [
                        {
                            role: 'user',
                            content: userPrompt
                        }
                    ]
                };
                
                response = await fetch(CLAUDE_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': CLAUDE_API_KEY,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                const requestDuration = Date.now() - startTime;
                console.log(`[API-FIREFOX] Attempt ${attemptNumber} response received:`, {
                    status: response.status,
                    duration: `${requestDuration}ms`
                });
                
                if (!response.ok) {
                    let errorText;
                    try {
                        errorText = await response.text();
                    } catch (e) {
                        errorText = 'Could not read error response';
                    }
                    
                    const error = new Error(`API error: ${response.status} - ${errorText}`);
                    error.hasResponse = true;
                    throw error;
                }
                
                data = await response.json();
                content = data.content?.[0]?.text?.trim();
            } else {
                // OpenRouter API request
                const requestBody = {
                    model: MODEL_MAP[AI_PROVIDER] || 'anthropic/claude-3-haiku',
                    messages: [
                        {
                            role: 'system',
                            content: systemPrompt
                        },
                        {
                            role: 'user',
                            content: userPrompt
                        }
                    ],
                    temperature: 0.7,
                    max_tokens: 300
                };
                
                response = await fetch(OPENROUTER_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
                        'HTTP-Referer': window.location.origin,
                        'X-Title': 'Search Suggestions'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                const requestDuration = Date.now() - startTime;
                console.log(`[API-FIREFOX] Attempt ${attemptNumber} response received:`, {
                    status: response.status,
                    duration: `${requestDuration}ms`
                });
                
                if (!response.ok) {
                    let errorText;
                    try {
                        errorText = await response.text();
                    } catch (e) {
                        errorText = 'Could not read error response';
                    }
                    
                    const error = new Error(`API error: ${response.status} - ${errorText}`);
                    error.hasResponse = true;
                    throw error;
                }
                
                data = await response.json();
                content = data.choices[0]?.message?.content?.trim();
            }
            
            if (!content) {
                const error = new Error('Empty content in response');
                error.hasResponse = true;
                throw error;
            }
            
            // Parse JSON response - should be array of Firefox suggestion objects
            let firefoxSuggestions = [];
            try {
                // Try to parse as JSON array first (expected format)
                const jsonArrayMatch = content.match(/\[.*\]/s);
                if (jsonArrayMatch) {
                    const parsed = JSON.parse(jsonArrayMatch[0]);
                    if (Array.isArray(parsed)) {
                        firefoxSuggestions = parsed;
                    }
                } else {
                    // Try to parse as JSON object (fallback)
                    const jsonObjectMatch = content.match(/\{[\s\S]*\}/);
                    if (jsonObjectMatch) {
                        const parsed = JSON.parse(jsonObjectMatch[0]);
                        if (parsed.firefoxSuggestions && Array.isArray(parsed.firefoxSuggestions)) {
                            firefoxSuggestions = parsed.firefoxSuggestions;
                        }
                        // Fallback for old "historyTitles" key name
                        if (parsed.historyTitles && Array.isArray(parsed.historyTitles)) {
                            firefoxSuggestions = parsed.historyTitles;
                        }
                    }
                }
                
                console.log(`[API-FIREFOX] Parsed ${firefoxSuggestions.length} Firefox suggestions from response`);
                console.log(`[API-FIREFOX] First suggestion structure:`, firefoxSuggestions[0]);
            } catch (parseError) {
                console.error('[API-FIREFOX] Parse error:', parseError);
                console.error('[API-FIREFOX] Content:', content);
            }
            
            // Filter and validate Firefox suggestions
            const validFirefoxSuggestions = firefoxSuggestions
                .filter(item => {
                    if (typeof item === 'object' && item.title) {
                        return item.title && item.title.length > 0;
                    }
                    return false;
                })
                .slice(0, 4);
            
            console.log(`[API-FIREFOX] Attempt ${attemptNumber} succeeded with ${validFirefoxSuggestions.length} valid Firefox suggestions`);
            
            return validFirefoxSuggestions;
        }

        async function fetchAISuggestions(query, retryCount = 0) {
            const maxRetries = 2; // Retry up to 2 times (3 total attempts)
            console.log('[API] Starting fetchAISuggestions for query:', query, retryCount > 0 ? `(retry ${retryCount}/${maxRetries})` : '');
            
            // Check cache first (only on first attempt, not retries)
            let cachedSuggestions = null;
            let cachedFirefoxData = null;
            let cachedSelectedFirefoxSuggestions = null;
            let cachedFirefoxCountToShow = null; // Declare outside if block so it's accessible throughout function
            if (retryCount === 0) {
                cachedSuggestions = getCachedSuggestions(query);
                cachedFirefoxData = getCachedFirefoxSuggestions(query);
                if (cachedFirefoxData) {
                    cachedSelectedFirefoxSuggestions = cachedFirefoxData.selectedSuggestions;
                    cachedFirefoxCountToShow = cachedFirefoxData.countToShow;
                }
                if (cachedSuggestions && cachedSuggestions.length > 0) {
                    console.log('[API] Found', cachedSuggestions.length, 'cached suggestions');
                    // Note: We still fetch Firefox suggestions even if we have cached search suggestions
                    if (cachedSuggestions.length >= 9) {
                        console.log('[API] Have', cachedSuggestions.length, 'cached suggestions (enough for full list), but will still fetch Firefox suggestions');
                    } else {
                        console.log('[API] Only', cachedSuggestions.length, 'cached suggestions, will fetch from AI to fill remaining slots');
                    }
                }
                if (cachedSelectedFirefoxSuggestions && cachedSelectedFirefoxSuggestions.length > 0) {
                    console.log('[API-FIREFOX] Found', cachedSelectedFirefoxSuggestions.length, 'cached Firefox suggestions | Count to show:', cachedFirefoxCountToShow);
                }
            }
            
            // Make both requests concurrently (always fetch Firefox suggestions, unless we have cached ones)
            const searchPromise = fetchSearchSuggestions(query, maxRetries);
            // If we have cached selected Firefox suggestions, skip the API call entirely
            const firefoxPromise = cachedSelectedFirefoxSuggestions && cachedSelectedFirefoxSuggestions.length > 0
                ? Promise.resolve(cachedSelectedFirefoxSuggestions)
                : fetchFirefoxSuggestions(query, maxRetries);
            
            try {
                const [searchResults, firefoxResults] = await Promise.allSettled([searchPromise, firefoxPromise]);
                
                let finalSuggestions = [];
                let firefoxSuggestions = [];
                
                // Handle search suggestions
                if (searchResults.status === 'fulfilled') {
                    finalSuggestions = searchResults.value;
                    if (finalSuggestions.length > 0) {
                        cacheSuggestions(query, finalSuggestions);
                    }
                } else {
                    console.error('[API] Search suggestions failed:', searchResults.reason);
                }
                
                // Handle Firefox suggestions
                if (firefoxResults.status === 'fulfilled') {
                    firefoxSuggestions = firefoxResults.value || [];
                    console.log('[API] Received', firefoxSuggestions.length, 'Firefox suggestions');
                    if (firefoxSuggestions.length === 0) {
                        console.warn('[API] Firefox suggestions fulfilled but empty array received');
                    }
                    // Note: Caching is now handled in the processing section where we determine countToShow
                } else {
                    console.error('[API] Firefox suggestions failed:', firefoxResults.reason);
                    firefoxSuggestions = []; // Ensure it's an empty array, not undefined
                }
                
                // If we had cached suggestions, merge them with AI results
                if (cachedSuggestions && cachedSuggestions.length > 0) {
                    if (cachedSuggestions.length >= 9) {
                        // Use cached suggestions as base if we have enough
                        finalSuggestions = [...cachedSuggestions];
                        console.log('[API] Using', cachedSuggestions.length, 'cached suggestions as base');
                    } else {
                        console.log('[API] Merging', cachedSuggestions.length, 'cached suggestions with', finalSuggestions.length, 'AI suggestions');
                        // Combine cached and AI, removing duplicates
                        const combined = [...cachedSuggestions];
                        finalSuggestions.forEach(aiSuggestion => {
                            const aiLower = aiSuggestion.toLowerCase();
                            if (!combined.some(s => s.toLowerCase() === aiLower)) {
                                combined.push(aiSuggestion);
                            }
                        });
                        // Limit to 9 total (typed text is shown separately as first item)
                        finalSuggestions = combined.slice(0, 9);
                        console.log('[API] Returning', finalSuggestions.length, 'combined suggestions (', cachedSuggestions.length, 'cached +', searchResults.value?.length || 0, 'AI)');
                    }
                }
                
                // Process Firefox suggestions and replace last suggestions
                // Skip Firefox suggestions if winter olympics is active
                const suggestionsPreview = document.querySelector('.search-suggestions-preview');
                const isWinterOlympicsActive = suggestionsPreview && suggestionsPreview.classList.contains('winter-olympics-active');
                
                let selectedFirefoxSuggestions = [];
                if (firefoxSuggestions && firefoxSuggestions.length > 0 && !isWinterOlympicsActive) {
                    console.log('[API] Processing', firefoxSuggestions.length, 'Firefox suggestions');
                    
                    // Check if we have cached selected suggestions (the exact ones shown before)
                    if (cachedSelectedFirefoxSuggestions && cachedSelectedFirefoxSuggestions.length > 0) {
                        // Use cached selected suggestions directly - these are the exact ones that were shown before
                        selectedFirefoxSuggestions = cachedSelectedFirefoxSuggestions;
                        const numToReplace = cachedFirefoxCountToShow || selectedFirefoxSuggestions.length;
                        console.log('[API] Using cached Firefox suggestions directly:', selectedFirefoxSuggestions.length, '| Count to show:', numToReplace);
                        
                        // Extract titles for replacing in suggestions list
                        const firefoxTitles = selectedFirefoxSuggestions.map(item => item.title);
                        
                        console.log(`[API] Replacing last ${numToReplace} suggestions with cached Firefox titles:`, firefoxTitles);
                        console.log(`[API] Current finalSuggestions before replacement:`, finalSuggestions);
                        
                        // Replace the last N suggestions with Firefox suggestion titles
                        const actualNumToReplace = Math.min(numToReplace, Math.max(finalSuggestions.length, 0));
                        const keepCount = Math.max(0, finalSuggestions.length - actualNumToReplace);
                        
                        if (finalSuggestions.length === 0) {
                            finalSuggestions = firefoxTitles.slice(0, 9);
                        } else {
                            finalSuggestions = [
                                ...finalSuggestions.slice(0, keepCount),
                                ...firefoxTitles
                            ].slice(0, 9);
                        }
                        
                        console.log(`[API] Replaced last ${actualNumToReplace} suggestions with ${selectedFirefoxSuggestions.length} cached Firefox suggestions`);
                    } else {
                        // No cached suggestions - fetch and select new ones
                        const validFirefoxSuggestions = firefoxSuggestions
                            .filter(item => {
                                if (typeof item === 'object' && item.title) {
                                    return item.title && item.title.length > 0;
                                }
                                return false;
                            })
                            .slice(0, 4);
                        
                        console.log('[API] Valid Firefox suggestions:', validFirefoxSuggestions.length);
                        
                        if (validFirefoxSuggestions.length > 0) {
                            // Generate new count: minimum 2, maximum available (up to 4)
                            const maxCount = Math.min(validFirefoxSuggestions.length, 4);
                            const minCount = Math.min(2, maxCount); // At least 2, but not more than available
                            const numToReplace = minCount === maxCount ? maxCount : Math.floor(Math.random() * (maxCount - minCount + 1)) + minCount; // 2-4 (or 2-maxCount if less than 4)
                            console.log('[API] Generated new Firefox count to show:', numToReplace, '(min:', minCount, 'max:', maxCount, ')');
                            
                            selectedFirefoxSuggestions = validFirefoxSuggestions.slice(0, numToReplace);
                            
                            // Extract titles for replacing in suggestions list
                            const firefoxTitles = selectedFirefoxSuggestions.map(item => item.title);
                            
                            console.log(`[API] Replacing last ${numToReplace} suggestions with Firefox titles:`, firefoxTitles);
                            console.log(`[API] Current finalSuggestions before replacement:`, finalSuggestions);
                            
                            // Replace the last N suggestions with Firefox suggestion titles
                            const actualNumToReplace = Math.min(numToReplace, Math.max(finalSuggestions.length, 0));
                            const keepCount = Math.max(0, finalSuggestions.length - actualNumToReplace);
                            
                            if (finalSuggestions.length === 0) {
                                finalSuggestions = firefoxTitles.slice(0, 9);
                            } else {
                                finalSuggestions = [
                                    ...finalSuggestions.slice(0, keepCount),
                                    ...firefoxTitles
                                ].slice(0, 9);
                            }
                            
                            console.log(`[API] Replaced last ${actualNumToReplace} suggestions with ${selectedFirefoxSuggestions.length} Firefox suggestions:`, selectedFirefoxSuggestions);
                            console.log(`[API] Final suggestions after replacement:`, finalSuggestions);
                            
                            // Cache the selected Firefox suggestions (the exact ones shown) with the count
                            cacheFirefoxSuggestions(query, selectedFirefoxSuggestions, numToReplace);
                        } else {
                            console.log('[API] No valid Firefox suggestions to replace');
                        }
                    }
                } else {
                    console.log('[API] No Firefox suggestions received');
                }
                
                // Store Firefox suggestions (with full data) for later use in rendering
                finalSuggestions._firefoxSuggestions = selectedFirefoxSuggestions;
                
                // Preload images for Firefox suggestions
                if (selectedFirefoxSuggestions && selectedFirefoxSuggestions.length > 0) {
                    preloadFirefoxSuggestionImages(selectedFirefoxSuggestions);
                }
                
                // If API failed but we have cached suggestions, return those
                if (finalSuggestions.length === 0 && cachedSuggestions && cachedSuggestions.length > 0) {
                    console.log('[API] API failed, returning', cachedSuggestions.length, 'cached suggestions as fallback');
                    return cachedSuggestions;
                }
                
                return finalSuggestions;
            } catch (error) {
                console.error('[API] Error fetching suggestions:', error);
                // If API failed but we have cached suggestions, return those
                if (cachedSuggestions && cachedSuggestions.length > 0) {
                    console.log('[API] API failed, returning', cachedSuggestions.length, 'cached suggestions as fallback');
                    return cachedSuggestions;
                }
                return [];
            }
        }
        
        // Race both providers and return whichever responds first
        async function raceProviders(query, attemptNumber) {
            console.log(`[API-SEARCH] Attempt ${attemptNumber}: Racing both providers`);
            
            const providers = ['openrouter-haiku', 'openai'];
            const promises = providers.map(provider => 
                makeSearchSuggestionsRequest(query, attemptNumber, 0, provider)
                    .then(result => ({ provider, result }))
                    .catch(error => ({ provider, error }))
            );
            
            // Wait for the first successful response
            const results = await Promise.all(promises);
            const successful = results.find(r => !r.error);
            
            if (successful) {
                console.log(`[API-SEARCH] Attempt ${attemptNumber}: ${successful.provider} responded first with success`);
                return successful.result;
            }
            
            // If both failed, throw the first error
            console.error(`[API-SEARCH] Attempt ${attemptNumber}: Both providers failed`);
            throw results[0].error;
        }
        
        async function fetchSearchSuggestions(query, maxRetries = 2) {
            let resolveFirst = null;
            let rejectFirst = null;
            const firstResponsePromise = new Promise((resolve, reject) => {
                resolveFirst = resolve;
                rejectFirst = reject;
            });

            const errors = [];
            const totalAttempts = maxRetries + 1;
            let completed = false;
            let finishedAttempts = 0;

            function handleAttemptResult(attemptNumber, result, error) {
                if (completed) {
                    return;
                }

                if (error) {
                    finishedAttempts++;
                    console.log(`[API-SEARCH] Attempt ${attemptNumber} failed:`, error.message);
                    errors.push({ attempt: attemptNumber, error });

                    if (finishedAttempts === totalAttempts) {
                        completed = true;
                        rejectFirst(new Error('All search attempts failed'));
                    }
                    return;
                }

                completed = true;
                resolveFirst({ result, attempt: attemptNumber });
            }

            // Attempt 1: Use selected provider
            makeSearchSuggestionsRequest(query, 1, 0)
                .then(result => handleAttemptResult(1, result, null))
                .catch(error => handleAttemptResult(1, null, error));

            // Attempt 2: Race both providers after 2s
            setTimeout(() => {
                if (completed) {
                    return;
                }
                raceProviders(query, 2)
                    .then(result => handleAttemptResult(2, result, null))
                    .catch(error => handleAttemptResult(2, null, error));
            }, 2000);

            setTimeout(() => {
                if (completed) {
                    return;
                }
                makeSearchSuggestionsRequest(query, 3, 0)
                    .then(result => handleAttemptResult(3, result, null))
                    .catch(error => handleAttemptResult(3, null, error));
            }, 4000);

            const { result } = await firstResponsePromise;
            return result;
        }
        
        async function fetchFirefoxSuggestions(query, maxRetries = 2) {
            let resolveFirst = null;
            let rejectFirst = null;
            const firstResponsePromise = new Promise((resolve, reject) => {
                resolveFirst = resolve;
                rejectFirst = reject;
            });

            const errors = [];
            const totalAttempts = maxRetries + 1;
            let completed = false;
            let finishedAttempts = 0;

            function handleAttemptResult(attemptNumber, result, error) {
                if (completed) {
                    return;
                }

                if (error) {
                    finishedAttempts++;
                    console.log(`[API-FIREFOX] Attempt ${attemptNumber} failed:`, error.message);
                    errors.push({ attempt: attemptNumber, error });

                    if (finishedAttempts === totalAttempts) {
                        completed = true;
                        rejectFirst(new Error('All Firefox attempts failed'));
                    }
                    return;
                }

                completed = true;
                resolveFirst({ result, attempt: attemptNumber });
            }

            // Attempt 1 immediately, then additional attempts after 2s and 4s
            makeFirefoxSuggestionsRequest(query, 1, 0)
                .then(result => handleAttemptResult(1, result, null))
                .catch(error => handleAttemptResult(1, null, error));

            setTimeout(() => {
                if (completed) {
                    return;
                }
                makeFirefoxSuggestionsRequest(query, 2, 0)
                    .then(result => handleAttemptResult(2, result, null))
                    .catch(error => handleAttemptResult(2, null, error));
            }, 2000);

            setTimeout(() => {
                if (completed) {
                    return;
                }
                makeFirefoxSuggestionsRequest(query, 3, 0)
                    .then(result => handleAttemptResult(3, result, null))
                    .catch(error => handleAttemptResult(3, null, error));
            }, 4000);

            try {
                const { result } = await firstResponsePromise;
                return result;
            } catch (error) {
                console.error('[API-FIREFOX] All Firefox attempts failed, returning empty array');
                return [];
            }
        }
    </script>
    <script>
        // Set phase number for image preloader
        window.currentPhase = 5;
        if (typeof preloadCarrotImages === 'function') {
            preloadCarrotImages(5);
        }
        
        // Preload ESPN image for winter olympics background
        window.addEventListener('load', () => {
            const espnImage = new Image();
            espnImage.src = 'icons/espn2.jpg';
        });
    </script>
</head>
<body class="ut-page">
    <div class="server-selector">
        <select id="server-selector" aria-label="Select AI server">
            <option value="openrouter-haiku">Server 1</option>
            <option value="openai">Server 2</option>
        </select>
    </div>
    <section class="pane pane--bottom">
        <div class="bottom-overlay" aria-hidden="true"></div>
        <div class="top-overlay">
            <div class="winter-olympics-background"></div>
            <img src="icons/Fx-Browser-icon-fullColor-64.png" alt="Firefox" class="firefox-logo">
            <button class="close-button" type="button" aria-label="Close search panel">
                <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>
            <div class="vpn-indicator" id="vpn-indicator">
                <span class="vpn-indicator-dot"></span>
                <span>VPN</span>
            </div>
            <div class="info-icon-wrapper">
                <button class="info-icon-button" type="button" aria-label="Show demo searches">
                    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/>
                        <path d="M12 16V12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        <circle cx="12" cy="8" r="1" fill="currentColor"/>
                    </svg>
                </button>
                <div class="demo-searches-card">
                    <div class="demo-searches-earlier">
                        <ul>
                            <li>• fox wiki</li>
                            <li>• sneakers</li>
                            <li>• chair / ramen / sushi</li>
                            <li>• uber stock</li>
                            <li>• lakers game</li>
                            <li>• AC8170</li>
                            <li>• coffee shops</li>
                            <li>• weather</li>
                            <li>• time rome</li>
                            <li>• $100 in euros</li>
                            <li>• hello in italian</li>
                            <li>• renewable energy</li>
                            <li>• winter olympics</li>
                            <li>• vpn</li>
                            <li>• MDN</li>
                            <li>• youtube</li>
                            <li>• happy emoji</li>
                        </ul>
                        <button type="button" class="clear-history-button" style="margin-top: 12px; padding: 6px 12px; background-color: #F3F4F6; border: 1px solid #D1D5DB; border-radius: 6px; cursor: pointer; font-size: 12px; color: #374151; transition: background-color 0.2s ease;">Reset prototype</button>
                    </div>
                </div>
            </div>
            <!-- DEBUG BUTTONS - DO NOT DELETE! Uncomment for testing/development -->
            <!--
            <div class="debug-buttons">
                <button class="debug-button" type="button">1. No enriched content</button>
                <button class="debug-button" type="button">2. Local recommendations</button>
                <button class="debug-button" type="button">3. Flights (AC 8170)</button>
                <button class="debug-button" type="button">4. Wikipedia</button>
                <button class="debug-button" type="button">5. Weather</button>
                <button class="debug-button" type="button">6. Sports</button>
                <button class="debug-button" type="button">7. Stocks</button>
                <button class="debug-button" type="button">8. World clock</button>
                </div>
            <div class="debug-buttons-bottom">
                <button class="debug-button" type="button">A</button>
                <button class="debug-button" type="button">B</button>
                <button class="debug-button" type="button">C</button>
                <button class="debug-button" type="button">D</button>
                <button class="debug-button" type="button">E</button>
                </div>
            -->
            <button class="search-background-bottom-overlay" type="button">
                <span class="visually-hidden">Collapse search overlay</span>
                <svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                    <path class="chevron-shallow" d="M4 20L16 15L28 20" stroke="#6B7280" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path class="chevron-steep" d="M6 20L16 12L26 20" stroke="#6B7280" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>
            <div class="search-container">
                <div class="search-wrapper">
                    <div class="search-input-shell">
                        <div class="search-dropdown-button">
                            <span class="circle-icon">
                                <img src="icons/Google.svg" alt="Search options" class="circle-icon__image">
                            </span>
                            <img src="icons/chevron.svg" alt="Expand" class="chevron">
            </div>
                        <input type="text" class="search-box" placeholder="Search or start browsing">
                        <button type="button" class="search-clear-button" aria-label="Clear search" style="display: none;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </button>
                </div>
                    <div class="search-suggestions-preview" aria-hidden="true">
                        <div class="search-suggestions-divider"></div>
                        <div class="local-carrot-row" aria-hidden="true"></div>
                        <div class="search-suggestions-preview-column-container expand-left">
                        <ul class="search-suggestions-preview-list">
                            <li class="search-suggestions-preview-item">
                                <img src="icons/clock.svg" alt="" aria-hidden="true" class="suggestion-icon">
                                <span class="label">hoka</span>
                            </li>
                            <li class="search-suggestions-preview-item">
                                <img src="icons/clock.svg" alt="" aria-hidden="true" class="suggestion-icon">
                                <span class="label">macbook</span>
                            </li>
                            <li class="search-suggestions-preview-item">
                                <img src="icons/clock.svg" alt="" aria-hidden="true" class="suggestion-icon">
                                <span class="label">13 in macbook air</span>
                            </li>
                            <li class="search-suggestions-preview-item">
                                <img src="icons/clock.svg" alt="" aria-hidden="true" class="suggestion-icon">
                                <span class="label">Coffee machines for sale</span>
                            </li>
                            <li class="search-suggestions-preview-item">
                                <img src="icons/clock.svg" alt="" aria-hidden="true" class="suggestion-icon">
                                <span class="label">taylor swift</span>
                            </li>
                            <li class="search-suggestions-preview-item">
                                <img src="icons/clock.svg" alt="" aria-hidden="true" class="suggestion-icon">
                                <span class="label">coffee grinder</span>
                            </li>
                            <li class="search-suggestions-preview-item">
                                <img src="icons/clock.svg" alt="" aria-hidden="true" class="suggestion-icon">
                                <span class="label">gmail</span>
                            </li>
                        </ul>
                        <div class="preview-box"></div>
                            <ul class="search-suggestions-preview-list">
                                <li class="search-suggestions-preview-item carrot">
                                    <div class="carrot-tile" aria-hidden="true"></div>
                                    <div class="carrot-lines">
                                        <p class="carrot-line">Departure <strong>9:21pm</strong> Chicago (CHI)</p>
                                        <p class="carrot-line">Arrival <strong>11:42am</strong> Vancouver (VYR)</p>
                                        <p class="carrot-line carrot-line--meta"><span class="carrot-line green-text">In flight</span> · Today · AC 8170</p>
            </div>
                                </li>
                                <li class="search-suggestions-preview-item carrot">
                                    <div class="carrot-tile" aria-hidden="true"></div>
                                    <div class="carrot-lines">
                                        <p class="carrot-line">Departure <strong>7:05am</strong> New York (JFK)</p>
                                        <p class="carrot-line">Arrival <strong>9:18am</strong> Toronto (YYZ)</p>
                                        <p class="carrot-line carrot-line--meta">Boarding · Thu, June 5 · DL 4732</p>
        </div>
                                </li>
                                <li class="search-suggestions-preview-item carrot">
                                    <div class="carrot-tile" aria-hidden="true"></div>
                                    <div class="carrot-lines">
                                        <p class="carrot-line">Departure <strong>2:45pm</strong> Los Angeles (LAX)</p>
                                        <p class="carrot-line">Arrival <strong>6:10pm</strong> Seattle (SEA)</p>
                                        <p class="carrot-line carrot-line--meta">Scheduled · Fri, June 6 · AS 124</p>
                        </div>
                                </li>
                            </ul>
                    </div>
                </div>
                </div>
                <div class="search-description">
                    <div class="overlay-product-grid" data-product-grid data-product-sections="history,openTabs,bookmarks,articles"></div>
                </div>
            </div>
        </div>
        <div class="bottom-content">
                <div class="quick-tiles" aria-hidden="true">
                    <a href="https://www.google.com" target="_blank" class="quick-tiles__tile">
                        <img src="favicons/Google.svg" alt="" class="quick-tiles__favicon">
                        <span class="quick-tiles__label">Google</span>
                    </a>
                    <a href="https://www.youtube.com" target="_blank" class="quick-tiles__tile">
                        <img src="favicons/YouTube.svg" alt="" class="quick-tiles__favicon">
                        <span class="quick-tiles__label">YouTube</span>
                    </a>
                    <a href="https://www.instagram.com" target="_blank" class="quick-tiles__tile">
                        <img src="favicons/Instagram.svg" alt="" class="quick-tiles__favicon">
                        <span class="quick-tiles__label">Instagram</span>
                    </a>
                    <a href="https://www.reddit.com" target="_blank" class="quick-tiles__tile">
                        <img src="favicons/Reddit.svg" alt="" class="quick-tiles__favicon">
                        <span class="quick-tiles__label">Reddit</span>
                    </a>
                    <a href="https://twitter.com" target="_blank" class="quick-tiles__tile">
                        <img src="favicons/Twitter.svg" alt="" class="quick-tiles__favicon">
                        <span class="quick-tiles__label">Twitter</span>
                    </a>
                    <a href="https://www.wikipedia.org" target="_blank" class="quick-tiles__tile">
                        <img src="favicons/Wikipedia.svg" alt="" class="quick-tiles__favicon">
                        <span class="quick-tiles__label">Wikipedia</span>
                    </a>
                    <a href="https://www.facebook.com" target="_blank" class="quick-tiles__tile">
                        <img src="favicons/Facebook.svg" alt="" class="quick-tiles__favicon">
                        <span class="quick-tiles__label">Facebook</span>
                    </a>
                    <a href="https://slack.com" target="_blank" class="quick-tiles__tile">
                        <img src="favicons/Slack.svg" alt="" class="quick-tiles__favicon">
                        <span class="quick-tiles__label">Slack</span>
                    </a>
                </div>
                <h1 class="heading">Thought-provoking stories</h1>
                <div class="articles-grid">
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>The Surprising Science Behind Lightning</h2>
                    <p>SELF G</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>Ten People Go on Trial in Paris</h2>
                    <p>The Guardian</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>Can Dogs Sense Ghosts?</h2>
                    <p>Popular Science</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>11 One-Pot Gut-Healthy Dinners</h2>
                    <p>Eating Well</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>The Dark Side of Mirrors in Space</h2>
                    <p>Nautilus</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>UK Regional Airline Suspends Ops</h2>
                    <p>Sky</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>The Internet Is Going to Break Again</h2>
                    <p>Sky</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>The 1 Surprising Snack People Eat</h2>
                    <p>Eating Well</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>Reclaiming 72 Hours a Week</h2>
                    <p>Sky</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>Hidden Dangers in Fast Food</h2>
                    <p>Health Digest</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>Exploring Virtual Reality</h2>
                    <p>Tech Today</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>Unveiling the Quantum Age</h2>
                    <p>Scientific Insights</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>Breakthroughs in Renewable Energy</h2>
                    <p>Eco World</p>
                    <p class="sponsored-label">Sponsored</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>Astronomy's New Frontiers</h2>
                    <p>Space Observer</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>Innovative Designs in Architecture</h2>
                    <p>Modern Home</p>
                </a>
            </div>
            <div class="footer-links">
                <a href="#" class="footer-link">Mozilla</a>
                <div class="footer-links-right">
                    <a href="#" class="footer-link">Privacy Notice</a>
                    <a href="#" class="footer-link">Customize New Tab</a>
                </div>
            </div>
        </div>
    </section>
    <script>
        const apiKey = window.API_CONFIG?.PEXELS_API_KEY || '';
        const keywords = [
            'UTI', 'trial Paris', 'ghosts',
            'healthy dinner', 'mirrors space', 'UK airline',
            'internet', 'snack', 'productivity',
            'fast food', 'virtual reality', 'quantum physics',
            'renewable energy', 'astronomy', 'architecture'
        ];

        // Store original product grid content for restoration
        let originalProductGridContent = null;
        let originalProductGridSections = null;

        const renderOverlayProductGrid = () => {
            const container = document.querySelector('[data-product-grid]');
            if (!container || typeof productContent?.renderInto !== 'function') {
                return;
            }

            const sectionAttr = container.getAttribute('data-product-sections');
            const sectionKeys = sectionAttr ? sectionAttr.split(',').map((section) => section.trim()).filter(Boolean) : undefined;

            // Store original content if not already stored
            if (!originalProductGridSections) {
                originalProductGridSections = sectionKeys;
            }

            productContent.renderInto(container, sectionKeys);
            
            // Attach close button handlers for product cards
            attachProductCardCloseHandlers();
        };
        
        function attachProductCardCloseHandlers() {
            const productCards = document.querySelectorAll('.overlay-product-close-button');
            productCards.forEach(button => {
                // Remove any existing listeners by cloning the button
                const newButton = button.cloneNode(true);
                button.replaceWith(newButton);
                
                newButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Find the parent product card
                    const productCard = newButton.closest('.overlay-product-card');
                    if (productCard) {
                        // Remove the card from the DOM
                        productCard.remove();
                    }
                });
            });
        }

        // Function to render Winter Olympics schedule
        const renderWinterOlympicsSchedule = () => {
            const container = document.querySelector('[data-product-grid]');
            if (!container) return;

            // Store original content if not already stored
            if (!originalProductGridContent && container.innerHTML.trim()) {
                originalProductGridContent = container.innerHTML;
            }

            // Add class to suggestions container to make it half height
            const suggestionsPreview = document.querySelector('.search-suggestions-preview');
            if (suggestionsPreview) {
                suggestionsPreview.classList.add('winter-olympics-active');
            }

            container.innerHTML = `
                <div class="winter-olympics-schedule" style="grid-column: 1 / -1; display: flex; flex-direction: column; gap: 8px;">
                    <div class="overlay-product-column" style="grid-column: 1 / -1;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px;">
                            <div>
                                <p style="margin: 0 0 4px 0; font-size: 32px; font-weight: 500; color: #1F2933; text-shadow: 0 0 16px rgba(255, 255, 255, 1), 0 0 12px rgba(255, 255, 255, 1), 0 0 8px rgba(255, 255, 255, 0.9), 0 0 4px rgba(255, 255, 255, 0.8);">Winter Olympics 2026</p>
                                <p style="margin: 0; font-size: 16px; color: #6B7280; text-shadow: 0 0 14px rgba(255, 255, 255, 1), 0 0 10px rgba(255, 255, 255, 0.9), 0 0 6px rgba(255, 255, 255, 0.8), 0 0 3px rgba(255, 255, 255, 0.7);">Milan-Cortina, Italy · Sponsored by ESPN</p>
                            </div>
                            <div style="display: flex; align-items: center; gap: 56px;">
                                <img src="icons/espn.svg" alt="ESPN" style="flex-shrink: 0; width: 140px; height: auto; filter: drop-shadow(0 0 12px rgba(255, 255, 255, 1)) drop-shadow(0 0 8px rgba(255, 255, 255, 0.9)) drop-shadow(0 0 4px rgba(255, 255, 255, 0.8));">
                                <img src="icons/olympics.svg" alt="Olympics" style="flex-shrink: 0; width: 140px; height: auto; filter: drop-shadow(0 0 12px rgba(255, 255, 255, 1)) drop-shadow(0 0 8px rgba(255, 255, 255, 0.9)) drop-shadow(0 0 4px rgba(255, 255, 255, 0.8));">
                                <img src="icons/Fx-Browser-icon-fullColor-64.png" alt="Firefox" style="flex-shrink: 0; width: 48px; height: 48px; filter: drop-shadow(0 0 12px rgba(255, 255, 255, 1)) drop-shadow(0 0 8px rgba(255, 255, 255, 0.9)) drop-shadow(0 0 4px rgba(255, 255, 255, 0.8));">
                            </div>
                        </div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-top: 24px;">
                        <div class="overlay-product-card olympics-card-blue" style="flex-direction: column; height: auto; padding: 16px;">
                            <div style="font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: #6B7280; margin-bottom: 8px;">Today</div>
                            <div class="overlay-product-title" style="font-size: 16px; font-weight: 500; margin-bottom: 4px; color: #1F2933;">Alpine Skiing</div>
                            <div style="font-size: 13px; color: #6B7280;">Men's Downhill • 10:00 AM</div>
                        </div>
                        <div class="overlay-product-card olympics-card-black" style="flex-direction: column; height: auto; padding: 16px;">
                            <div style="font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: #6B7280; margin-bottom: 8px;">Today</div>
                            <div class="overlay-product-title" style="font-size: 16px; font-weight: 500; margin-bottom: 4px; color: #1F2933;">Figure Skating</div>
                            <div style="font-size: 13px; color: #6B7280;">Pairs Short Program • 2:30 PM</div>
                        </div>
                        <div class="overlay-product-card olympics-card-red" style="flex-direction: column; height: auto; padding: 16px;">
                            <div style="font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: #6B7280; margin-bottom: 8px;">Tomorrow</div>
                            <div class="overlay-product-title" style="font-size: 16px; font-weight: 500; margin-bottom: 4px; color: #1F2933;">Ice Hockey</div>
                            <div style="font-size: 13px; color: #6B7280;">USA vs Canada • 8:00 PM</div>
                        </div>
                        <div class="overlay-product-card olympics-card-yellow" style="flex-direction: column; height: auto; padding: 16px;">
                            <div style="font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: #6B7280; margin-bottom: 8px;">Feb 8</div>
                            <div class="overlay-product-title" style="font-size: 16px; font-weight: 500; margin-bottom: 4px; color: #1F2933;">Snowboarding</div>
                            <div style="font-size: 13px; color: #6B7280;">Men's Halfpipe Final • 11:00 AM</div>
                        </div>
                    </div>
                </div>
            `;
        };

        // Function to restore original product grid
        const restoreProductGrid = () => {
            const container = document.querySelector('[data-product-grid]');
            if (!container) return;

            // Remove winter olympics class from suggestions container
            const suggestionsPreview = document.querySelector('.search-suggestions-preview');
            if (suggestionsPreview) {
                suggestionsPreview.classList.remove('winter-olympics-active');
            }
            // Re-enable scrolling
            document.body.classList.remove('winter-olympics-active');
            document.documentElement.classList.remove('winter-olympics-active');

            if (originalProductGridContent) {
                container.innerHTML = originalProductGridContent;
            } else if (originalProductGridSections) {
                renderOverlayProductGrid();
            }
        };

        const fetchImages = async () => {
            const imageUrls = [];

            for (const keyword of keywords) {
                try {
                    const response = await fetch(`https://api.pexels.com/v1/search?query=${encodeURIComponent(keyword)}&per_page=1`, {
                    headers: {
                        Authorization: apiKey
                    }
                });

                    if (!response.ok) {
                        throw new Error(`Pexels request failed: ${response.status}`);
                    }

                const data = await response.json();
                    const photoUrl = data.photos && data.photos[0] ? data.photos[0].src.medium : null;
                    imageUrls.push(photoUrl || 'https://via.placeholder.com/600x400?text=Image');
                } catch (error) {
                    console.error('Error fetching image for keyword:', keyword, error);
                    imageUrls.push('https://via.placeholder.com/600x400?text=Image');
            }
            }

            return imageUrls;
        };

        const updateImages = async () => {
            const imagePlaceholders = document.querySelectorAll('.image-placeholder');
            if (!imagePlaceholders.length) {
                return;
            }

            const images = await fetchImages();

            imagePlaceholders.forEach((placeholder, index) => {
                const img = document.createElement('img');
                img.src = images[index] || 'https://via.placeholder.com/600x400?text=Image';
                img.alt = placeholder.nextElementSibling ? placeholder.nextElementSibling.textContent : 'Article image';
                img.style.width = '100%';
                img.style.height = '160px';
                img.style.objectFit = 'cover';
                placeholder.replaceWith(img);
            });
        };

        document.addEventListener('DOMContentLoaded', () => {
            renderOverlayProductGrid();
            updateImages();
            // Attach hover listeners to initial suggestions
            attachHoverListeners();
        });

        const topOverlay = document.querySelector('.top-overlay');
        const bottomOverlay = document.querySelector('.bottom-overlay');
        const searchWrapperElement = document.querySelector('.search-wrapper');
        const searchDescriptionElement = document.querySelector('.search-description');
        const searchSuggestionsPreviewElement = document.querySelector('.search-suggestions-preview');
        const searchBoxElement = document.querySelector('.search-box');
        const searchClearButton = document.querySelector('.search-clear-button');
        const searchContainer = document.querySelector('.search-container');
        const productContainers = Array.from(document.querySelectorAll('.search-wrapper-products, .search-description'));
        const resizeObservers = [];

        const updateSearchContentOffset = () => {
            if (!searchWrapperElement || !searchContainer) {
                return;
            }

            const wrapperRect = searchWrapperElement.getBoundingClientRect();
            const containerRect = searchContainer.getBoundingClientRect();
            const spacing = 32;
            const offset = Math.max(wrapperRect.bottom - containerRect.top + spacing, spacing);

            searchContainer.style.setProperty('--search-wrapper-offset', `${offset}px`);
        };

        if (searchWrapperElement && searchContainer) {
            updateSearchContentOffset();

            if (typeof ResizeObserver === 'function') {
                const wrapperObserver = new ResizeObserver(updateSearchContentOffset);
                wrapperObserver.observe(searchWrapperElement);
                resizeObservers.push(wrapperObserver);

                productContainers.forEach((container) => {
                    if (container) {
                        const containerObserver = new ResizeObserver(updateSearchContentOffset);
                        containerObserver.observe(container);
                        resizeObservers.push(containerObserver);
                    }
                });
            }

            window.addEventListener('resize', updateSearchContentOffset);
        }

        const localCarrotRow = document.querySelector('.local-carrot-row');
        const showAdMarketplaceCarrots = () => {
            if (!localCarrotRow) {
                return;
            }

            localCarrotRow.innerHTML = `<ul class="local-carrot-grid">${carrotTemplates.adMarketplace()}</ul>`;
            localCarrotRow.classList.add('is-visible');
            localCarrotRow.setAttribute('aria-hidden', 'false');

            if (suggestionsContainer) {
                suggestionsContainer.classList.add('local-horizontal');
                suggestionsContainer.classList.remove('show-carrot');
                suggestionsContainer.classList.remove('expand-left');
            }

            if (carrotList) {
                carrotList.innerHTML = '';
                carrotList.dataset.carrotState = '0';
            }
        };

        const hideLocalCarrots = () => {
            if (!localCarrotRow) {
                return;
            }

            localCarrotRow.innerHTML = '';
            localCarrotRow.classList.remove('is-visible');
            localCarrotRow.setAttribute('aria-hidden', 'true');

            if (suggestionsContainer) {
                suggestionsContainer.classList.remove('local-horizontal');
                if (!carrotList || !carrotList.innerHTML.trim()) {
                    suggestionsContainer.classList.remove('show-carrot');
                }
            }
        };

        if (document.readyState !== 'loading') {
            if (searchBoxElement) {
                searchBoxElement.value = '';
            }
        } else {
            document.addEventListener('DOMContentLoaded', () => {
                if (searchBoxElement) {
                    searchBoxElement.value = '';
                }
            });
        }
 
         const OVERLAY_STATE_KEY = 'overlayExpanded';
         const OVERLAY_RESTORE_KEY = 'overlayRestorePending';
 
         const elementsForTransitionControl = [topOverlay, bottomOverlay, searchWrapperElement, searchDescriptionElement, searchSuggestionsPreviewElement];

        const setOverlayState = (expanded, { suppressTransition = false } = {}) => {
            if (!topOverlay || !bottomOverlay || !searchWrapperElement || !searchDescriptionElement || !searchSuggestionsPreviewElement) {
                return;
            }

            if (suppressTransition) {
                elementsForTransitionControl.forEach((el) => el && el.classList.add('no-transition'));
            }

            if (expanded) {
                topOverlay.classList.add('is-focused');
                searchWrapperElement.classList.add('expanded');
                searchDescriptionElement.classList.add('expanded');
                bottomOverlay.style.top = '85vh';
                bottomOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
                bottomOverlay.style.pointerEvents = 'auto';
            } else {
                topOverlay.classList.remove('is-focused');
                topOverlay.classList.remove('winter-olympics');
                // Re-enable scrolling
                document.body.classList.remove('winter-olympics-active');
                document.documentElement.classList.remove('winter-olympics-active');
                searchWrapperElement.classList.remove('expanded');
                searchDescriptionElement.classList.remove('expanded');
                // Clear any inline height styles to return to starting state
                searchWrapperElement.style.height = '';
                searchWrapperElement.style.minHeight = '';
                searchWrapperElement.style.maxHeight = '';
                if (searchBoxElement) {
                    searchBoxElement.style.height = '';
                    searchBoxElement.style.minHeight = '';
                    searchBoxElement.style.maxHeight = '';
                }
                // Clear height styles on suggestions preview container
                if (searchSuggestionsPreviewElement) {
                    searchSuggestionsPreviewElement.style.height = '';
                    searchSuggestionsPreviewElement.style.minHeight = '';
                    searchSuggestionsPreviewElement.style.maxHeight = '';
                }
                // Clear height styles on column container if it exists
                const columnContainer = document.querySelector('.search-suggestions-preview-column-container');
                if (columnContainer) {
                    columnContainer.style.height = '';
                    columnContainer.style.minHeight = '';
                    columnContainer.style.maxHeight = '';
                }
                bottomOverlay.style.top = '130px';
                bottomOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0)';
                bottomOverlay.style.pointerEvents = 'none';
            }

            sessionStorage.setItem(OVERLAY_STATE_KEY, expanded ? 'true' : 'false');

        if (typeof requestAnimationFrame === 'function') {
            requestAnimationFrame(() => updateSearchContentOffset());
        } else {
            updateSearchContentOffset();
        }

            if (suppressTransition) {
                requestAnimationFrame(() => {
                    elementsForTransitionControl.forEach((el) => el && el.classList.remove('no-transition'));
                });
            }
        };

        if (topOverlay && bottomOverlay) {
            const handleOverlayBackground = () => {
                const scrolled = window.scrollY > 0;
                topOverlay.classList.toggle('is-scrolled', scrolled);
            };
            handleOverlayBackground();
            window.addEventListener('scroll', handleOverlayBackground, { passive: true });
        }

        // Animate gradient border
        const searchWrapper = document.querySelector('.search-wrapper');
        let gradientAnimationId = null;
        let gradientAngle = 0;

        const animateGradient = () => {
            if (searchWrapper && searchBoxElement && document.activeElement === searchBoxElement) {
                gradientAngle = (gradientAngle + 1.2) % 360;
                const beforeElement = window.getComputedStyle(searchWrapper, '::before');
                searchWrapper.style.setProperty('--gradient-angle', `${gradientAngle}deg`);
                // Directly update the background of the pseudo-element
                const style = document.createElement('style');
                style.id = 'gradient-animation-style';
                const existingStyle = document.getElementById('gradient-animation-style');
                if (existingStyle) {
                    existingStyle.remove();
                }
                style.textContent = `.search-wrapper:focus-within::before { background: conic-gradient(from ${gradientAngle}deg, #945AF2 0%, #F37E49 71%, #945AF2 100%); }`;
                document.head.appendChild(style);
                gradientAnimationId = requestAnimationFrame(animateGradient);
            } else {
                const existingStyle = document.getElementById('gradient-animation-style');
                if (existingStyle) {
                    existingStyle.remove();
                }
                if (gradientAnimationId) {
                    cancelAnimationFrame(gradientAnimationId);
                    gradientAnimationId = null;
                }
            }
        };

        if (topOverlay && searchBoxElement && bottomOverlay) {
            searchBoxElement.addEventListener('focus', () => {
                setOverlayState(true);
                // Check if search box contains "winter ol" and apply background/schedule
                const currentValue = searchBoxElement.value.toLowerCase().trim();
                if (currentValue === 'winter ol' || currentValue.startsWith('winter ol')) {
                    if (topOverlay) {
                        topOverlay.classList.add('winter-olympics');
                    }
                    // Prevent scrolling
                    document.body.classList.add('winter-olympics-active');
                    document.documentElement.classList.add('winter-olympics-active');
                    renderWinterOlympicsSchedule();
                }
                setTimeout(() => {
                    if (!gradientAnimationId) {
                        animateGradient();
                    }
                }, 50);
            });

            searchBoxElement.addEventListener('blur', () => {
                const existingStyle = document.getElementById('gradient-animation-style');
                if (existingStyle) {
                    existingStyle.remove();
                }
                if (gradientAnimationId) {
                    cancelAnimationFrame(gradientAnimationId);
                    gradientAnimationId = null;
                }
            });
        }

        const overlayCloseButton = document.querySelector('.search-background-bottom-overlay');
        if (overlayCloseButton && searchBoxElement) {
            overlayCloseButton.addEventListener('click', () => {
                setOverlayState(false);
                searchBoxElement.blur();
            });
        }

        const closeButton = document.querySelector('.close-button');
        if (closeButton && searchBoxElement) {
            closeButton.addEventListener('click', () => {
                const existingStyle = document.getElementById('gradient-animation-style');
                if (existingStyle) {
                    existingStyle.remove();
                }
                if (gradientAnimationId) {
                    cancelAnimationFrame(gradientAnimationId);
                    gradientAnimationId = null;
                }
                // Reset winter olympics background if active
                if (topOverlay && topOverlay.classList.contains('winter-olympics')) {
                    topOverlay.classList.remove('winter-olympics');
                    // Re-enable scrolling
                    document.body.classList.remove('winter-olympics-active');
                    document.documentElement.classList.remove('winter-olympics-active');
                    restoreProductGrid();
                }
                setOverlayState(false);
                searchBoxElement.blur();
            });
        }

        // Toggle demo searches card on info icon click
        const infoIconButton = document.querySelector('.info-icon-button');
        const infoIconWrapper = document.querySelector('.info-icon-wrapper');
        if (infoIconButton && infoIconWrapper) {
            infoIconButton.addEventListener('click', (e) => {
                e.stopPropagation();
                infoIconWrapper.classList.toggle('is-open');
            });
        }

        // Reset prototype button - clears all localStorage
        const clearHistoryButton = document.querySelector('.clear-history-button');
        if (clearHistoryButton) {
            clearHistoryButton.addEventListener('click', (e) => {
                e.stopPropagation();
                try {
                    // Clear all localStorage items
                    localStorage.clear();
                    clearHistoryButton.textContent = 'Prototype reset';
                    clearHistoryButton.style.backgroundColor = '#D1FAE5';
                    clearHistoryButton.style.color = '#065F46';
                    setTimeout(() => {
                        clearHistoryButton.textContent = 'Reset prototype';
                        clearHistoryButton.style.backgroundColor = '#F3F4F6';
                        clearHistoryButton.style.color = '#374151';
                    }, 2000);
                } catch (error) {
                    console.error('Error resetting prototype:', error);
                    clearHistoryButton.textContent = 'Error resetting';
                    setTimeout(() => {
                        clearHistoryButton.textContent = 'Reset prototype';
                    }, 2000);
                }
            });
        }

        if (bottomOverlay && searchBoxElement) {
            bottomOverlay.addEventListener('click', () => {
                if (topOverlay && topOverlay.classList.contains('is-focused')) {
                    setOverlayState(false);
                    searchBoxElement.blur();
                }
            });
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && topOverlay && topOverlay.classList.contains('is-focused') && searchBoxElement) {
                setOverlayState(false);
                searchBoxElement.blur();
            }
        });

        if (topOverlay && bottomOverlay) {
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'hidden') {
                    sessionStorage.setItem(OVERLAY_STATE_KEY, topOverlay.classList.contains('is-focused') ? 'true' : 'false');
                    sessionStorage.setItem(OVERLAY_RESTORE_KEY, 'true');
                } else if (document.visibilityState === 'visible') {
                    const shouldRestore = sessionStorage.getItem(OVERLAY_RESTORE_KEY) === 'true';
                    if (shouldRestore) {
                        const shouldExpand = sessionStorage.getItem(OVERLAY_STATE_KEY) === 'true';
                        setOverlayState(shouldExpand, { suppressTransition: true });
                        sessionStorage.setItem(OVERLAY_RESTORE_KEY, 'false');
                    }
                }
            });
        }

        // Debug button handlers
        const debugButtons = document.querySelectorAll('.debug-buttons .debug-button');
        const suggestionsContainer = document.querySelector('.search-suggestions-preview-column-container');
        const carrotList = document.querySelector('.search-suggestions-preview-list:last-child');
        const suggestionsList = document.querySelector('.search-suggestions-preview-list:first-child');
        
        let currentState = 0; // Track current state
        let lastCarrotContext = null;
        let suspendedCarrotContext = null;
        let suspendedByFirefoxUrls = new Set(); // Track which Firefox URLs were displayed when carrot was suspended
        let selectedSuggestionIndex = -1; // Track selected suggestion index (only one at a time)
        let suggestionsJustUpdated = false; // Track if suggestions were just updated to prevent stale hover
        let isKeyboardNavigating = false; // Track if user is using keyboard navigation
        let currentDisplayedSuggestions = []; // Track currently displayed suggestions for incremental filtering
        let currentFirefoxSuggestions = []; // Track current Firefox suggestions (full objects) for incremental filtering
        
        // Fixed skeleton widths for each row position (1-10)
        // Range: 60-160px (shortest is now 60px instead of 30px, longest stays at 160px)
        const skeletonWidths = [
            Math.floor(Math.random() * 100) + 60, // Row 1
            Math.floor(Math.random() * 100) + 60, // Row 2
            Math.floor(Math.random() * 100) + 60, // Row 3
            Math.floor(Math.random() * 100) + 60, // Row 4
            Math.floor(Math.random() * 100) + 60, // Row 5
            Math.floor(Math.random() * 100) + 60, // Row 6
            Math.floor(Math.random() * 100) + 60, // Row 7
            Math.floor(Math.random() * 100) + 60, // Row 8
            Math.floor(Math.random() * 100) + 60, // Row 9
            Math.floor(Math.random() * 100) + 60  // Row 10
        ];
        
        // Mapping of demo search terms to carrot states
        const demoSearchCarrots = {
            'fox wiki': 2,        // wikipedia
            'wiki fox': 2,        // wikipedia
            'chair': 8,          // adMarketplace
            'ramen': 18,         // adMarketplaceRamen
            'sushi': 19,         // adMarketplaceSushi
            'sneakers': 9,       // bigAd
            'uber stock': 6,     // stocks
            'stocks': 20,        // stocksETFs
            'ac8170': 1,         // flights
            'lakers game': 5,    // sports
            'coffee shops': 0,   // local
            'weather': 4,         // weather
            'vpn': 13,           // vpn
            'mdn': 10,           // mdn
            'array': 10,         // mdn
            'youtube': 12,       // youtube
            'time rome': 7,     // worldClock
            'happy emoji': 11,   // happyEmoji
            'renewable energy': 16  // renewableEnergy
        };
        
        // Function to detect currency conversion patterns
        const detectCurrencyMatch = (query) => {
            const queryLower = query.toLowerCase().trim();
            
            // Currency codes mapping
            const currencyCodes = {
                'usd': 'USD', 'dollar': 'USD', 'dollars': 'USD', 'us': 'USD',
                'eur': 'EUR', 'euro': 'EUR', 'euros': 'EUR', '€': 'EUR',
                'gbp': 'GBP', 'pound': 'GBP', 'pounds': 'GBP', 'sterling': 'GBP', 'uk': 'GBP',
                'jpy': 'JPY', 'yen': 'JPY', 'japan': 'JPY',
                'cad': 'CAD', 'canadian': 'CAD', 'canada': 'CAD',
                'aud': 'AUD', 'australian': 'AUD', 'australia': 'AUD'
            };
            
            // Country to currency mapping
            const countryToCurrency = {
                'italy': 'EUR', 'france': 'EUR', 'germany': 'EUR', 'spain': 'EUR', 'portugal': 'EUR',
                'netherlands': 'EUR', 'belgium': 'EUR', 'austria': 'EUR', 'greece': 'EUR',
                'uk': 'GBP', 'united kingdom': 'GBP', 'britain': 'GBP', 'england': 'GBP',
                'japan': 'JPY',
                'canada': 'CAD',
                'australia': 'AUD'
            };
            
            // Pattern 1: $XX in euros / $XX in italy / $XX EUR / $XX in [country]
            let match = queryLower.match(/^\$(\d{1,4})\s+(?:in\s+)?(italy|france|germany|spain|portugal|netherlands|belgium|austria|greece|uk|united kingdom|britain|england|japan|canada|australia|euros?|eur|euro|€)/);
            if (match) {
                const amount = match[1];
                const target = match[2];
                const toCurrency = countryToCurrency[target] || currencyCodes[target] || 'EUR';
                return { amount, fromCurrency: 'USD', toCurrency, state: 14 };
            }
            
            // Pattern 2: XXUSD in italy / XX USD in italy / XXUSD EUR
            match = queryLower.match(/^(\d{1,4})\s*(?:usd|dollars?|dollar)\s+(?:in\s+)?(italy|france|germany|spain|portugal|netherlands|belgium|austria|greece|eur|euros?|euro|€)/);
            if (match) {
                const amount = match[1];
                const target = match[2];
                const toCurrency = countryToCurrency[target] || currencyCodes[target] || 'EUR';
                return { amount, fromCurrency: 'USD', toCurrency, state: 14 };
            }
            
            // Pattern 3: XX USD to EUR / XX USD EUR / convert XX USD to EUR
            match = queryLower.match(/(?:convert\s+)?(\d{1,4})\s*(?:usd|dollars?|dollar)\s+(?:to\s+)?(eur|euros?|euro|gbp|pounds?|pound|jpy|yen|cad|aud|€)/);
            if (match) {
                const amount = match[1];
                const toCurrency = currencyCodes[match[2]] || match[2].toUpperCase();
                return { amount, fromCurrency: 'USD', toCurrency, state: 14 };
            }
            
            // Pattern 4: XX EUR to USD / XX euros to dollars
            match = queryLower.match(/(?:convert\s+)?(\d{1,4})\s*(eur|euros?|euro|gbp|pounds?|pound|jpy|yen|cad|aud|€)\s+(?:to\s+)?(usd|dollars?|dollar|eur|euros?|euro|gbp|pounds?|pound|jpy|yen|cad|aud|€)/);
            if (match) {
                const amount = match[1];
                const fromCurrency = currencyCodes[match[2]] || match[2].toUpperCase();
                const toCurrency = currencyCodes[match[3]] || match[3].toUpperCase();
                return { amount, fromCurrency, toCurrency, state: 14 };
            }
            
            return null;
        };
        
        // Function to detect translation patterns
        const detectTranslationMatch = (query) => {
            const queryLower = query.toLowerCase().trim();
            
            // Language mapping for display (normalize common variations)
            const languageMap = {
                'italian': 'italian', 'italy': 'italian', 'it': 'italian',
                'spanish': 'spanish', 'spain': 'spanish', 'es': 'spanish',
                'french': 'french', 'france': 'french', 'fr': 'french',
                'german': 'german', 'germany': 'german', 'de': 'german',
                'portuguese': 'portuguese', 'portugal': 'portuguese', 'pt': 'portuguese',
                'japanese': 'japanese', 'japan': 'japanese', 'jp': 'japanese',
                'chinese': 'chinese', 'china': 'chinese', 'zh': 'chinese',
                'korean': 'korean', 'korea': 'korean', 'ko': 'korean',
                'russian': 'russian', 'russia': 'russian', 'ru': 'russian'
            };
            
            // Pattern 1: "how do i say {term} in {language}" (check first to avoid matching generic pattern)
            let match = queryLower.match(/^how\s+do\s+i\s+say\s+(.+?)\s+in\s+(\w+)$/);
            if (match) {
                const term = match[1].trim();
                const languageKey = match[2].toLowerCase();
                const targetLanguage = languageMap[languageKey] || languageKey;
                if (term.length > 0 && languageKey.length > 0) {
                    return { term, targetLanguage, state: 15 };
                }
            }
            
            // Pattern 2: "how to say {term} in {language}" (check second to avoid matching generic pattern)
            match = queryLower.match(/^how\s+to\s+say\s+(.+?)\s+in\s+(\w+)$/);
            if (match) {
                const term = match[1].trim();
                const languageKey = match[2].toLowerCase();
                const targetLanguage = languageMap[languageKey] || languageKey;
                if (term.length > 0 && languageKey.length > 0) {
                    return { term, targetLanguage, state: 15 };
                }
            }
            
            // Pattern 3: "translate {term} to {language}"
            match = queryLower.match(/^translate\s+(.+?)\s+to\s+(\w+)$/);
            if (match) {
                const term = match[1].trim();
                const languageKey = match[2].toLowerCase();
                const targetLanguage = languageMap[languageKey] || languageKey;
                if (term.length > 0 && languageKey.length > 0) {
                    return { term, targetLanguage, state: 15 };
                }
            }
            
            // Pattern 4: "{term} in {language}" (check last as it's the most generic)
            match = queryLower.match(/^(.+?)\s+in\s+(\w+)$/);
            if (match) {
                const term = match[1].trim();
                const languageKey = match[2].toLowerCase();
                const targetLanguage = languageMap[languageKey] || languageKey;
                if (term.length > 0 && languageKey.length > 0) {
                    return { term, targetLanguage, state: 15 };
                }
            }
            
            return null;
        };
        
        // Function to fetch translation from AI
        async function fetchTranslation(query, term) {
            const modelName = MODEL_MAP[AI_PROVIDER] || AI_PROVIDER;
            console.log(`[TRANSLATION] Fetching translation for query: "${query}" (provider: ${AI_PROVIDER}, model: ${modelName})`);
            
            // Determine which API to use based on provider
            const isOpenRouter = AI_PROVIDER.startsWith('openrouter-');
            const isOpenAI = AI_PROVIDER === 'openai';
            
            // Check API key based on provider
            if (AI_PROVIDER === 'claude' && !CLAUDE_API_KEY) {
                console.warn('[TRANSLATION] Claude API key not set');
                return { translation: 'Translation unavailable', language: null };
            } else if (AI_PROVIDER.startsWith('openrouter-') && !OPENROUTER_API_KEY) {
                console.warn('[TRANSLATION] OpenRouter API key not set');
                return { translation: 'Translation unavailable', language: null };
            } else if (isOpenAI && !OPENAI_API_KEY) {
                console.warn('[TRANSLATION] OpenAI API key not set');
                return { translation: 'Translation unavailable', language: null };
            }
            
            const systemPrompt = 'You are a translation assistant. Translate the user\'s query. Return a JSON object with "translation" (the translated text) and "language" (the target language name, capitalized, e.g. "Italian", "Spanish"). Example: {"translation": "Ciao", "language": "Italian"}';
            
            let response, data, content;
            
            try {
                if (isOpenAI) {
                    // OpenAI API request
                    const requestBody = {
                        model: 'gpt-4o-mini',
                        messages: [
                            {
                                role: 'system',
                                content: systemPrompt
                            },
                            {
                                role: 'user',
                                content: query
                            }
                        ],
                        temperature: 0.3,
                        max_tokens: 150
                    };
                    
                    response = await fetch(OPENAI_API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${OPENAI_API_KEY}`
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (!response.ok) {
                        console.error('[TRANSLATION] API error:', response.status, response.statusText);
                        return { translation: 'Translation unavailable', language: null };
                    }
                    
                    data = await response.json();
                    content = data.choices?.[0]?.message?.content?.trim() || '';
                } else if (AI_PROVIDER === 'claude') {
                    // Claude API request
                    const requestBody = {
                        model: 'claude-3-5-haiku-20241022',
                        max_tokens: 150,
                        temperature: 0.3,
                        system: systemPrompt,
                        messages: [
                            {
                                role: 'user',
                                content: query
                            }
                        ]
                    };
                    
                    response = await fetch(CLAUDE_API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': CLAUDE_API_KEY,
                            'anthropic-version': '2023-06-01'
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (!response.ok) {
                        console.error('[TRANSLATION] API error:', response.status, response.statusText);
                        return { translation: 'Translation unavailable', language: null };
                    }
                    
                    data = await response.json();
                    content = data.content?.[0]?.text?.trim() || '';
                } else {
                    // OpenRouter API request
                    const requestBody = {
                        model: MODEL_MAP[AI_PROVIDER] || 'anthropic/claude-3-haiku',
                        messages: [
                            {
                                role: 'system',
                                content: systemPrompt
                            },
                            {
                                role: 'user',
                                content: query
                            }
                        ],
                        temperature: 0.3,
                        max_tokens: 150
                    };
                    
                    response = await fetch(OPENROUTER_API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (!response.ok) {
                        console.error('[TRANSLATION] API error:', response.status, response.statusText);
                        return { translation: 'Translation unavailable', language: null };
                    }
                    
                    data = await response.json();
                    content = data.choices?.[0]?.message?.content?.trim() || '';
                }
                
                console.log('[TRANSLATION] Received response:', content);
                
                // Try to parse as JSON first
                let translationResult = { translation: 'Translation unavailable', language: null };
                try {
                    // Look for JSON object in the response
                    const jsonMatch = content.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        const parsed = JSON.parse(jsonMatch[0]);
                        translationResult = {
                            translation: parsed.translation || content,
                            language: parsed.language || null
                        };
                    } else {
                        // Fallback: use the content as translation
                        translationResult = {
                            translation: content,
                            language: null
                        };
                    }
                } catch (parseError) {
                    console.warn('[TRANSLATION] Failed to parse JSON, using raw content');
                    translationResult = {
                        translation: content,
                        language: null
                    };
                }
                
                console.log('[TRANSLATION] Parsed result:', translationResult);
                return translationResult;
            } catch (error) {
                console.error('[TRANSLATION] Error fetching translation:', error);
                return { translation: 'Translation unavailable', language: null };
            }
        }
        
        // Function to check if a query uniquely matches a carrot (disambiguates it)
        const findUniqueCarrotMatch = (query) => {
            const queryLower = query.toLowerCase().trim();
            
            // If query starts with $, a number, or "dollars", prioritize currency over translation
            // This prevents translation from matching partial patterns
            const queryTrimmed = query.trim();
            const startsWithCurrency = /^[\$0-9]/.test(queryTrimmed) || /^\d+\s*(?:usd|dollars?|dollar)/i.test(queryTrimmed);
            
            if (startsWithCurrency) {
                // Check for currency conversion patterns first
                const currencyMatch = detectCurrencyMatch(query);
                if (currencyMatch) {
                    return currencyMatch;
                }
                // If starts with currency indicator but pattern doesn't match yet,
                // don't check translation - return null to wait for complete pattern
                return null;
            }
            
            // Check for translation patterns (only if not a currency query)
            const translationMatch = detectTranslationMatch(query);
            if (translationMatch) {
                return translationMatch;
            }
            
            // Then check for currency conversion patterns (if not already checked)
            const currencyMatch = detectCurrencyMatch(query);
            if (currencyMatch) {
                return currencyMatch;
            }
            
            // Then check for exact match
            if (demoSearchCarrots[queryLower] !== undefined) {
                return { term: queryLower, state: demoSearchCarrots[queryLower] };
            }
            
            // Check for partial matches that uniquely identify a carrot
            const matchingTerms = Object.keys(demoSearchCarrots).filter(term => 
                term.startsWith(queryLower)
            );
            
            // If exactly one match, check if it's long enough to disambiguate
            if (matchingTerms.length === 1) {
                const matchedTerm = matchingTerms[0];
                
                // Minimum length requirements to show user intent
                // Analysis of each trigger in real-world search context:
                const minLengths = {
                    // 'time rome': "time" alone could be "time management", "time travel", "time zones", "time converter"
                    //            "time r" could be "time rome", "time right now", "time remaining", "time range"
                    //            "time ro" (7 chars) is clearer - likely "time rome" or "time round"
                    //            "time rom" (8 chars) is even clearer
                    'time rome': 8,        // Require "time rom" (8 chars) - clear intent for Rome time
                    
                    // 'uber stock': "uber" alone could be "uber eats", "uber driver", "uber app", "uber login"
                    //              "uber s" could be "uber stock", "uber support", "uber sign up", "uber store"
                    //              "uber st" (7 chars) is better - likely "uber stock" or "uber store"
                    //              "uber sto" (8 chars) is clearer
                    'uber stock': 8,        // Require "uber sto" (8 chars) - clear intent for stock info
                    
                    // 'lakers game': "lakers" alone could be "lakers game", "lakers schedule", "lakers tickets", "lakers roster"
                    //               All are Lakers-related, so showing game info is useful regardless
                    'lakers game': 7,      // "lakers" (7 chars) is enough - clear Lakers intent
                    
                    // 'coffee shops': "coffee" alone could be "coffee shops", "coffee cake", "coffee beans", "coffee maker", "coffee recipe"
                    //                "coffee s" could be "coffee shops", "coffee store", "coffee shop near me", "coffee subscription"
                    //                "coffee sh" (10 chars) is better - likely "coffee shop" or "coffee shops"
                    'coffee shops': 10,    // Require "coffee sh" (10 chars) - clear intent for shops
                    
                    // 'happy emoji': "happy" alone could be "happy emoji", "happy birthday", "happy new year", "happy quotes", "happy song"
                    //               "happy e" could be "happy emoji", "happy ending", "happy easter", "happy expression"
                    //               "happy em" (8 chars) is better - likely "happy emoji" or "happy emotion"
                    //               "happy emo" (9 chars) is even clearer
                    'happy emoji': 9,      // Require "happy emo" (9 chars) - clear intent for emoji
                    
                    // 'fox wiki': "fox" alone could be "fox wiki", "fox news", "fox sports", "fox weather", "fox channel"
                    //            "fox w" could be "fox wiki", "fox weather", "fox website", "fox watch"
                    //            "fox wi" (6 chars) is better - likely "fox wiki" or "fox weather"
                    //            "fox wik" (7 chars) is even clearer
                    'fox wiki': 7,         // Require "fox wik" (7 chars) - clear intent for wiki
                    'wiki fox': 7,         // Require "wiki fo" (7 chars) - clear intent for wiki fox
                    
                    // 'chair': "chair" alone could be buying a chair (our carrot) or "chair design", "chair covers", "chair exercises"
                    //          But "chair" (5 chars) is the full word, so it's acceptable
                    'chair': 5,            // "chair" (5 chars) - full word, acceptable
                    'ramen': 5,            // "ramen" (5 chars) - full word, acceptable
                    'sushi': 5,            // "sushi" (5 chars) - full word, acceptable
                    
                    // 'sneakers': "sneaker" (singular) is fine - clear intent for sneakers
                    'sneakers': 7,        // "sneaker" (7 chars) - clear intent
                    
                    // 'weather': "weather" alone could be "weather", "weather forecast", "weather today", "weather app"
                    //            But "weather" (7 chars) is the full word, so it's acceptable
                    'weather': 7,          // "weather" (7 chars) - full word, acceptable
                    
                    // 'array': "array" alone could be MDN docs (our carrot) or "array javascript", "array python", "array methods"
                    //          But "array" (5 chars) is the full word, so it's acceptable
                    'array': 5,            // "array" (5 chars) - full word, acceptable
                    
                    // 'youtube': "youtube" alone could be "youtube", "youtube music", "youtube tv", "youtube downloader"
                    //            But "youtube" (7 chars) is the full word, so it's acceptable
                    'youtube': 7,          // "youtube" (7 chars) - full word, acceptable
                    
                    // 'ac8170': Flight numbers are specific - partial matches could match other flights
                    'ac8170': 6,           // Require full flight number "ac8170" (6 chars)
                    
                    // 'vpn': Exact match, specific term
                    'vpn': 3,              // Exact match, 3 chars is fine
                    
                    // 'mdn': Exact match, specific term
                    'mdn': 3,              // Exact match, 3 chars is fine
                    
                    // 'renewable energy': "renewable" alone could be "renewable resources", "renewable energy", "renewable power"
                    //                      "renewable e" could be "renewable energy", "renewable electricity", "renewable energy sources"
                    //                      "renewable en" (12 chars) is clearer - likely "renewable energy"
                    'renewable energy': 12,  // Require "renewable en" (12 chars) - clear intent for renewable energy
                    
                    // 'stocks': "stocks" alone could be "stocks", "stocks market", "stocks today", "stocks to buy"
                    //           But "stocks" (6 chars) is the full word, so it's acceptable
                    'stocks': 6              // "stocks" (6 chars) - full word, acceptable
                };
                
                const minLength = minLengths[matchedTerm] || 3;
                
                if (queryLower.length < minLength) {
                    return null;
                }
                
                return { term: matchedTerm, state: demoSearchCarrots[matchedTerm] };
            }
            
            // If multiple matches or no matches, return null
            return null;
        };
        
        // Function to show carrot for demo searches
        const showCarrotForDemoSearch = (query) => {
            const queryLower = query.toLowerCase().trim();
            const queryTrimmed = query.trim();
            
            // If query starts with $, a number, or "dollars", prioritize currency over translation
            // This prevents translation from matching partial patterns like "ital" in "$100 in ital"
            const startsWithCurrency = /^[\$0-9]/.test(queryTrimmed) || /^\d+\s*(?:usd|dollars?|dollar)/i.test(queryTrimmed);
            
            if (startsWithCurrency) {
                // Check for currency conversion first - don't check translation at all
                const currencyMatch = detectCurrencyMatch(query);
                if (currencyMatch && carrotList && suggestionsContainer) {
                    const needsSlide = currentState !== 0 && currentState !== currencyMatch.state;
                    
                    if (needsSlide) {
                        suggestionsContainer.classList.add('expand-left');
                        suggestionsContainer.classList.remove('show-carrot');
                        
                        setTimeout(() => {
                            setCarrotContent(currencyMatch.state, currencyMatch.amount, currencyMatch.fromCurrency, currencyMatch.toCurrency);
                            currentState = currencyMatch.state;
                            suggestionsContainer.classList.remove('expand-left');
                            suggestionsContainer.classList.add('show-carrot');
                        }, 400);
                    } else {
                        setCarrotContent(currencyMatch.state, currencyMatch.amount, currencyMatch.fromCurrency, currencyMatch.toCurrency);
                        currentState = currencyMatch.state;
                        suggestionsContainer.classList.remove('expand-left');
                        suggestionsContainer.classList.add('show-carrot');
                    }
                    return true;
                }
                // If currency pattern doesn't match yet but starts with $/number/dollars, 
                // don't show translation - wait for complete currency pattern
                return false;
            }
            
            // Check for translation (only if not a currency query)
            const translationMatch = detectTranslationMatch(query);
            if (translationMatch && carrotList && suggestionsContainer) {
                const needsSlide = currentState !== 0 && currentState !== translationMatch.state;
                
                // Show carrot immediately with loading state
                const showTranslationCarrot = (translationResult, language) => {
                    // Use AI-returned language if available, otherwise use detected language
                    const displayLanguage = language || translationMatch.targetLanguage;
                    
                    if (needsSlide) {
                        suggestionsContainer.classList.add('expand-left');
                        suggestionsContainer.classList.remove('show-carrot');
                        
                        setTimeout(() => {
                            setCarrotContent(translationMatch.state, translationMatch.term, displayLanguage, translationResult);
                            currentState = translationMatch.state;
                            suggestionsContainer.classList.remove('expand-left');
                            suggestionsContainer.classList.add('show-carrot');
                        }, 400);
                    } else {
                        setCarrotContent(translationMatch.state, translationMatch.term, displayLanguage, translationResult);
                        currentState = translationMatch.state;
                        suggestionsContainer.classList.remove('expand-left');
                        suggestionsContainer.classList.add('show-carrot');
                    }
                };
                
                // Show loading state first
                showTranslationCarrot('Loading translation...', null);
                
                // Fetch translation from AI - send the full original query, let AI figure out the language
                fetchTranslation(query, translationMatch.term).then(result => {
                    const translation = typeof result === 'string' ? result : result.translation;
                    const language = typeof result === 'string' ? null : result.language;
                    showTranslationCarrot(translation, language);
                });
                
                return true;
            }
            
            // Check for currency conversion (only if not already checked above)
            if (!startsWithCurrency) {
                const currencyMatch = detectCurrencyMatch(query);
                if (currencyMatch && carrotList && suggestionsContainer) {
                    const needsSlide = currentState !== 0 && currentState !== currencyMatch.state;
                    
                    if (needsSlide) {
                        suggestionsContainer.classList.add('expand-left');
                        suggestionsContainer.classList.remove('show-carrot');
                        
                        setTimeout(() => {
                            setCarrotContent(currencyMatch.state, currencyMatch.amount, currencyMatch.fromCurrency, currencyMatch.toCurrency);
                            currentState = currencyMatch.state;
                            suggestionsContainer.classList.remove('expand-left');
                            suggestionsContainer.classList.add('show-carrot');
                        }, 400);
                    } else {
                        setCarrotContent(currencyMatch.state, currencyMatch.amount, currencyMatch.fromCurrency, currencyMatch.toCurrency);
                        currentState = currencyMatch.state;
                        suggestionsContainer.classList.remove('expand-left');
                        suggestionsContainer.classList.add('show-carrot');
                    }
                    return true;
                }
            }
            
            // Check for exact match first
            let carrotState = demoSearchCarrots[queryLower];
            let matchedTerm = queryLower;
            
            // If no exact match, check for unique partial match
            if (carrotState === undefined) {
                const uniqueMatch = findUniqueCarrotMatch(queryLower);
                if (uniqueMatch) {
                    carrotState = uniqueMatch.state;
                    matchedTerm = uniqueMatch.term;
                }
            }
            
            if (carrotState !== undefined && carrotList && suggestionsContainer) {
                // Special handling for ad marketplace carrots (chair, ramen, sushi), local carrots (coffee shops), stocks (uber stock, stocks), and sports (lakers game) - show as regular suggestion, not as carrot
                // Check both queryLower and matchedTerm to catch exact and partial matches
                if ((carrotState === 8 && (queryLower === 'chair' || matchedTerm === 'chair')) || 
                    (carrotState === 18 && (queryLower === 'ramen' || matchedTerm === 'ramen')) || 
                    (carrotState === 19 && (queryLower === 'sushi' || matchedTerm === 'sushi')) ||
                    (carrotState === 0 && (queryLower === 'coffee shops' || matchedTerm === 'coffee shops')) ||
                    (carrotState === 6 && (queryLower === 'uber stock' || matchedTerm === 'uber stock')) ||
                    (carrotState === 20 && (queryLower === 'stocks' || matchedTerm === 'stocks')) ||
                    (carrotState === 5 && ((queryLower === 'lakers game' || matchedTerm === 'lakers game') || (queryLower.startsWith('lakers') && queryLower.length >= 7)))) {
                    // Don't show these carrots as right panel carrots - they're handled in updateSuggestions
                    return false;
                }
                
                // Check if we need to slide in from the right
                const needsSlide = currentState !== 0 && currentState !== carrotState;
                
                if (needsSlide) {
                    // Slide out current carrot, then slide in new one
                    suggestionsContainer.classList.add('expand-left');
                    suggestionsContainer.classList.remove('show-carrot');
                    
                    setTimeout(() => {
                        setCarrotContent(carrotState);
                        currentState = carrotState;
                        suggestionsContainer.classList.remove('expand-left');
                        suggestionsContainer.classList.add('show-carrot');
                    }, 400);
                } else {
                    // Just show the carrot directly
                    setCarrotContent(carrotState);
                    currentState = carrotState;
                    suggestionsContainer.classList.remove('expand-left');
                    suggestionsContainer.classList.add('show-carrot');
                }
                return true;
            }
            
            // Check if query is a prefix of any demo search (don't hide carrot while typing)
            const isPrefix = Object.keys(demoSearchCarrots).some(term => term.startsWith(queryLower));
            if (isPrefix) {
                // User is typing a demo search, don't hide carrot yet
                return false;
            }
            
            return false;
        };
        
        // Minimal iconMappings for ut.html (since suggestion-paths.js was removed)
        const iconMappings = {
            lightning: [],
            search: []
        };
        
        // Search history management
        function getSearchHistory() {
            try {
                const history = localStorage.getItem('search_history');
                return history ? JSON.parse(history) : [];
            } catch (error) {
                console.error('Error reading search history:', error);
                return [];
            }
        }

        function saveToSearchHistory(text) {
            try {
                const history = getSearchHistory();
                const textLower = text.toLowerCase();
                
                // Remove if already exists (case-insensitive)
                const filteredHistory = history.filter(item => item.toLowerCase() !== textLower);
                
                // Add to top of list
                filteredHistory.unshift(text);
                
                // Limit to 100 items
                const limitedHistory = filteredHistory.slice(0, 100);
                
                localStorage.setItem('search_history', JSON.stringify(limitedHistory));
            } catch (error) {
                console.error('Error saving to search history:', error);
            }
        }

        function isInSearchHistory(text) {
            try {
                const history = getSearchHistory();
                const textLower = text.toLowerCase();
                return history.some(item => item.toLowerCase() === textLower);
            } catch (error) {
                console.error('Error checking search history:', error);
                return false;
            }
        }

        function moveToTopOfHistory(text) {
            try {
                const history = getSearchHistory();
                const textLower = text.toLowerCase();
                const index = history.findIndex(item => item.toLowerCase() === textLower);
                
                if (index !== -1) {
                    // Remove from current position and add to top
                    history.splice(index, 1);
                    history.unshift(text);
                    localStorage.setItem('search_history', JSON.stringify(history));
                }
            } catch (error) {
                console.error('Error moving to top of history:', error);
            }
        }

        function getRemovedDefaultSuggestions() {
            try {
                const removed = localStorage.getItem('removed_default_suggestions');
                return removed ? JSON.parse(removed) : [];
            } catch (error) {
                console.error('Error reading removed default suggestions:', error);
                return [];
            }
        }

        function addToRemovedDefaultSuggestions(text) {
            try {
                const removed = getRemovedDefaultSuggestions();
                const textLower = text.toLowerCase();
                if (!removed.some(item => item.toLowerCase() === textLower)) {
                    removed.push(text);
                    localStorage.setItem('removed_default_suggestions', JSON.stringify(removed));
                }
                return true;
            } catch (error) {
                console.error('Error adding to removed default suggestions:', error);
                return false;
            }
        }

        function getDefaultSuggestions() {
            const allDefaults = ['hoka', '13 in macbook air', 'Coffee machines for sale', 'taylor swift', 'coffee grinder', 'gmail'];
            const removed = getRemovedDefaultSuggestions();
            const removedLower = removed.map(r => r.toLowerCase());
            return allDefaults.filter(suggestion => !removedLower.includes(suggestion.toLowerCase()));
        }

        function removeFromSearchHistory(text) {
            try {
                const history = getSearchHistory();
                const textLower = text.toLowerCase();
                const filteredHistory = history.filter(item => item.toLowerCase() !== textLower);
                localStorage.setItem('search_history', JSON.stringify(filteredHistory));
                
                // Also add to removed default suggestions if it's a default suggestion
                const defaultSuggestions = ['hoka', '13 in macbook air', 'Coffee machines for sale', 'taylor swift', 'coffee grinder', 'gmail'];
                if (defaultSuggestions.some(ds => ds.toLowerCase() === textLower)) {
                    addToRemovedDefaultSuggestions(text);
                }
                
                return true;
            } catch (error) {
                console.error('Error removing from search history:', error);
                return false;
            }
        }

        // Track Firefox suggestions globally
        const firefoxSuggestionsSet = new Set();
        
        function getIconForSuggestion(text, forceClock = false) {
            try {
                const textLower = text.toLowerCase();
                
                // Firefox suggestions get rounded square icon
                if (firefoxSuggestionsSet.has(textLower)) {
                    return 'icons/firefox-suggest.svg';
                }
                
                // Force clock icon if specified (for random assignment)
                if (forceClock) {
                    return 'icons/clock.svg';
                }
                
                // Check if in search history
                if (isInSearchHistory(text)) {
                    return 'icons/clock.svg';
                }
                
                // AI suggestions always get search icon
                if (aiSuggestionsSet.has(textLower)) {
                    return 'icons/search.svg';
                }
                
                if (typeof iconMappings !== 'undefined' && iconMappings) {
                    if (iconMappings.lightning && iconMappings.lightning.includes(textLower)) {
                        return 'icons/lightning.svg';
                    } else if (iconMappings.search && iconMappings.search.includes(textLower)) {
                        return 'icons/search.svg';
                    }
                }
                return 'icons/search.svg';
            } catch (error) {
                console.error('Error in getIconForSuggestion:', error);
                return 'icons/search.svg';
            }
        }
        
        function showSkeletonLoaders(count = 3) {
            console.log('[Skeleton] showSkeletonLoaders called, count:', count);
            if (!suggestionsList) {
                console.log('[Skeleton] suggestionsList is null/undefined');
                return;
            }
            
            // Get current number of real suggestions (non-skeleton items)
            const existingItems = suggestionsList.querySelectorAll('.search-suggestions-preview-item:not(.skeleton)');
            const startRowIndex = existingItems.length; // Row position where skeletons will start (0-indexed)
            
            // Generate skeletons with fixed widths based on their row positions
            const skeletonHTML = Array.from({ length: count }, (_, i) => {
                const rowPosition = startRowIndex + i; // Actual row position (0-9 for rows 1-10)
                const width = skeletonWidths[rowPosition] || skeletonWidths[rowPosition % skeletonWidths.length] || 80; // Use fixed width for this row position, with fallback
                return `
                    <li class="search-suggestions-preview-item skeleton" data-index="-1">
                        <div class="suggestion-icon" style="background-color: #E5E7EB; width: 16px; height: 16px; border-radius: 2px; opacity: 0.6; display: block; flex-shrink: 0;"></div>
                        <span class="skeleton-text" style="width: ${width}px; height: 14px; background-color: #E5E7EB; border-radius: 4px; opacity: 0.6; display: block;"></span>
                    </li>
                `;
            }).join('');
            
            console.log('[Skeleton] Generated HTML:', skeletonHTML);
            console.log('[Skeleton] Current innerHTML length:', suggestionsList.innerHTML.length);
            console.log('[Skeleton] Start row index:', startRowIndex, 'Skeleton count:', count);
            
            // Append skeletons to existing suggestions
            suggestionsList.innerHTML += skeletonHTML;
            
            console.log('[Skeleton] New innerHTML length:', suggestionsList.innerHTML.length);
            console.log('[Skeleton] Number of skeleton elements:', suggestionsList.querySelectorAll('.skeleton').length);
        }
        
        function removeSkeletons() {
            if (!suggestionsList) return;
            const skeletons = suggestionsList.querySelectorAll('.skeleton');
            skeletons.forEach(skeleton => skeleton.remove());
        }
        
        // Filter existing suggestions based on next character typed
        // Helper function to highlight matching characters in text
        function highlightMatchingText(text, searchValue, isTypedText, isGmailSuggestion) {
            if (!searchValue || isTypedText || isGmailSuggestion) {
                return text;
            }
            
            const searchNoSpaces = searchValue.replace(/\s/g, '');
            const textLower = text.toLowerCase();
            const textNoSpaces = textLower.replace(/\s/g, '');
            const matchIndex = textNoSpaces.indexOf(searchNoSpaces);
            
            if (matchIndex === -1) {
                return text;
            }
            
            // Find the actual position in the original text
            let charCount = 0;
            let startIndex = -1;
            let endIndex = -1;
            
            for (let i = 0; i < text.length; i++) {
                if (text[i] !== ' ') {
                    if (charCount === matchIndex) {
                        startIndex = i;
                    }
                    if (charCount === matchIndex + searchNoSpaces.length - 1) {
                        endIndex = i + 1;
                        break;
                    }
                    charCount++;
                }
            }
            
            if (startIndex !== -1 && endIndex !== -1) {
                const before = text.substring(0, startIndex);
                const match = text.substring(startIndex, endIndex);
                const after = text.substring(endIndex);
                return `${before}<strong>${match}</strong>${after}`;
            }
            
            return text;
        }
        
        function filterExistingSuggestions(query) {
            if (!suggestionsList || currentDisplayedSuggestions.length === 0) {
                return [];
            }
            
            const queryLower = query.toLowerCase();
            const queryLength = queryLower.length;
            
            console.log('[FILTER] Filtering', currentDisplayedSuggestions.length, 'suggestions for query:', queryLower);
            
            // Filter suggestions that match the query
            const filteredSuggestions = currentDisplayedSuggestions.filter(suggestion => {
                const suggestionLower = suggestion.toLowerCase();
                // Check if suggestion has enough characters and matches at the next position
                if (suggestionLower.length < queryLength) {
                    return false;
                }
                // Check if suggestion starts with the query
                return suggestionLower.startsWith(queryLower);
            });
            
            console.log('[FILTER] Filtered to', filteredSuggestions.length, 'matching suggestions');
            
            // Rebuild the list: typed text first, then matching suggestions, then skeletons, then Firefox Suggest items
            if (suggestionsList) {
                // Get current search value to identify typed text
                const searchValueTrimmed = searchBoxElement ? searchBoxElement.value.trim() : '';
                const searchValueLower = searchValueTrimmed.toLowerCase();
                console.log('[FILTER] Search value trimmed:', searchValueTrimmed, '| Lower:', searchValueLower);
                
                // Get all current items (including headings)
                const allItems = Array.from(suggestionsList.querySelectorAll('.search-suggestions-preview-item'));
                console.log('[FILTER] Total items found:', allItems.length);
                const headings = allItems.filter(item => item.classList.contains('search-suggestions-preview-heading'));
                console.log('[FILTER] Headings found:', headings.length);
                const firefoxSuggestHeading = headings.find(h => h.querySelector('.firefox-suggest-heading'));
                const otherHeadings = headings.filter(h => !h.querySelector('.firefox-suggest-heading'));
                console.log('[FILTER] Firefox Suggest heading:', !!firefoxSuggestHeading, '| Other headings:', otherHeadings.length);
                const suggestionItems = allItems.filter(item => !item.classList.contains('skeleton') && !item.classList.contains('search-suggestions-preview-heading'));
                console.log('[FILTER] Suggestion items (non-skeleton, non-heading):', suggestionItems.length);
                
                // Separate Firefox Suggest items from regular search suggestions
                const firefoxSuggestItems = suggestionItems.filter(item => item.classList.contains('firefox-suggest-item'));
                const regularSuggestionItems = suggestionItems.filter(item => !item.classList.contains('firefox-suggest-item'));
                console.log('[FILTER] Firefox Suggest items:', firefoxSuggestItems.length, '| Regular items:', regularSuggestionItems.length);
                
                // Identify and separate typed text item (first item that matches the search value exactly)
                let typedTextItem = null;
                const matchingRegularItems = [];
                const nonMatchingRegularItems = [];
                
                regularSuggestionItems.forEach((item, index) => {
                    const itemText = item.querySelector('.label')?.textContent?.trim();
                    const dataIndex = item.getAttribute('data-index');
                    console.log('[FILTER] Item', index, '| Text:', itemText, '| Data-index:', dataIndex);
                    if (itemText) {
                        const itemLower = itemText.toLowerCase();
                        // Check if this is the typed text (exact match, usually first item with data-index="0")
                        if (searchValueTrimmed && itemLower === searchValueLower) {
                            console.log('[FILTER] ✓ Found typed text item:', itemText);
                            typedTextItem = item;
                        } else if (itemLower.length >= queryLength && itemLower.startsWith(queryLower)) {
                            console.log('[FILTER] ✓ Matching item:', itemText);
                            matchingRegularItems.push(item);
                        } else {
                            console.log('[FILTER] ✗ Non-matching item:', itemText);
                            nonMatchingRegularItems.push(item);
                        }
                    }
                });
                
                console.log('[FILTER] Typed text item found:', !!typedTextItem);
                console.log('[FILTER] Matching regular items:', matchingRegularItems.length);
                console.log('[FILTER] Non-matching regular items:', nonMatchingRegularItems.length);
                
                // Filter Firefox Suggest items that match the query
                const matchingFirefoxItems = [];
                firefoxSuggestItems.forEach(item => {
                    const itemText = item.querySelector('.label')?.textContent?.trim();
                    if (itemText) {
                        const itemLower = itemText.toLowerCase();
                        if (itemLower.length >= queryLength && itemLower.startsWith(queryLower)) {
                            matchingFirefoxItems.push(item);
                        }
                    }
                });
                
                // Remove all items to rebuild
                allItems.forEach(item => item.remove());
                
                // Calculate how many skeletons we need (up to 9 total regular suggestions, minus typed text and matching regular items)
                const itemsToShow = (typedTextItem ? 1 : 0) + matchingRegularItems.length;
                const skeletonCount = Math.max(0, 9 - itemsToShow);
                console.log('[FILTER] Items to show:', itemsToShow, '| Skeleton count:', skeletonCount);
                
                // Rebuild list in correct order:
                // 1. Other headings (like "Your recent searches")
                console.log('[FILTER] Adding', otherHeadings.length, 'other headings');
                otherHeadings.forEach(heading => {
                    suggestionsList.appendChild(heading);
                });
                
                // 2. Typed text item (always first, create if it doesn't exist)
                let finalItemsToShow = itemsToShow;
                let finalSkeletonCount = skeletonCount;
                
                if (typedTextItem) {
                    console.log('[FILTER] Adding existing typed text item:', typedTextItem.querySelector('.label')?.textContent?.trim());
                    // Ensure typed text item has is-selected class and Search with Google hint is visible
                    typedTextItem.classList.add('is-selected');
                    const hintElement = typedTextItem.querySelector('.search-hint:not(.firefox-url-display)');
                    if (hintElement) {
                        hintElement.style.display = 'inline';
                        console.log('[FILTER] Set hintElement display to inline for preserved typed text item');
                    } else {
                        // Add the hint if it doesn't exist
                        const hintHtml = `<span class="search-hint" style="display: inline;"><span class="search-hint-interpunct">&nbsp;•</span><span class="search-hint-text">Search with Google</span></span>`;
                        typedTextItem.insertAdjacentHTML('beforeend', hintHtml);
                        console.log('[FILTER] Added Search with Google hint to preserved typed text item');
                    }
                    suggestionsList.appendChild(typedTextItem);
                } else if (searchValueTrimmed) {
                    // Create typed text item if it doesn't exist
                    console.log('[FILTER] Creating new typed text item for:', searchValueTrimmed);
                    const isInHistory = isInSearchHistory(searchValueTrimmed);
                    const typedTextIcon = isInHistory ? 'icons/clock.svg' : 'icons/search.svg';
                    const typedTextHtml = `
                        <li class="search-suggestions-preview-item is-selected" data-index="0">
                            <img src="${typedTextIcon}" alt="" aria-hidden="true" class="suggestion-icon">
                            <span class="label">${searchValueTrimmed}</span>
                            <span class="search-hint" style="display: inline;"><span class="search-hint-interpunct">&nbsp;•</span><span class="search-hint-text">Search with Google</span></span>
                        </li>
                    `;
                    suggestionsList.insertAdjacentHTML('beforeend', typedTextHtml);
                    console.log('[FILTER] Created typed text item with is-selected class and Search with Google hint');
                    // Update counts to account for the typed text item we just added
                    finalItemsToShow = itemsToShow + 1;
                    finalSkeletonCount = Math.max(0, 9 - finalItemsToShow);
                } else {
                    console.log('[FILTER] ⚠️ No typed text item found and no search value!');
                }
                
                // 3. Matching regular search suggestions
                console.log('[FILTER] Adding', matchingRegularItems.length, 'matching regular items');
                matchingRegularItems.forEach(item => {
                    // Update highlighting for matching characters
                    const labelElement = item.querySelector('.label');
                    if (labelElement) {
                        const originalText = labelElement.textContent.trim();
                        const isGmailSuggestion = item.classList.contains('gmail-suggestion');
                        const highlightedText = highlightMatchingText(originalText, searchValueTrimmed, false, isGmailSuggestion);
                        labelElement.innerHTML = highlightedText;
                    }
                    suggestionsList.appendChild(item);
                });
                
                // 4. Skeletons (to fill up to 9 regular suggestions)
                if (finalSkeletonCount > 0) {
                    const skeletonHTML = Array.from({ length: finalSkeletonCount }, (_, i) => {
                        const skeletonRowIndex = finalItemsToShow + i;
                        const width = skeletonWidths[skeletonRowIndex] || skeletonWidths[skeletonRowIndex % skeletonWidths.length] || 80;
                        return `
                            <li class="search-suggestions-preview-item skeleton" data-index="-1">
                                <div class="suggestion-icon" style="background-color: #E5E7EB; width: 16px; height: 16px; border-radius: 2px; opacity: 0.6; display: block; flex-shrink: 0;"></div>
                                <span class="skeleton-text" style="width: ${width}px; height: 14px; background-color: #E5E7EB; border-radius: 4px; opacity: 0.6; display: block;"></span>
                            </li>
                        `;
                    }).join('');
                    suggestionsList.insertAdjacentHTML('beforeend', skeletonHTML);
                }
                
                // 5. Firefox Suggest heading (if there are Firefox Suggest items)
                if (matchingFirefoxItems.length > 0 && firefoxSuggestHeading) {
                    suggestionsList.appendChild(firefoxSuggestHeading);
                }
                
                // 6. Matching Firefox Suggest items (always at the bottom)
                matchingFirefoxItems.forEach(item => {
                    suggestionsList.appendChild(item);
                });
                
                // Preserve Firefox suggestions that match the query
                // Get Firefox suggestions from the DOM items we kept
                const preservedFirefoxSuggestions = [];
                matchingFirefoxItems.forEach(item => {
                    const title = item.getAttribute('data-firefox-title');
                    const url = item.getAttribute('data-firefox-url');
                    const description = item.getAttribute('data-firefox-description');
                    if (title) {
                        preservedFirefoxSuggestions.push({
                            title: title,
                            url: url || '',
                            description: description || ''
                        });
                    }
                });
                
                // Update current Firefox suggestions with preserved ones (even if empty, to clear old ones)
                currentFirefoxSuggestions = preservedFirefoxSuggestions;
                console.log('[FILTER] Preserved', preservedFirefoxSuggestions.length, 'Firefox suggestions that match query');
            } else {
                // No suggestionsList, clear Firefox suggestions
                currentFirefoxSuggestions = [];
            }
            
            // Update current displayed suggestions
            currentDisplayedSuggestions = filteredSuggestions;
            
            return filteredSuggestions;
        }
        
        function updateSuggestions(suggestions) {
            console.log('[UPDATE] ===== updateSuggestions CALLED =====');
            console.log('[UPDATE] Suggestions array:', suggestions);
            console.log('[UPDATE] Suggestions count:', suggestions ? suggestions.length : 0);
            console.log('[UPDATE] suggestionsList element:', suggestionsList);
            console.log('[UPDATE] suggestionsList exists?', !!suggestionsList);
            if (!suggestionsList) {
                console.log('[UPDATE] ✗ suggestionsList is null/undefined, returning early');
                return;
            }
            console.log('[UPDATE] ✓ suggestionsList exists, proceeding...');
            
            // Reset container height to auto so it can expand to fit content
            const previewContainer = document.querySelector('.search-suggestions-preview');
            if (previewContainer) {
                previewContainer.style.height = '';
                previewContainer.style.minHeight = '';
                previewContainer.style.maxHeight = '1000px';
                console.log('[UPDATE] Reset preview container height to auto');
            }
            
            // Remove any existing skeletons when updating with real suggestions
            removeSkeletons();
            
            // Get currently displayed suggestions from DOM to preserve their order
            const currentlyDisplayedOrder = [];
            if (suggestionsList) {
                const displayedItems = suggestionsList.querySelectorAll('.search-suggestions-preview-item:not(.skeleton):not(.search-suggestions-preview-heading):not(.firefox-suggest-item)');
                displayedItems.forEach(item => {
                    const itemText = item.querySelector('.label')?.textContent?.trim();
                    if (itemText) {
                        currentlyDisplayedOrder.push(itemText);
                    }
                });
            }
            console.log('[UPDATE] Currently displayed order (to preserve):', currentlyDisplayedOrder);
            
            // Update current displayed suggestions
            currentDisplayedSuggestions = Array.isArray(suggestions) ? [...suggestions] : [];
            
            // Update current Firefox suggestions if they're provided
            if (suggestions && suggestions._firefoxSuggestions) {
                currentFirefoxSuggestions = suggestions._firefoxSuggestions;
                console.log('[UPDATE] Stored', currentFirefoxSuggestions.length, 'Firefox suggestions');
            }
            
            // Check if these are the default suggestions - if so, ensure they're all in history
            const allDefaultSuggestions = ['hoka', '13 in macbook air', 'Coffee machines for sale', 'taylor swift', 'coffee grinder', 'gmail'];
            const defaultSuggestions = getDefaultSuggestions();
            const isDefaultSuggestions = suggestions.length === defaultSuggestions.length && 
                suggestions.every(s => defaultSuggestions.some(ds => ds.toLowerCase() === s.toLowerCase()));
            
            if (isDefaultSuggestions) {
                // Add all default suggestions to history if not already there
                defaultSuggestions.forEach(suggestion => {
                    if (!isInSearchHistory(suggestion)) {
                        saveToSearchHistory(suggestion);
                    }
                });
            }
            
            console.log('Sorting suggestions...');
            try {
                // Get current search value for highlighting
                const searchValue = searchBoxElement ? searchBoxElement.value.toLowerCase() : '';
                const searchValueTrimmed = searchBoxElement ? searchBoxElement.value.trim() : '';
                console.log('Search value for highlighting:', searchValue);
                
                // Separate suggestions into history and non-history
                const historySuggestions = [];
                const nonHistorySuggestions = [];
                
                suggestions.forEach(suggestion => {
                    // Skip typed text - it will be added separately
                    if (searchValueTrimmed && suggestion.toLowerCase() === searchValueTrimmed.toLowerCase()) {
                        return;
                    }
                    
                    if (isInSearchHistory(suggestion)) {
                        historySuggestions.push(suggestion);
                        // Move to top of history when shown
                        moveToTopOfHistory(suggestion);
                    } else {
                        nonHistorySuggestions.push(suggestion);
                    }
                });
                
                // Only randomly assign clock icons if there are NO history items in the current list
                const suggestionsToMarkWithClock = [];
                if (historySuggestions.length === 0) {
                    // Randomly assign clock icons to 1-3 suggestions from non-history
                    const clockCount = Math.floor(Math.random() * 3) + 1; // 1-3
                    const availableSuggestions = [...nonHistorySuggestions];
                    
                    for (let i = 0; i < clockCount && availableSuggestions.length > 0; i++) {
                        const randomIndex = Math.floor(Math.random() * availableSuggestions.length);
                        const selected = availableSuggestions.splice(randomIndex, 1)[0];
                        suggestionsToMarkWithClock.push(selected);
                        // Save to history
                        saveToSearchHistory(selected);
                    }
                }
                
                // Sort history suggestions by icon type (lightning first, then clock)
                const sortedHistory = historySuggestions.sort((a, b) => {
                    try {
                        const iconA = getIconForSuggestion(a);
                        const iconB = getIconForSuggestion(b);
                        const iconOrder = {
                            'icons/lightning.svg': 0,
                            'icons/clock.svg': 1,
                            'icons/search.svg': 2
                        };
                        return (iconOrder[iconA] || 2) - (iconOrder[iconB] || 2);
                    } catch (e) {
                        return 0;
                    }
                });
                
                // Sort non-history suggestions by icon type
                const sortedNonHistory = nonHistorySuggestions.sort((a, b) => {
                    try {
                        const aIsForcedClock = suggestionsToMarkWithClock.some(s => s.toLowerCase() === a.toLowerCase());
                        const bIsForcedClock = suggestionsToMarkWithClock.some(s => s.toLowerCase() === b.toLowerCase());
                        const iconA = getIconForSuggestion(a, aIsForcedClock);
                        const iconB = getIconForSuggestion(b, bIsForcedClock);
                        const iconOrder = {
                            'icons/lightning.svg': 0,
                            'icons/clock.svg': 1,
                            'icons/search.svg': 2
                        };
                        return (iconOrder[iconA] || 2) - (iconOrder[iconB] || 2);
                    } catch (e) {
                        return 0;
                    }
                });
                
                // Combine: history first, then non-history
                let sortedSuggestions = [...sortedHistory, ...sortedNonHistory];
                
                // Preserve the order of already-displayed suggestions
                // If we have currently displayed items, maintain their relative order
                if (currentlyDisplayedOrder.length > 0) {
                    const preservedOrder = [];
                    const remainingSuggestions = [...sortedSuggestions];
                    
                    // First, add items that were already displayed, in their original order
                    currentlyDisplayedOrder.forEach(displayedText => {
                        const displayedLower = displayedText.toLowerCase();
                        const foundIndex = remainingSuggestions.findIndex(s => s.toLowerCase() === displayedLower);
                        if (foundIndex >= 0) {
                            preservedOrder.push(remainingSuggestions[foundIndex]);
                            remainingSuggestions.splice(foundIndex, 1);
                        }
                    });
                    
                    // Combine: preserved order first, then new sorted suggestions
                    sortedSuggestions = [...preservedOrder, ...remainingSuggestions];
                    console.log('[UPDATE] Preserved order of', preservedOrder.length, 'already-displayed suggestions');
                }
                
                console.log('Sorted suggestions:', sortedSuggestions.length);
                
                // Prepend the typed text as the first suggestion if there's text
                // Check case-insensitively to avoid duplicates
                const typedTextInSuggestions = sortedSuggestions.some(s => s.toLowerCase() === searchValueTrimmed.toLowerCase());
                const suggestionsToShow = searchValueTrimmed && !typedTextInSuggestions
                    ? [searchValueTrimmed, ...sortedSuggestions]
                    : sortedSuggestions;
                
                console.log('Mapping suggestions to HTML...');
                
                // Get Firefox suggestions from the suggestions array if available
                // Skip Firefox suggestions if winter olympics is active
                const suggestionsPreview = document.querySelector('.search-suggestions-preview');
                const isWinterOlympicsActive = suggestionsPreview && suggestionsPreview.classList.contains('winter-olympics-active');
                const firefoxSuggestions = (!isWinterOlympicsActive && suggestions._firefoxSuggestions) ? suggestions._firefoxSuggestions : [];
                console.log('[UPDATE] Firefox suggestions from _firefoxSuggestions:', firefoxSuggestions.length, '| isWinterOlympicsActive:', isWinterOlympicsActive);
                // Extract titles for matching (handle both object and string formats)
                const firefoxSuggestionsLower = firefoxSuggestions.map(fs => {
                    if (typeof fs === 'string') {
                        return fs.toLowerCase();
                    } else if (typeof fs === 'object' && fs.title) {
                        return fs.title.toLowerCase();
                    }
                    return '';
                });
                
                // Create a map of title to full Firefox suggestion object for easy lookup
                const firefoxSuggestionsMap = new Map();
                firefoxSuggestions.forEach(fs => {
                    if (typeof fs === 'string') {
                        firefoxSuggestionsMap.set(fs.toLowerCase(), { title: fs, url: '', description: '' });
                    } else if (typeof fs === 'object' && fs.title) {
                        firefoxSuggestionsMap.set(fs.title.toLowerCase(), fs);
                    }
                });
                
                // Track if we've shown the Firefox Suggest heading
                let firefoxSuggestHeadingShown = false;
                
                // Check if these are default suggestions (shown when no text is typed)
                const defaultSuggestions = getDefaultSuggestions();
                const isDefaultSuggestions = !searchValueTrimmed && suggestionsToShow.length === defaultSuggestions.length && 
                    suggestionsToShow.every(s => defaultSuggestions.some(ds => ds.toLowerCase() === s.toLowerCase()));
                
                // For default suggestions, separate gmail and show it first, then heading, then rest
                let finalSuggestionsToShow = suggestionsToShow;
                let gmailSuggestion = null;
                if (isDefaultSuggestions) {
                    const gmailIndex = suggestionsToShow.findIndex(s => s.toLowerCase() === 'gmail');
                    if (gmailIndex >= 0) {
                        gmailSuggestion = suggestionsToShow[gmailIndex];
                        finalSuggestionsToShow = [
                            gmailSuggestion,
                            ...suggestionsToShow.filter((s, i) => i !== gmailIndex)
                        ];
                    }
                }
                
                let recentSearchesHeadingShown = false;
                
                // Randomly select one Firefox suggestion to show "Switch to tab" button instead of URL
                const firefoxSuggestionsList = Array.from(firefoxSuggestionsMap.keys());
                const randomSwitchToTabIndex = firefoxSuggestionsList.length > 0 
                    ? Math.floor(Math.random() * firefoxSuggestionsList.length) 
                    : -1;
                const switchToTabTitle = randomSwitchToTabIndex >= 0 ? firefoxSuggestionsList[randomSwitchToTabIndex] : null;
                
                const htmlString = finalSuggestionsToShow.map((text, index) => {
                // First suggestion (typed text) - check if it's in history
                // Also check if text matches searchValueTrimmed (case-insensitive) to handle filtered suggestions
                const textMatchesTyped = searchValueTrimmed && text.toLowerCase() === searchValueTrimmed.toLowerCase();
                const isTypedText = index === 0 && searchValueTrimmed && (text === searchValueTrimmed || textMatchesTyped);
                console.log('[UPDATE] Item', index, '| Text:', text, '| searchValueTrimmed:', searchValueTrimmed, '| isTypedText:', isTypedText);
                
                // Log whether this typed text item should be selected and show "Search with Google"
                if (isTypedText) {
                    console.log('[UPDATE] Typed text item detected - should be selected:', true, '| Should show Search with Google:', true);
                }
                
                // Show "Your recent searches" heading after gmail if showing default suggestions
                let headingHtml = '';
                if (isDefaultSuggestions && gmailSuggestion && index === 1 && !recentSearchesHeadingShown) {
                    // Show heading before the second item (first item after gmail)
                    recentSearchesHeadingShown = true;
                    headingHtml = `
                    <li class="search-suggestions-preview-item search-suggestions-preview-heading" data-index="-1">
                        <span class="firefox-suggest-heading">Your recent searches</span>
                    </li>
                    `;
                }
                
                // Check if this is a Firefox suggestion and get its full data
                const textLower = text.toLowerCase();
                const isFirefoxSuggest = firefoxSuggestionsLower.includes(textLower);
                const firefoxSuggestData = isFirefoxSuggest ? firefoxSuggestionsMap.get(textLower) : null;
                
                // Show Firefox Suggest heading before the first Firefox suggestion
                if (isFirefoxSuggest && !firefoxSuggestHeadingShown && !isTypedText && !isDefaultSuggestions) {
                    firefoxSuggestHeadingShown = true;
                    headingHtml = `
                    <li class="search-suggestions-preview-item search-suggestions-preview-heading" data-index="-1">
                        <span class="firefox-suggest-heading">Firefox Suggest</span>
                    </li>
                    `;
                }
                
                const isSwitchToTab = isFirefoxSuggest && switchToTabTitle && textLower === switchToTabTitle.toLowerCase();
                
                // Check if this suggestion was randomly assigned clock icon (for new additions)
                const isForcedClock = suggestionsToMarkWithClock.some(s => s.toLowerCase() === text.toLowerCase());
                // Check if it's in history (will also get clock icon)
                const isInHistory = isInSearchHistory(text);
                
                // Special handling for gmail suggestion
                const isGmailSuggestion = textLower === 'gmail' && isDefaultSuggestions;
                
                // For typed text, show clock if in history, otherwise search icon
                // For Firefox suggestions, use rounded square icon
                // For gmail suggestion, use Gmail favicon
                const icon = isGmailSuggestion
                    ? 'favicons/Google Mail.svg'
                    : isTypedText 
                    ? (isInSearchHistory(text) ? 'icons/clock.svg' : 'icons/search.svg')
                    : isFirefoxSuggest
                    ? 'icons/firefox-suggest.svg'
                    : getIconForSuggestion(text, isForcedClock);
                
                // Convert Firefox suggestions to Title Case
                // For gmail suggestion, use special text
                const titleCaseText = isGmailSuggestion
                    ? 'Inbox (84) - your.email@gmail.com - Gmail'
                    : isFirefoxSuggest 
                    ? text.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ')
                    : text;
                
                // Bold matching characters (ignore spaces in search value)
                // Skip bolding for the typed text itself (first item) and gmail suggestion
                const textToSearch = isFirefoxSuggest || isGmailSuggestion ? titleCaseText : text;
                let displayText = highlightMatchingText(textToSearch, searchValue, isTypedText, isGmailSuggestion);
                if (isGmailSuggestion) {
                    displayText = titleCaseText;
                }
                
                const firefoxDataAttrs = isFirefoxSuggest && firefoxSuggestData 
                    ? `data-firefox-title="${(firefoxSuggestData.title || '').replace(/"/g, '&quot;')}" data-firefox-description="${(firefoxSuggestData.description || '').replace(/"/g, '&quot;')}" data-firefox-url="${(firefoxSuggestData.url || '').replace(/"/g, '&quot;')}"`
                    : '';
                
                // Get cached image URL for Firefox suggestions
                let firefoxImageUrl = '';
                if (isFirefoxSuggest && firefoxSuggestData && firefoxSuggestData.title) {
                    const cacheKey = firefoxSuggestData.title.toLowerCase();
                    firefoxImageUrl = firefoxImageCache.get(cacheKey) || '';
                }
                
                // For typed text, add is-selected class to keep it highlighted
                const typedTextSelectedClass = isTypedText ? ' is-selected' : '';
                console.log('[UPDATE] Item', index, '| isTypedText:', isTypedText, '| typedTextSelectedClass:', typedTextSelectedClass);
                
                const tabIconSvg = '<svg class="suggestion-icon firefox-suggest-type-icon" width="16" height="16" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><rect x="1" y="2" width="10" height="8" rx="1" stroke="currentColor" stroke-width="1"/><path d="M1 4H11" stroke="currentColor" stroke-width="1"/><circle cx="3" cy="3" r="0.5" fill="currentColor"/><circle cx="5" cy="3" r="0.5" fill="currentColor"/></svg>';
                const firefoxSuggestIconSvg = '<svg class="suggestion-icon firefox-suggest-type-icon" width="16" height="16" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M6 1.2C6.3 2.2 6.6 3.2 7.3 4.4C8.2 4.6 9.4 4.7 10.6 4.9C9.8 6.1 9 7.1 8.3 7.4C8.8 8.8 9.1 9.8 9.2 10.6C7.8 9.8 6.9 9.2 6 8.8C4.1 9.2 3.2 9.8 2.8 10.6C3.1 8.8 3.4 7.8 3.7 7.4C2.8 6.5 2.1 5.5 1.4 4.9C3 5.1 4.1 4.8 4.7 4.4C5.4 3.2 5.7 2.2 6 1.2Z" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg>';

                const itemHtml = `
                    <li class="search-suggestions-preview-item${typedTextSelectedClass} ${isFirefoxSuggest ? 'firefox-suggest-item' : ''} ${isGmailSuggestion ? 'gmail-suggestion' : ''}" data-index="${index}" ${firefoxDataAttrs}>
                        ${isFirefoxSuggest 
                            ? `${isSwitchToTab ? tabIconSvg : firefoxSuggestIconSvg}
                                ${firefoxImageUrl 
                                ? `<img src="${firefoxImageUrl}" alt="" aria-hidden="true" class="suggestion-icon firefox-suggest-image-icon" onload="this.classList.add('loaded');">`
                                : `<div class="suggestion-icon firefox-suggest-image-icon firefox-image-placeholder" aria-hidden="true"></div>`}`
                            : `<img src="${icon}" alt="" aria-hidden="true" class="suggestion-icon ${isGmailSuggestion ? 'gmail-icon' : ''}">`
                        }
                        <span class="label">${displayText}</span>
                        ${isFirefoxSuggest && firefoxSuggestData && firefoxSuggestData.url 
                            ? (textLower === switchToTabTitle?.toLowerCase()
                                ? `<span class="search-hint firefox-switch-tab-display"><span class="firefox-switch-tab-interpunct">&nbsp;•&nbsp;&nbsp;&nbsp;</span><button class="firefox-switch-tab-button" type="button"><svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg" style="flex-shrink: 0;"><rect x="1" y="2" width="10" height="8" rx="1" stroke="currentColor" stroke-width="1"/><path d="M1 4H11" stroke="currentColor" stroke-width="1"/><circle cx="3" cy="3" r="0.5" fill="currentColor"/><circle cx="5" cy="3" r="0.5" fill="currentColor"/></svg>Switch to tab</button></span>`
                                : `<span class="search-hint firefox-url-display">&nbsp;•&nbsp;&nbsp;&nbsp;<span class="firefox-url-text">${(firefoxSuggestData.url || '').replace(/^www\./i, '').toLowerCase()}</span></span>`)
                            : !isFirefoxSuggest ? `<span class="search-hint" style="display: ${isTypedText ? 'inline' : 'none'};"><span class="search-hint-interpunct">&nbsp;•</span><span class="search-hint-text">${isGmailSuggestion ? 'Your top visited site' : 'Search with Google'}</span></span>` : ''
                        }
                        ${!isTypedText && !isFirefoxSuggest && (icon === 'icons/clock.svg' || isInHistory || isForcedClock) ? `
                        <div class="suggestion-actions">
                            <button class="suggestion-menu-button" type="button" aria-label="More options" data-suggestion-text="${text.replace(/"/g, '&quot;')}">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <circle cx="4" cy="8" r="1.5" fill="currentColor"/>
                                    <circle cx="8" cy="8" r="1.5" fill="currentColor"/>
                                    <circle cx="12" cy="8" r="1.5" fill="currentColor"/>
                                </svg>
                            </button>
                            <div class="suggestion-menu-dropdown" style="display: none;">
                                <button class="suggestion-menu-item" type="button">Remove from Firefox search history</button>
                            </div>
                        </div>
                        ` : ''}
                    </li>
                `;
                
                return headingHtml + itemHtml;
                }).join('');
                
                // If query is "chair", "ramen", "sushi", or "coffee shops", insert carrot as second item (after typed text)
                const queryLower = searchValueTrimmed.toLowerCase();
                const isAdMarketplaceQuery = queryLower === 'chair' || queryLower === 'ramen' || queryLower === 'sushi';
                // Check if query matches "coffee shops" (exact or partial match that would trigger the carrot)
                const isCoffeeShopsQuery = queryLower === 'coffee shops' || (queryLower.startsWith('coffee sh') && queryLower.length >= 10);
                // Check if query matches "lakers game" (exact or partial match that would trigger the carrot)
                const isLakersGameQuery = queryLower === 'lakers game' || (queryLower.startsWith('lakers') && queryLower.length >= 7);
                let finalHtml = htmlString;
                // For ad marketplace queries (chair/ramen/sushi), don't insert carrot yet - will be inserted after delay
                if (isAdMarketplaceQuery) {
                    // Don't insert carrot here - will be inserted after all suggestions are shown
                } else if (isCoffeeShopsQuery) {
                    // Insert coffee shops carrot after first item (typed text)
                    // Insert both coffee shop items directly - CSS will display them side by side
                    const coffeeShopsCarrotHtml = carrotTemplates.local();
                    const firstItemEnd = htmlString.indexOf('</li>');
                    if (firstItemEnd !== -1) {
                        finalHtml = htmlString.substring(0, firstItemEnd + 5) + coffeeShopsCarrotHtml + htmlString.substring(firstItemEnd + 5);
                    } else {
                        finalHtml = htmlString + coffeeShopsCarrotHtml;
                    }
                } else if (queryLower === 'uber stock' || (queryLower.startsWith('uber sto') && queryLower.length >= 8)) {
                    // Insert stocks carrot after first item (typed text)
                    // Insert all three stock items directly - CSS will display them side by side
                    const stocksCarrotHtml = carrotTemplates.stocks();
                    const firstItemEnd = htmlString.indexOf('</li>');
                    if (firstItemEnd !== -1) {
                        finalHtml = htmlString.substring(0, firstItemEnd + 5) + stocksCarrotHtml + htmlString.substring(firstItemEnd + 5);
                    } else {
                        finalHtml = htmlString + stocksCarrotHtml;
                    }
                } else if (queryLower === 'stocks') {
                    // Insert stocks ETFs carrot after first item (typed text)
                    // Insert all three ETF items directly - CSS will display them side by side
                    const stocksETFsCarrotHtml = carrotTemplates.stocksETFs();
                    const firstItemEnd = htmlString.indexOf('</li>');
                    if (firstItemEnd !== -1) {
                        finalHtml = htmlString.substring(0, firstItemEnd + 5) + stocksETFsCarrotHtml + htmlString.substring(firstItemEnd + 5);
                    } else {
                        finalHtml = htmlString + stocksETFsCarrotHtml;
                    }
                } else if (isLakersGameQuery) {
                    // Insert sports carrot after first item (typed text)
                    // Insert all three sports items directly - CSS will display them side by side
                    const sportsCarrotHtml = carrotTemplates.sports();
                    const firstItemEnd = htmlString.indexOf('</li>');
                    if (firstItemEnd !== -1) {
                        finalHtml = htmlString.substring(0, firstItemEnd + 5) + sportsCarrotHtml + htmlString.substring(firstItemEnd + 5);
                    } else {
                        finalHtml = htmlString + sportsCarrotHtml;
                    }
                } else if (isLakersGameQuery) {
                    // Insert sports carrot after first item (typed text)
                    // Insert all three sports items directly - CSS will display them side by side
                    const sportsCarrotHtml = carrotTemplates.sports();
                    const firstItemEnd = htmlString.indexOf('</li>');
                    if (firstItemEnd !== -1) {
                        finalHtml = htmlString.substring(0, firstItemEnd + 5) + sportsCarrotHtml + htmlString.substring(firstItemEnd + 5);
                    } else {
                        finalHtml = htmlString + sportsCarrotHtml;
                    }
                }
                
                // Add Firefox suggestions after regular suggestions (if they exist and aren't already in the list)
                if (firefoxSuggestions && firefoxSuggestions.length > 0 && !isDefaultSuggestions) {
                    console.log('[UPDATE] Adding Firefox suggestions to HTML. Count:', firefoxSuggestions.length);
                    // Check if Firefox Suggest heading has been shown
                    let firefoxHeadingAdded = false;
                    
                    firefoxSuggestions.forEach((fs, fsIndex) => {
                        const fsTitle = typeof fs === 'string' ? fs : (fs.title || '');
                        const fsTitleLower = fsTitle.toLowerCase();
                        const fsData = typeof fs === 'object' ? fs : { title: fs, url: '', description: '' };
                        
                        // Check if this Firefox suggestion is already in the regular list
                        const alreadyInList = finalSuggestionsToShow.some(s => s.toLowerCase() === fsTitleLower);
                        if (alreadyInList) {
                            console.log('[UPDATE] Firefox suggestion already in regular list, skipping:', fsTitle);
                            return;
                        }
                        
                        // Add Firefox Suggest heading before the first Firefox suggestion
                        if (!firefoxHeadingAdded && !firefoxSuggestHeadingShown) {
                            firefoxHeadingAdded = true;
                            const headingHtml = `
                                <li class="search-suggestions-preview-item search-suggestions-preview-heading" data-index="-1">
                                    <span class="firefox-suggest-heading">Firefox Suggest</span>
                                </li>
                            `;
                            finalHtml += headingHtml;
                            console.log('[UPDATE] Added Firefox Suggest heading');
                        }
                        
                        // Render the Firefox suggestion
                        const fsLower = fsTitleLower;
                        const switchToTabTitle = firefoxSuggestionsList.length > 0 
                            ? firefoxSuggestionsList[Math.floor(Math.random() * firefoxSuggestionsList.length)] 
                            : null;
                        const isSwitchToTab = switchToTabTitle && fsLower === switchToTabTitle.toLowerCase();
                        
                        // Get cached image URL
                        let firefoxImageUrl = '';
                        if (fsData.title) {
                            const cacheKey = fsData.title.toLowerCase();
                            firefoxImageUrl = firefoxImageCache.get(cacheKey) || '';
                        }
                        
                        const firefoxDataAttrs = `data-firefox-title="${(fsData.title || '').replace(/"/g, '&quot;')}" data-firefox-description="${(fsData.description || '').replace(/"/g, '&quot;')}" data-firefox-url="${(fsData.url || '').replace(/"/g, '&quot;')}"`;
                        
                        const tabIconSvg = '<svg class="suggestion-icon firefox-suggest-type-icon" width="16" height="16" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><rect x="1" y="2" width="10" height="8" rx="1" stroke="currentColor" stroke-width="1"/><path d="M1 4H11" stroke="currentColor" stroke-width="1"/><circle cx="3" cy="3" r="0.5" fill="currentColor"/><circle cx="5" cy="3" r="0.5" fill="currentColor"/></svg>';
                        const firefoxSuggestIconSvg = '<svg class="suggestion-icon firefox-suggest-type-icon" width="16" height="16" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M6 1.2C6.3 2.2 6.6 3.2 7.3 4.4C8.2 4.6 9.4 4.7 10.6 4.9C9.8 6.1 9 7.1 8.3 7.4C8.8 8.8 9.1 9.8 9.2 10.6C7.8 9.8 6.9 9.2 6 8.8C4.1 9.2 3.2 9.8 2.8 10.6C3.1 8.8 3.4 7.8 3.7 7.4C2.8 6.5 2.1 5.5 1.4 4.9C3 5.1 4.1 4.8 4.7 4.4C5.4 3.2 5.7 2.2 6 1.2Z" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg>';

                        const firefoxItemHtml = `
                            <li class="search-suggestions-preview-item firefox-suggest-item" data-index="${finalSuggestionsToShow.length + fsIndex}" ${firefoxDataAttrs}>
                                ${isSwitchToTab ? tabIconSvg : firefoxSuggestIconSvg}
                                ${firefoxImageUrl 
                            ? `<img src="${firefoxImageUrl}" alt="" aria-hidden="true" class="suggestion-icon firefox-suggest-image-icon" onload="this.classList.add('loaded');">`
                            : `<div class="suggestion-icon firefox-suggest-image-icon firefox-image-placeholder" aria-hidden="true"></div>`}
                                <span class="label">${fsTitle.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ')}</span>
                                ${fsData.url 
                                    ? (isSwitchToTab
                                        ? `<span class="search-hint firefox-switch-tab-display"><span class="firefox-switch-tab-interpunct">&nbsp;•&nbsp;&nbsp;&nbsp;</span><button class="firefox-switch-tab-button" type="button"><svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg" style="flex-shrink: 0;"><rect x="1" y="2" width="10" height="8" rx="1" stroke="currentColor" stroke-width="1"/><path d="M1 4H11" stroke="currentColor" stroke-width="1"/><circle cx="3" cy="3" r="0.5" fill="currentColor"/><circle cx="5" cy="3" r="0.5" fill="currentColor"/></svg>Switch to tab</button></span>`
                                        : `<span class="search-hint firefox-url-display">&nbsp;•&nbsp;&nbsp;&nbsp;<span class="firefox-url-text">${(fsData.url || '').replace(/^www\./i, '').toLowerCase()}</span></span>`)
                                    : ''
                                }
                            </li>
                        `;
                        finalHtml += firefoxItemHtml;
                        console.log('[UPDATE] Added Firefox suggestion to HTML:', fsTitle);
                    });
                } else {
                    console.log('[UPDATE] No Firefox suggestions to add. firefoxSuggestions:', firefoxSuggestions, '| isDefaultSuggestions:', isDefaultSuggestions);
                }
                
                console.log('Generated HTML length:', finalHtml.length);
                console.log('Generated HTML preview:', finalHtml.substring(0, 200));
                console.log('About to set innerHTML...');
                suggestionsList.innerHTML = finalHtml;
                console.log('innerHTML set, new innerHTML length:', suggestionsList.innerHTML.length);
                console.log('Number of child elements:', suggestionsList.children.length);
                
                // Check for Firefox suggestion images that are already loaded (from cache)
                const firefoxImages = suggestionsList.querySelectorAll('.firefox-suggest-image-icon:not(.firefox-image-placeholder)');
                firefoxImages.forEach((img) => {
                    if (img.complete && img.naturalHeight !== 0) {
                        img.classList.add('loaded');
                    }
                });
                
                // For ad marketplace queries (chair/ramen/sushi), insert carrot after all suggestions are loaded
                if (isAdMarketplaceQuery) {
                    // Wait for all suggestions to load (no skeletons, list stabilized)
                    const insertCarrotWhenReady = () => {
                        // Check if there are any skeletons still loading
                        const skeletons = suggestionsList.querySelectorAll('.skeleton');
                        if (skeletons.length > 0) {
                            // Still loading, check again in a bit
                            setTimeout(insertCarrotWhenReady, 100);
                            return;
                        }
                        
                        // Get all suggestion items, excluding Firefox suggestions, headings, and the first typed text item
                        const allItems = Array.from(suggestionsList.querySelectorAll('.search-suggestions-preview-item'));
                        // Filter to only search suggestions (not Firefox suggestions, not headings, not the typed text)
                        const searchSuggestions = allItems.filter((item, index) => {
                            // Skip first item (typed text)
                            if (index === 0) return false;
                            // Skip Firefox suggestions
                            if (item.classList.contains('firefox-suggest-item')) return false;
                            // Skip headings
                            if (item.classList.contains('search-suggestions-preview-heading')) return false;
                            // Skip carrots
                            if (item.classList.contains('carrot')) return false;
                            return true;
                        });
                        
                        // Check if carrot is already inserted
                        const existingCarrot = suggestionsList.querySelector('.carrot--ad-marketplace');
                        if (existingCarrot) {
                            return; // Already inserted
                        }
                        
                        if (searchSuggestions.length > 0) {
                            // Pick a random position among search suggestions only
                            const randomPosition = Math.floor(Math.random() * searchSuggestions.length);
                            const targetItem = searchSuggestions[randomPosition];
                            
                            // Get the carrot HTML
                            let adMarketplaceCarrotHtml;
                            if (queryLower === 'chair') {
                                adMarketplaceCarrotHtml = carrotTemplates.adMarketplace();
                            } else if (queryLower === 'ramen') {
                                adMarketplaceCarrotHtml = carrotTemplates.adMarketplaceRamen();
                            } else if (queryLower === 'sushi') {
                                adMarketplaceCarrotHtml = carrotTemplates.adMarketplaceSushi();
                            }
                            
                            if (adMarketplaceCarrotHtml && targetItem) {
                                // Create a temporary container to parse the HTML
                                const tempDiv = document.createElement('div');
                                tempDiv.innerHTML = adMarketplaceCarrotHtml;
                                const carrotElement = tempDiv.firstElementChild;
                                
                                if (carrotElement) {
                                    // Insert the carrot before the target item
                                    suggestionsList.insertBefore(carrotElement, targetItem);
                                    
                                    // Add hover handlers to clear other hover states
                                    carrotElement.addEventListener('mouseenter', () => {
                                        suggestionsList.classList.add('carrot-hovered');
                                        // Remove is-selected from all other items
                                        const allItems = suggestionsList.querySelectorAll('.search-suggestions-preview-item');
                                        allItems.forEach(item => {
                                            if (item !== carrotElement) {
                                                item.classList.remove('is-selected');
                                            }
                                        });
                                    });
                                    
                                    carrotElement.addEventListener('mouseleave', () => {
                                        suggestionsList.classList.remove('carrot-hovered');
                                    });
                                }
                            }
                        } else {
                            // Not enough items yet, check again
                            setTimeout(insertCarrotWhenReady, 100);
                        }
                    };
                    
                    // Start checking after a short delay
                    setTimeout(insertCarrotWhenReady, 200);
                }
            } catch (error) {
                console.error('Error in updateSuggestions:', error);
                console.error('Error stack:', error.stack);
            }
            
            // Set first suggestion as selected by default only if there's text typed
            const suggestionItems = suggestionsList.querySelectorAll('.search-suggestions-preview-item');
            const hasTypedText = searchBoxElement && searchBoxElement.value.trim().length > 0;
            console.log('[UPDATE] Setting selected suggestion | hasTypedText:', hasTypedText, '| suggestionItems.length:', suggestionItems.length);
            if (suggestionItems.length > 0 && hasTypedText) {
                selectedSuggestionIndex = 0;
                console.log('[UPDATE] Setting selectedSuggestionIndex to 0 for typed text');
                // Enable keyboard navigation mode to prevent hover from interfering
                suggestionsList.classList.add('keyboard-navigating');
                // Ensure typed text item is selected and shows "Search with Google"
                const typedTextItem = suggestionItems[0];
                if (typedTextItem) {
                    typedTextItem.classList.add('is-selected');
                    const hintElement = typedTextItem.querySelector('.search-hint:not(.firefox-url-display)');
                    if (hintElement) {
                        hintElement.style.display = 'inline';
                        console.log('[UPDATE] Set hintElement display to inline for typed text item');
                    } else {
                        console.log('[UPDATE] ⚠️ No hintElement found for typed text item');
                    }
                }
            } else {
                selectedSuggestionIndex = -1;
                suggestionsList.classList.remove('keyboard-navigating');
            }
            updateSelectedSuggestion();
            
            // Mark that suggestions were just updated to prevent stale hover
            suggestionsJustUpdated = true;
            // Clear the flag after a short delay to allow mouse movement to be detected
            setTimeout(() => {
                suggestionsJustUpdated = false;
            }, 100);
            
            // Attach click handlers to suggestions (this clones nodes, so do it first)
            attachClickListeners();
            
            // Attach hover listeners to the new suggestions (after click listeners)
            attachHoverListeners();
            
            // Attach preview box hover handlers (if preview box exists)
            attachPreviewBoxHoverHandlers();
            
            // Attach pin button handlers for stocks and sports items
            attachPinButtonHandlersForSuggestions();
            
            // Attach close button handlers for suggestion rows
            attachCloseButtonHandlers();
            
            // Attach menu button handlers for suggestion rows
            attachMenuButtonHandlers();
            
        }
        
        function attachCloseButtonHandlers() {
            if (!suggestionsList) return;
            
            const closeButtons = suggestionsList.querySelectorAll('.suggestion-close-button');
            closeButtons.forEach(button => {
                // Remove any existing listeners by cloning the button
                const newButton = button.cloneNode(true);
                button.replaceWith(newButton);
                
                newButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Find the parent suggestion item
                    const suggestionItem = newButton.closest('.search-suggestions-preview-item');
                    if (suggestionItem && !suggestionItem.classList.contains('removing')) {
                        // Get the current height before animating
                        const height = suggestionItem.offsetHeight;
                        suggestionItem.style.height = height + 'px';
                        suggestionItem.style.marginTop = getComputedStyle(suggestionItem).marginTop;
                        suggestionItem.style.marginBottom = getComputedStyle(suggestionItem).marginBottom;
                        
                        // Log heights before removal
                        const previewContainer = document.querySelector('.search-suggestions-preview');
                        const columnContainer = suggestionsList?.parentElement;
                        console.log('[REMOVE] Before removal:', {
                            itemHeight: height,
                            listHeight: suggestionsList?.offsetHeight,
                            columnContainerHeight: columnContainer?.offsetHeight,
                            previewContainerHeight: previewContainer?.offsetHeight,
                            previewContainerMaxHeight: previewContainer ? getComputedStyle(previewContainer).maxHeight : null,
                            previewContainerStyleHeight: previewContainer?.style.height
                        });
                        
                        // Force reflow to ensure styles are applied
                        suggestionItem.offsetHeight;
                        
                        // Add removing class to trigger fade out animation
                        suggestionItem.classList.add('removing');
                        
                        // Force container to recalculate height by reading its offsetHeight
                        if (suggestionsList) {
                            suggestionsList.offsetHeight; // Force reflow
                        }
                        
                        // Log heights after adding removing class
                        console.log('[REMOVE] After adding removing class:', {
                            listHeight: suggestionsList?.offsetHeight,
                            columnContainerHeight: columnContainer?.offsetHeight,
                            previewContainerHeight: previewContainer?.offsetHeight
                        });
                        
                        // Remove from DOM after animation completes
                        setTimeout(() => {
                            suggestionItem.remove();
                            
                            // Use requestAnimationFrame to ensure DOM has updated
                            requestAnimationFrame(() => {
                                // Log heights after DOM removal
                                console.log('[REMOVE] After DOM removal (before recalc):', {
                                    listHeight: suggestionsList?.offsetHeight,
                                    listScrollHeight: suggestionsList?.scrollHeight,
                                    columnContainerHeight: columnContainer?.offsetHeight,
                                    columnContainerScrollHeight: columnContainer?.scrollHeight,
                                    previewContainerHeight: previewContainer?.offsetHeight,
                                    previewContainerScrollHeight: previewContainer?.scrollHeight
                                });
                                
                                // Force container to recalculate height after removal
                                if (suggestionsList) {
                                    // Trigger reflow to ensure container shrinks
                                    suggestionsList.offsetHeight;
                                    // Recalculate parent containers
                                    const columnContainer = suggestionsList.parentElement;
                                    if (columnContainer && columnContainer.classList.contains('search-suggestions-preview-column-container')) {
                                        // Remove any explicit height to let it recalculate
                                        columnContainer.style.height = '';
                                        columnContainer.style.minHeight = '';
                                        // Force reflow
                                        columnContainer.offsetHeight;
                                        
                                        // Calculate the actual content height AFTER forcing reflow
                                        const columnContainerHeight = columnContainer.scrollHeight;
                                        console.log('[REMOVE] Column container scrollHeight:', columnContainerHeight);
                                        
                                        // Also update the main suggestions preview container
                                        const previewContainer = columnContainer.parentElement;
                                        if (previewContainer && previewContainer.classList.contains('search-suggestions-preview')) {
                                            // Remove any explicit height to let it recalculate
                                            previewContainer.style.height = '';
                                            previewContainer.style.minHeight = '';
                                            previewContainer.style.maxHeight = '1000px';
                                            
                                            // Force reflow
                                            previewContainer.offsetHeight;
                                            
                                            // Calculate the actual content height AFTER forcing reflow
                                            const previewContainerHeight = previewContainer.scrollHeight;
                                            console.log('[REMOVE] Preview container scrollHeight:', previewContainerHeight);
                                            
                                            // Set explicit height based on content
                                            if (previewContainerHeight > 0 && previewContainerHeight < 296) {
                                                previewContainer.style.height = previewContainerHeight + 'px';
                                                console.log('[REMOVE] Set preview container height to:', previewContainerHeight + 'px');
                                                
                                                // Force another reflow after setting height
                                                previewContainer.offsetHeight;
                                            }
                                        }
                                    }
                                }
                                
                                // Log heights after recalculation
                                const finalColumnContainer = suggestionsList?.parentElement;
                                const finalPreviewContainer = finalColumnContainer?.parentElement;
                                console.log('[REMOVE] After recalculation:', {
                                    listHeight: suggestionsList?.offsetHeight,
                                    listScrollHeight: suggestionsList?.scrollHeight,
                                    columnContainerHeight: finalColumnContainer?.offsetHeight,
                                    columnContainerScrollHeight: finalColumnContainer?.scrollHeight,
                                    previewContainerHeight: finalPreviewContainer?.offsetHeight,
                                    previewContainerScrollHeight: finalPreviewContainer?.scrollHeight,
                                    previewContainerMaxHeight: finalPreviewContainer ? getComputedStyle(finalPreviewContainer).maxHeight : null,
                                    previewContainerStyleHeight: finalPreviewContainer?.style.height,
                                    previewContainerComputedHeight: finalPreviewContainer ? getComputedStyle(finalPreviewContainer).height : null
                                });
                            });
                            
                            // Update selected index if needed
                            const remainingItems = suggestionsList.querySelectorAll('.search-suggestions-preview-item:not(.search-suggestions-preview-heading):not(.removing)');
                            if (selectedSuggestionIndex >= remainingItems.length) {
                                selectedSuggestionIndex = remainingItems.length - 1;
                                updateSelectedSuggestion();
                            }
                        }, 300); // Match CSS transition duration
                    }
                });
            });
        }
        
        function attachMenuButtonHandlers() {
            console.log('=== attachMenuButtonHandlers START ===');
            if (!suggestionsList) {
                console.error('suggestionsList is null!');
                return;
            }
            
            const menuButtons = suggestionsList.querySelectorAll('.suggestion-menu-button');
            console.log('Found', menuButtons.length, 'menu buttons');
            
            if (menuButtons.length === 0) {
                console.warn('No menu buttons found!');
                return;
            }
            
            menuButtons.forEach((button, index) => {
                console.log(`\n--- Processing button ${index} ---`);
                console.log('Button element:', button);
                console.log('Button parent:', button.parentElement);
                console.log('Button next sibling:', button.nextElementSibling);
                
                // Get the dropdown before cloning (it's the next sibling)
                const originalDropdown = button.nextElementSibling;
                console.log('Original dropdown:', originalDropdown);
                console.log('Is dropdown?', originalDropdown?.classList.contains('suggestion-menu-dropdown'));
                
                // Remove any existing listeners by cloning the button
                const newButton = button.cloneNode(true);
                console.log('Cloned button:', newButton);
                button.replaceWith(newButton);
                
                // Re-attach dropdown if it exists
                let menuDropdown = null;
                if (originalDropdown && originalDropdown.classList.contains('suggestion-menu-dropdown')) {
                    // Insert dropdown right after the button
                    newButton.parentNode.insertBefore(originalDropdown, newButton.nextSibling);
                    menuDropdown = originalDropdown;
                    console.log('Dropdown re-attached successfully');
                } else {
                    // Try to find it after insertion
                    menuDropdown = newButton.nextElementSibling;
                    console.log('Looking for dropdown after insertion:', menuDropdown);
                    if (!menuDropdown || !menuDropdown.classList.contains('suggestion-menu-dropdown')) {
                        console.warn('Dropdown not found for button:', newButton);
                        menuDropdown = null;
                    }
                }
                
                if (!menuDropdown) {
                    console.error(`Button ${index}: No dropdown found, skipping handler attachment`);
                    return;
                }
                
                console.log(`Button ${index}: Dropdown found:`, menuDropdown);
                console.log('Dropdown HTML:', menuDropdown.outerHTML.substring(0, 200));
                console.log('Dropdown computed display:', window.getComputedStyle(menuDropdown).display);
                console.log('Dropdown inline style:', menuDropdown.style.display);
                
                newButton.addEventListener('click', (e) => {
                    console.log(`\n=== BUTTON ${index} CLICKED ===`);
                    console.log('Event:', e);
                    console.log('Event target:', e.target);
                    console.log('Event currentTarget:', e.currentTarget);
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Prevent hover state from being triggered
                    const suggestionItem = newButton.closest('.search-suggestions-preview-item');
                    if (suggestionItem) {
                        suggestionItem.classList.add('menu-clicked');
                        setTimeout(() => {
                            suggestionItem.classList.remove('menu-clicked');
                        }, 100);
                    }
                    
                    // Close all other dropdowns
                    const allDropdowns = document.querySelectorAll('.suggestion-menu-dropdown');
                    console.log('Found', allDropdowns.length, 'total dropdowns');
                    allDropdowns.forEach((d, i) => {
                        if (d !== menuDropdown) {
                            console.log(`Closing dropdown ${i}`);
                            d.style.display = 'none';
                        }
                    });
                    
                    // Toggle this dropdown
                    const inlineDisplay = menuDropdown.style.display;
                    const computedDisplay = window.getComputedStyle(menuDropdown).display;
                    console.log('Current inline display:', inlineDisplay);
                    console.log('Current computed display:', computedDisplay);
                    
                    const isHidden = inlineDisplay === 'none' || (!inlineDisplay && computedDisplay === 'none');
                    console.log('Is hidden?', isHidden);
                    
                    if (isHidden) {
                        // Move dropdown to body to avoid overflow clipping
                        const buttonRect = newButton.getBoundingClientRect();
                        // Store reference to original parent and suggestion item for restoration
                        const actionsContainer = newButton.parentElement;
                        const suggestionItem = newButton.closest('.search-suggestions-preview-item');
                        menuDropdown.dataset.originalButtonId = `btn-${index}`;
                        menuDropdown._originalParent = actionsContainer;
                        menuDropdown._suggestionItem = suggestionItem;
                        
                        // Keep the suggestion item highlighted when dropdown is open
                        if (suggestionItem) {
                            suggestionItem.classList.add('is-selected');
                            suggestionItem.classList.add('dropdown-open');
                        }
                        
                        document.body.appendChild(menuDropdown);
                        menuDropdown.style.position = 'fixed';
                        menuDropdown.style.left = (buttonRect.right - 220) + 'px';
                        menuDropdown.style.top = (buttonRect.bottom + 4) + 'px';
                        menuDropdown.style.right = 'auto';
                        menuDropdown.style.display = 'block';
                        console.log('Dropdown moved to body, positioned at:', {
                            left: menuDropdown.style.left,
                            top: menuDropdown.style.top,
                            buttonRect,
                            parent: actionsContainer,
                            suggestionItem
                        });
                        
                        // Keep suggestion item highlighted when hovering over dropdown
                        // Use a closure to store the timeout
                        let mouseLeaveTimeout = null;
                        
                        const handleMouseEnter = () => {
                            // Cancel any pending close timeout
                            if (mouseLeaveTimeout) {
                                clearTimeout(mouseLeaveTimeout);
                                mouseLeaveTimeout = null;
                            }
                            if (suggestionItem) {
                                suggestionItem.classList.add('is-selected');
                            }
                        };
                        
                        const handleMouseLeave = (e) => {
                            // Clear any existing timeout
                            if (mouseLeaveTimeout) {
                                clearTimeout(mouseLeaveTimeout);
                            }
                            
                            // Use a small delay to check if mouse is moving back to suggestion item
                            mouseLeaveTimeout = setTimeout(() => {
                                // Check if dropdown is still visible
                                if (menuDropdown.style.display === 'none') {
                                    return; // Already closed
                                }
                                
                                // Close the dropdown
                                menuDropdown.style.display = 'none';
                                
                                // Remove highlight from suggestion item
                                if (suggestionItem) {
                                    suggestionItem.classList.remove('is-selected');
                                    suggestionItem.classList.remove('dropdown-open');
                                }
                                
                                // Move back to original position if it was moved to body
                                if (menuDropdown.parentElement === document.body && menuDropdown._originalParent) {
                                    menuDropdown._originalParent.appendChild(menuDropdown);
                                    menuDropdown.style.position = 'absolute';
                                    menuDropdown.style.left = 'auto';
                                    menuDropdown.style.top = 'auto';
                                    menuDropdown.style.right = '0';
                                }
                            }, 150); // Small delay to allow mouse to move to suggestion item
                        };
                        
                        menuDropdown.addEventListener('mouseenter', handleMouseEnter);
                        menuDropdown.addEventListener('mouseleave', handleMouseLeave);
                    } else {
                        menuDropdown.style.display = 'none';
                        // Move back to original position
                        if (menuDropdown._originalParent) {
                            menuDropdown._originalParent.appendChild(menuDropdown);
                            menuDropdown.style.position = 'absolute';
                            menuDropdown.style.left = 'auto';
                            menuDropdown.style.top = 'auto';
                            menuDropdown.style.right = '0';
                        } else {
                            const actionsContainer = newButton.parentElement;
                            if (actionsContainer && actionsContainer.classList.contains('suggestion-actions')) {
                                actionsContainer.appendChild(menuDropdown);
                                menuDropdown.style.position = 'absolute';
                                menuDropdown.style.left = 'auto';
                                menuDropdown.style.top = 'auto';
                                menuDropdown.style.right = '0';
                            }
                        }
                    }
                    
                    console.log('New display style:', menuDropdown.style.display);
                    console.log('New computed display:', window.getComputedStyle(menuDropdown).display);
                    console.log('Dropdown rect:', menuDropdown.getBoundingClientRect());
                    console.log('Dropdown z-index:', window.getComputedStyle(menuDropdown).zIndex);
                    console.log('Dropdown visibility:', window.getComputedStyle(menuDropdown).visibility);
                    console.log('Dropdown opacity:', window.getComputedStyle(menuDropdown).opacity);
                    console.log('Dropdown element:', menuDropdown);
                });
                
                // Handle menu item click
                if (menuDropdown && menuDropdown.classList.contains('suggestion-menu-dropdown')) {
                    const menuItem = menuDropdown.querySelector('.suggestion-menu-item');
                    if (menuItem) {
                        const newMenuItem = menuItem.cloneNode(true);
                        menuItem.replaceWith(newMenuItem);
                        
                        newMenuItem.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            
                            const suggestionText = newButton.getAttribute('data-suggestion-text');
                            const suggestionItem = newButton.closest('.search-suggestions-preview-item');
                            
                            if (suggestionText && suggestionItem) {
                                // Remove from search history
                                removeFromSearchHistory(suggestionText);
                                
                                // Check if this is a default suggestion
                                const defaultSuggestions = ['hoka', '13 in macbook air', 'Coffee machines for sale', 'taylor swift', 'coffee grinder', 'gmail'];
                                const isDefaultSuggestion = defaultSuggestions.some(ds => ds.toLowerCase() === suggestionText.toLowerCase());
                                
                                // Hide dropdown
                                menuDropdown.style.display = 'none';
                                
                                if (isDefaultSuggestion) {
                                    // Remove the item from the list with fade-out animation
                                    if (!suggestionItem.classList.contains('removing')) {
                                        // Get the current height before animating
                                        const height = suggestionItem.offsetHeight;
                                        suggestionItem.style.height = height + 'px';
                                        suggestionItem.style.marginTop = getComputedStyle(suggestionItem).marginTop;
                                        suggestionItem.style.marginBottom = getComputedStyle(suggestionItem).marginBottom;
                                        
                                        // Log heights before removal
                                        const previewContainer = document.querySelector('.search-suggestions-preview');
                                        const columnContainer = suggestionsList?.parentElement;
                                        console.log('[REMOVE-MENU] Before removal:', {
                                            itemHeight: height,
                                            listHeight: suggestionsList?.offsetHeight,
                                            columnContainerHeight: columnContainer?.offsetHeight,
                                            previewContainerHeight: previewContainer?.offsetHeight,
                                            previewContainerMaxHeight: previewContainer ? getComputedStyle(previewContainer).maxHeight : null,
                                            previewContainerStyleHeight: previewContainer?.style.height
                                        });
                                        
                                        // Force reflow to ensure styles are applied
                                        suggestionItem.offsetHeight;
                                        
                                        // Add removing class to trigger fade out animation
                                        suggestionItem.classList.add('removing');
                                        
                                        // Force container to recalculate height by reading its offsetHeight
                                        if (suggestionsList) {
                                            suggestionsList.offsetHeight; // Force reflow
                                        }
                                        
                                        // Log heights after adding removing class
                                        console.log('[REMOVE-MENU] After adding removing class:', {
                                            listHeight: suggestionsList?.offsetHeight,
                                            columnContainerHeight: columnContainer?.offsetHeight,
                                            previewContainerHeight: previewContainer?.offsetHeight
                                        });
                                        
                                        // Remove from DOM after animation completes
                                        setTimeout(() => {
                                            suggestionItem.remove();
                                            
                                            // Use requestAnimationFrame to ensure DOM has updated
                                            requestAnimationFrame(() => {
                                                // Log heights after DOM removal
                                                console.log('[REMOVE-MENU] After DOM removal (before recalc):', {
                                                    listHeight: suggestionsList?.offsetHeight,
                                                    listScrollHeight: suggestionsList?.scrollHeight,
                                                    columnContainerHeight: columnContainer?.offsetHeight,
                                                    columnContainerScrollHeight: columnContainer?.scrollHeight,
                                                    previewContainerHeight: previewContainer?.offsetHeight,
                                                    previewContainerScrollHeight: previewContainer?.scrollHeight
                                                });
                                                
                                                // Force container to recalculate height after removal
                                                if (suggestionsList) {
                                                    // Trigger reflow to ensure container shrinks
                                                    suggestionsList.offsetHeight;
                                                    // Recalculate parent containers
                                                    const columnContainer = suggestionsList.parentElement;
                                                    if (columnContainer && columnContainer.classList.contains('search-suggestions-preview-column-container')) {
                                                        // Remove any explicit height to let it recalculate
                                                        columnContainer.style.height = '';
                                                        columnContainer.style.minHeight = '';
                                                        // Force reflow
                                                        columnContainer.offsetHeight;
                                                        
                                                        // Calculate the actual content height AFTER forcing reflow
                                                        const columnContainerHeight = columnContainer.scrollHeight;
                                                        console.log('[REMOVE-MENU] Column container scrollHeight:', columnContainerHeight);
                                                        
                                                        // Also update the main suggestions preview container
                                                        const previewContainer = columnContainer.parentElement;
                                                        if (previewContainer && previewContainer.classList.contains('search-suggestions-preview')) {
                                                            // Remove any explicit height to let it recalculate
                                                            previewContainer.style.height = '';
                                                            previewContainer.style.minHeight = '';
                                                            previewContainer.style.maxHeight = '1000px';
                                                            
                                                            // Force reflow
                                                            previewContainer.offsetHeight;
                                                            
                                                            // Calculate height based on actual remaining items
                                                            const remainingItems = suggestionsList.querySelectorAll('.search-suggestions-preview-item:not(.removing)');
                                                            let calculatedHeight = 0;
                                                            remainingItems.forEach(item => {
                                                                if (!item.classList.contains('removing')) {
                                                                    calculatedHeight += item.offsetHeight;
                                                                }
                                                            });
                                                            // Add padding and gaps
                                                            const listPadding = parseInt(getComputedStyle(suggestionsList).paddingTop) + parseInt(getComputedStyle(suggestionsList).paddingBottom);
                                                            const listGap = parseInt(getComputedStyle(suggestionsList).gap) * (remainingItems.length - 1);
                                                            calculatedHeight += listPadding + listGap;
                                                            
                                                            const columnPadding = parseInt(getComputedStyle(columnContainer).paddingTop) + parseInt(getComputedStyle(columnContainer).paddingBottom);
                                                            const columnHeight = calculatedHeight + columnPadding;
                                                            
                                                            const previewContainerHeight = previewContainer.scrollHeight;
                                                            console.log('[REMOVE-MENU] Preview container scrollHeight:', previewContainerHeight);
                                                            console.log('[REMOVE-MENU] Calculated height from items:', {
                                                                remainingItemsCount: remainingItems.length,
                                                                calculatedListHeight: calculatedHeight,
                                                                calculatedColumnHeight: columnHeight,
                                                                previewContainerScrollHeight: previewContainerHeight
                                                            });
                                                            
                                                            // Use the smaller of scrollHeight or calculated height
                                                            const targetHeight = Math.min(previewContainerHeight, columnHeight + 10); // Add small buffer
                                                            
                                                            // Set explicit height based on content
                                                            if (targetHeight > 0 && targetHeight < 296) {
                                                                previewContainer.style.height = targetHeight + 'px';
                                                                console.log('[REMOVE-MENU] Set preview container height to:', targetHeight + 'px');
                                                                
                                                                // Force another reflow after setting height
                                                                previewContainer.offsetHeight;
                                                            }
                                                        }
                                                    }
                                                }
                                                
                                                // Log heights after recalculation
                                                const finalColumnContainer = suggestionsList?.parentElement;
                                                const finalPreviewContainer = finalColumnContainer?.parentElement;
                                                console.log('[REMOVE-MENU] After recalculation:', {
                                                    listHeight: suggestionsList?.offsetHeight,
                                                    listScrollHeight: suggestionsList?.scrollHeight,
                                                    columnContainerHeight: finalColumnContainer?.offsetHeight,
                                                    columnContainerScrollHeight: finalColumnContainer?.scrollHeight,
                                                    previewContainerHeight: finalPreviewContainer?.offsetHeight,
                                                    previewContainerScrollHeight: finalPreviewContainer?.scrollHeight,
                                                    previewContainerMaxHeight: finalPreviewContainer ? getComputedStyle(finalPreviewContainer).maxHeight : null,
                                                    previewContainerStyleHeight: finalPreviewContainer?.style.height,
                                                    previewContainerComputedHeight: finalPreviewContainer ? getComputedStyle(finalPreviewContainer).height : null
                                                });
                                            });
                                            
                                            // Update selected index if needed
                                            const remainingItems = suggestionsList.querySelectorAll('.search-suggestions-preview-item:not(.search-suggestions-preview-heading):not(.removing)');
                                            if (selectedSuggestionIndex >= remainingItems.length) {
                                                selectedSuggestionIndex = remainingItems.length - 1;
                                                updateSelectedSuggestion();
                                            }
                                        }, 300); // Match CSS transition duration
                                    }
                                } else {
                                    // Change icon from clock to search
                                    const iconElement = suggestionItem.querySelector('.suggestion-icon');
                                    if (iconElement && iconElement.tagName === 'IMG') {
                                        iconElement.src = 'icons/search.svg';
                                    }
                                    
                                    // Hide the menu button since it's no longer in history
                                    const actionsContainer = suggestionItem.querySelector('.suggestion-actions');
                                    if (actionsContainer) {
                                        actionsContainer.style.display = 'none';
                                    }
                                }
                            }
                        });
                    }
                }
            });
            
            // Close dropdowns when clicking outside (only attach once)
            if (!window.dropdownClickHandlerAttached) {
                window.dropdownClickHandlerAttached = true;
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.suggestion-actions') && !e.target.closest('.suggestion-menu-dropdown')) {
                        document.querySelectorAll('.suggestion-menu-dropdown').forEach(dropdown => {
                            dropdown.style.display = 'none';
                            // Move back to original position if it was moved to body
                            if (dropdown.parentElement === document.body && dropdown._originalParent) {
                                dropdown._originalParent.appendChild(dropdown);
                                dropdown.style.position = 'absolute';
                                dropdown.style.left = 'auto';
                                dropdown.style.top = 'auto';
                                dropdown.style.right = '0';
                            }
                        });
                    }
                });
            }
        }
        
        function attachPinButtonHandlersForSuggestions() {
            if (!suggestionsList) return;
            
            const pinButtons = suggestionsList.querySelectorAll('.carrot-pin-button');
            pinButtons.forEach(button => {
                // Remove any existing listeners by cloning the button
                const newButton = button.cloneNode(true);
                button.replaceWith(newButton);
                
                newButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Find the parent stock-item or sports-item
                    const stockItem = newButton.closest('.stock-item');
                    const sportsItem = newButton.closest('.sports-item');
                    
                    if (stockItem) {
                        console.log('[PIN] Pin button clicked for stock item');
                        const pinnedCard = replaceThirdCardWithStock(stockItem);
                        handlePinSuccess(pinnedCard);
                    } else if (sportsItem) {
                        console.log('[PIN] Pin button clicked for sports item');
                        const pinnedCard = replaceThirdCardWithSports(sportsItem);
                        handlePinSuccess(pinnedCard);
                    }
                });
            });
        }
        
        // COMMENTED OUT: Google search functionality disabled
        // function performGoogleSearch(suggestionText) {
        //     if (!suggestionText || !suggestionText.trim()) return;
        //     const searchUrl = `https://www.google.com/search?q=${encodeURIComponent(suggestionText.trim())}`;
        //     window.open(searchUrl, '_blank');
        // }
        
        function attachClickListeners() {
            if (!suggestionsList) return;
            
            const suggestionItems = suggestionsList.querySelectorAll('.search-suggestions-preview-item:not(.skeleton)');
            suggestionItems.forEach((item) => {
                // Remove existing click listener if any
                const newItem = item.cloneNode(true);
                item.parentNode.replaceChild(newItem, item);
                
                // Add click handler
                newItem.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // COMMENTED OUT: Google search on click disabled
                    // Get the suggestion text from the label
                    // const labelElement = newItem.querySelector('.label');
                    // if (labelElement) {
                    //     // Get text content, removing any HTML tags (like <strong>)
                    //     const suggestionText = labelElement.textContent.trim();
                    //     performGoogleSearch(suggestionText);
                    // }
                });
            });
        }
        
        function attachHoverListeners() {
            if (!suggestionsList) return;
            
            const suggestionItems = suggestionsList.querySelectorAll('.search-suggestions-preview-item');
            suggestionItems.forEach((item, index) => {
                // For Firefox suggestions, add special hover handler to populate preview box
                if (item.classList.contains('firefox-suggest-item')) {
                    item.addEventListener('mouseenter', handleFirefoxSuggestionHover);
                    item.addEventListener('mouseleave', (e) => {
                        // Check if mouse is moving to a dropdown
                        const relatedTarget = e.relatedTarget;
                        const openDropdown = document.querySelector('.suggestion-menu-dropdown[style*="block"]');
                        if (openDropdown && (relatedTarget === openDropdown || openDropdown.contains(relatedTarget))) {
                            // Mouse is moving to dropdown, keep highlight
                            return;
                        }
                        // Check if this item has an open dropdown
                        if (item.classList.contains('dropdown-open')) {
                            return; // Keep highlight if dropdown is open
                        }
                        handleFirefoxSuggestionLeave(e);
                    });
                } else {
                    item.addEventListener('mouseenter', handleSuggestionHover);
                    // Handle mouseleave but check if dropdown is open
                    item.addEventListener('mouseleave', (e) => {
                        // Check if mouse is moving to a dropdown
                        const relatedTarget = e.relatedTarget;
                        const openDropdown = document.querySelector('.suggestion-menu-dropdown[style*="block"]');
                        if (openDropdown && (relatedTarget === openDropdown || openDropdown.contains(relatedTarget))) {
                            // Mouse is moving to dropdown, keep highlight
                            return;
                        }
                        // Check if this item has an open dropdown
                        if (item.classList.contains('dropdown-open')) {
                            return; // Keep highlight if dropdown is open
                        }
                        // Normal mouseleave behavior
                        if (item.classList.contains('firefox-suggest-item')) {
                            handleFirefoxSuggestionLeave(e);
                        } else {
                            selectedSuggestionIndex = -1;
                            updateSelectedSuggestion();
                        }
                    });
                }
                
                // For local business items, attach hover to the business divs
                // Both businesses are now in a single <li>, so we need to handle them separately
                if (item.classList.contains('local-business-wrapper')) {
                    const businessDivs = item.querySelectorAll('.local-business');
                    businessDivs.forEach((businessDiv, divIndex) => {
                        businessDiv.addEventListener('mouseenter', (e) => {
                            e.stopPropagation();
                            // Ignore hover if suggestions were just updated or keyboard navigating
                            if (suggestionsJustUpdated || suggestionsList.classList.contains('keyboard-navigating')) {
                                return;
                            }
                            // Set the selected index based on which business div is hovered
                            // We need to find the index of this list item, then add the divIndex
                            const allItems = Array.from(suggestionsList.querySelectorAll('.search-suggestions-preview-item'));
                            const itemIndex = allItems.indexOf(item);
                            // For coffee shops, the first business is at itemIndex, second is at itemIndex + 1
                            // But since they're in the same <li>, we need to track them separately
                            // Use a custom approach: store the business index on the div
                            const businessIndex = parseInt(businessDiv.dataset.businessIndex || '0');
                            // Calculate the actual suggestion index
                            // If this is the coffee shops item, first business = itemIndex, second = itemIndex + 1
                            const actualIndex = itemIndex + businessIndex;
                            selectedSuggestionIndex = actualIndex;
                            updateSelectedSuggestion();
                        });
                    });
                }
                
                // For stocks items, attach hover to the stock divs
                // All three stocks are now in a single <li>, so we need to handle them separately
                if (item.classList.contains('stocks-wrapper')) {
                    const stockDivs = item.querySelectorAll('.stock-item');
                    stockDivs.forEach((stockDiv, divIndex) => {
                        stockDiv.addEventListener('mouseenter', (e) => {
                            e.stopPropagation();
                            // Ignore hover if suggestions were just updated or keyboard navigating
                            if (suggestionsJustUpdated || suggestionsList.classList.contains('keyboard-navigating')) {
                                return;
                            }
                            // Set the selected index based on which stock div is hovered
                            const allItems = Array.from(suggestionsList.querySelectorAll('.search-suggestions-preview-item'));
                            const itemIndex = allItems.indexOf(item);
                            // For stocks, first stock = itemIndex, second = itemIndex + 1, third = itemIndex + 2
                            const stockIndex = parseInt(stockDiv.dataset.stockIndex || '0');
                            const actualIndex = itemIndex + stockIndex;
                            selectedSuggestionIndex = actualIndex;
                            updateSelectedSuggestion();
                        });
                    });
                }
                
                // For sports items, attach hover to the sports divs
                // All three sports items are now in a single <li>, so we need to handle them separately
                if (item.classList.contains('sports-wrapper')) {
                    const sportsDivs = item.querySelectorAll('.sports-item');
                    sportsDivs.forEach((sportsDiv, divIndex) => {
                        sportsDiv.addEventListener('mouseenter', (e) => {
                            e.stopPropagation();
                            // Ignore hover if suggestions were just updated or keyboard navigating
                            if (suggestionsJustUpdated || suggestionsList.classList.contains('keyboard-navigating')) {
                                return;
                            }
                            // Set the selected index based on which sports div is hovered
                            const allItems = Array.from(suggestionsList.querySelectorAll('.search-suggestions-preview-item'));
                            const itemIndex = allItems.indexOf(item);
                            // For sports, first item = itemIndex, second = itemIndex + 1, third = itemIndex + 2
                            const sportsIndex = parseInt(sportsDiv.dataset.sportsIndex || '0');
                            const actualIndex = itemIndex + sportsIndex;
                            selectedSuggestionIndex = actualIndex;
                            updateSelectedSuggestion();
                        });
                    });
                }
            });
            
            // Clear selection when mouse leaves the suggestions list
            // But don't hide preview box - it should stay open until Google suggestion is hovered
            const suggestionsContainer = suggestionsList.closest('.search-suggestions-preview-column-container');
            if (suggestionsContainer) {
                suggestionsContainer.addEventListener('mouseleave', (e) => {
                    // Check if mouse is moving to a dropdown
                    const relatedTarget = e.relatedTarget;
                    const openDropdown = document.querySelector('.suggestion-menu-dropdown[style*="block"]');
                    if (openDropdown && (relatedTarget === openDropdown || openDropdown.contains(relatedTarget))) {
                        // Mouse is moving to dropdown, keep highlight
                        return;
                    }
                    selectedSuggestionIndex = -1;
                    suggestionsList.classList.remove('keyboard-navigating');
                    // Don't call updateSelectedSuggestion() here as it would hide the preview box
                    // Just remove selection styling
                    const suggestionItems = suggestionsList.querySelectorAll('.search-suggestions-preview-item');
                    suggestionItems.forEach(item => {
                        // Don't remove highlight if dropdown is open for this item
                        if (item.classList.contains('dropdown-open')) {
                            return;
                        }
                        item.classList.remove('is-selected');
                        const hintElement = item.querySelector('.search-hint:not(.firefox-url-display)');
                        if (hintElement) {
                            hintElement.style.display = 'none';
                        }
                    });
                });
            }
            
            // Reset keyboard navigation flag when mouse moves (allows hover to work again)
            suggestionsList.addEventListener('mousemove', () => {
                suggestionsList.classList.remove('keyboard-navigating');
            });
        }
        
        async function handleFirefoxSuggestionHover(event) {
            if (!suggestionsList) return;
            
            const item = event.currentTarget;
            const title = item.dataset.firefoxTitle;
            const description = item.dataset.firefoxDescription;
            const url = item.dataset.firefoxUrl;
            
            if (!title || !description || !url) return;
            
            // Ignore hover if suggestions were just updated or keyboard navigating
            if (suggestionsJustUpdated || suggestionsList.classList.contains('keyboard-navigating')) {
                return;
            }
            
            // Calculate virtual index (accounting for coffee shops counting as 2 items, stocks counting as 3 items, and skipping headings)
            const suggestionItems = suggestionsList.querySelectorAll('.search-suggestions-preview-item');
            const itemIndex = Array.from(suggestionItems).indexOf(item);
            if (itemIndex >= 0) {
                let virtualIndex = 0;
                for (let i = 0; i < itemIndex; i++) {
                    const currentItem = suggestionItems[i];
                    // Skip Firefox Suggest heading
                    if (currentItem.classList.contains('search-suggestions-preview-heading') || currentItem.dataset.index === '-1') {
                        continue;
                    }
                    if (currentItem.classList.contains('local-business-wrapper')) {
                        const businessDivs = currentItem.querySelectorAll('.local-business');
                        if (businessDivs.length === 2) {
                            // Coffee shops item - counts as 2 virtual items
                            virtualIndex += 2;
                        } else {
                            // Regular local business - counts as 1
                            virtualIndex += 1;
                        }
                    } else if (currentItem.classList.contains('stocks-wrapper')) {
                        const stockDivs = currentItem.querySelectorAll('.stock-item');
                        // Stocks item - count each stock div as a virtual item
                        virtualIndex += stockDivs.length > 0 ? stockDivs.length : 1;
                    } else if (currentItem.classList.contains('sports-wrapper')) {
                        const sportsDivs = currentItem.querySelectorAll('.sports-item');
                        // Sports item - count each sports div as a virtual item
                        virtualIndex += sportsDivs.length > 0 ? sportsDivs.length : 1;
                    } else {
                        // Regular suggestion - counts as 1
                        virtualIndex += 1;
                    }
                }
                selectedSuggestionIndex = virtualIndex;
                updateSelectedSuggestion();
            }
            
            await showFirefoxPreviewBox(item, title, description, url);
        }
        
        function handleFirefoxSuggestionLeave(event) {
            const relatedTarget = event.relatedTarget;
            if (relatedTarget instanceof Element) {
                if (relatedTarget.closest('.firefox-suggest-item') || relatedTarget.closest('.preview-box')) {
                    return;
                }
            }

            if (!suspendedCarrotContext || !suggestionsContainer) {
                return;
            }

            // Only restore carrot if leaving a Firefox suggestion that was displayed when carrot was suspended
            const item = event.currentTarget;
            const url = item.dataset.firefoxUrl;
            if (!url || !suspendedByFirefoxUrls.has(url)) {
                // This Firefox suggestion was not displayed when the carrot was suspended
                return;
            }

            hideFirefoxPreviewBox();
            setCarrotContent(
                suspendedCarrotContext.state,
                suspendedCarrotContext.amountOrTerm,
                suspendedCarrotContext.fromCurrencyOrTargetLanguage,
                suspendedCarrotContext.toCurrencyOrTranslation
            );
            currentState = suspendedCarrotContext.state;
            suggestionsContainer.classList.remove('expand-left');
            suggestionsContainer.classList.add('show-carrot');
            suspendedCarrotContext = null;
            suspendedByFirefoxUrls.clear();
        }
        
        function handleSuggestionHover(event) {
            if (!suggestionsList) return;
            
            // Ignore hover if suggestions were just updated or keyboard navigating (prevents stale hover from mouse already being over an item)
            if (suggestionsJustUpdated || suggestionsList.classList.contains('keyboard-navigating')) {
                return;
            }
            
            const suggestionItems = suggestionsList.querySelectorAll('.search-suggestions-preview-item');
            const item = event.currentTarget;
            
            // If hovering over a carrot, clear the selection
            if (item.classList.contains('carrot')) {
                selectedSuggestionIndex = -1;
                updateSelectedSuggestion();
                return;
            }
            
            // Calculate virtual index (accounting for coffee shops counting as 2 items, stocks counting as 3 items, and skipping headings)
            const itemIndex = Array.from(suggestionItems).indexOf(item);
            if (itemIndex >= 0) {
                let virtualIndex = 0;
                for (let i = 0; i < itemIndex; i++) {
                    const currentItem = suggestionItems[i];
                    // Skip Firefox Suggest heading
                    if (currentItem.classList.contains('search-suggestions-preview-heading') || currentItem.dataset.index === '-1') {
                        continue;
                    }
                    if (currentItem.classList.contains('local-business-wrapper')) {
                        const businessDivs = currentItem.querySelectorAll('.local-business');
                        if (businessDivs.length === 2) {
                            // Coffee shops item - counts as 2 virtual items
                            virtualIndex += 2;
                        } else {
                            // Regular local business - counts as 1
                            virtualIndex += 1;
                        }
                    } else if (currentItem.classList.contains('stocks-wrapper')) {
                        const stockDivs = currentItem.querySelectorAll('.stock-item');
                        // Stocks item - count each stock div as a virtual item
                        virtualIndex += stockDivs.length > 0 ? stockDivs.length : 1;
                    } else if (currentItem.classList.contains('sports-wrapper')) {
                        const sportsDivs = currentItem.querySelectorAll('.sports-item');
                        // Sports item - count each sports div as a virtual item
                        virtualIndex += sportsDivs.length > 0 ? sportsDivs.length : 1;
                    } else {
                        // Regular suggestion - counts as 1
                        virtualIndex += 1;
                    }
                }
                // For the hovered item itself, if it's coffee shops or stocks, determine which sub-item
                if (item.classList.contains('local-business-wrapper')) {
                    const businessDivs = item.querySelectorAll('.local-business');
                    if (businessDivs.length === 2) {
                        // This is coffee shops - default to first business (index 0)
                        // The business div hover handler will override this
                        selectedSuggestionIndex = virtualIndex;
                    } else {
                        selectedSuggestionIndex = virtualIndex;
                    }
                } else if (item.classList.contains('stocks-wrapper')) {
                    const stockDivs = item.querySelectorAll('.stock-item');
                    // This is stocks - default to first stock (index 0)
                    // The stock div hover handler will override this
                    selectedSuggestionIndex = virtualIndex;
                } else if (item.classList.contains('sports-wrapper')) {
                    const sportsDivs = item.querySelectorAll('.sports-item');
                    // This is sports - default to first sports item (index 0)
                    // The sports div hover handler will override this
                    selectedSuggestionIndex = virtualIndex;
                } else {
                    selectedSuggestionIndex = virtualIndex;
                }
                updateSelectedSuggestion();
            }
        }
        
        function updateSelectedSuggestion(isKeyboardNavigation = false) {
            if (!suggestionsList) return;
            
            // Add/remove class to disable hover styles during keyboard navigation
            if (isKeyboardNavigation) {
                suggestionsList.classList.add('keyboard-navigating');
            } else {
                suggestionsList.classList.remove('keyboard-navigating');
            }
            
            const suggestionItems = suggestionsList.querySelectorAll('.search-suggestions-preview-item');
            
            // Remove selection from ALL items first
            suggestionItems.forEach((item) => {
                item.classList.remove('is-selected');
                // Also remove selected state from local-business divs (for side-by-side coffee shops)
                const localBusinesses = item.querySelectorAll('.local-business');
                localBusinesses.forEach((business) => {
                    business.classList.remove('local-business--selected');
                });
                // Also remove selected state from stock-item divs (for side-by-side stocks)
                const stockItems = item.querySelectorAll('.stock-item');
                stockItems.forEach((stock) => {
                    stock.classList.remove('stock-item--selected');
                });
                // Also remove selected state from sports-item divs (for side-by-side sports)
                const sportsItems = item.querySelectorAll('.sports-item');
                sportsItems.forEach((sports) => {
                    sports.classList.remove('sports-item--selected');
                });
                // Hide "Search with Google" hint (Firefox URLs are always visible)
                const hintElement = item.querySelector('.search-hint:not(.firefox-url-display)');
                if (hintElement) {
                    hintElement.style.display = 'none';
                }
            });
            
            // Calculate total virtual items (accounting for coffee shops having 2 businesses and stocks having 3 items)
            // Skip heading items (data-index="-1" or search-suggestions-preview-heading class)
            let virtualItemCount = 0;
            const virtualItemMap = []; // Maps virtual index to [itemIndex, businessIndex/stockIndex]
            suggestionItems.forEach((item, itemIndex) => {
                // Skip Firefox Suggest heading
                if (item.classList.contains('search-suggestions-preview-heading') || item.dataset.index === '-1') {
                    return;
                }
                
                if (item.classList.contains('local-business-wrapper')) {
                    const businessDivs = item.querySelectorAll('.local-business');
                    if (businessDivs.length === 2) {
                        // Coffee shops item - counts as 2 virtual items
                        virtualItemMap.push([itemIndex, 0]); // First business
                        virtualItemMap.push([itemIndex, 1]); // Second business
                        virtualItemCount += 2;
                    } else {
                        // Regular local business - counts as 1
                        virtualItemMap.push([itemIndex, 0]);
                        virtualItemCount += 1;
                    }
                } else if (item.classList.contains('stocks-wrapper')) {
                    const stockDivs = item.querySelectorAll('.stock-item');
                    // Stocks item - each stock div counts as a virtual item
                    stockDivs.forEach((stockDiv, stockIndex) => {
                        virtualItemMap.push([itemIndex, stockIndex]);
                        virtualItemCount += 1;
                    });
                    // If no stock divs found, treat as single item
                    if (stockDivs.length === 0) {
                        virtualItemMap.push([itemIndex, -1]);
                        virtualItemCount += 1;
                    }
                } else if (item.classList.contains('sports-wrapper')) {
                    const sportsDivs = item.querySelectorAll('.sports-item');
                    // Sports item - each sports div counts as a virtual item
                    sportsDivs.forEach((sportsDiv, sportsIndex) => {
                        virtualItemMap.push([itemIndex, sportsIndex]);
                        virtualItemCount += 1;
                    });
                    // If no sports divs found, treat as single item
                    if (sportsDivs.length === 0) {
                        virtualItemMap.push([itemIndex, -1]);
                        virtualItemCount += 1;
                    }
                } else {
                    // Regular suggestion - counts as 1
                    virtualItemMap.push([itemIndex, -1]); // -1 means no sub-item div
                    virtualItemCount += 1;
                }
            });
            
            // Then add selection to ONLY the selected item (if one is selected)
            if (selectedSuggestionIndex >= 0 && selectedSuggestionIndex < virtualItemCount) {
                const [itemIndex, businessIndex] = virtualItemMap[selectedSuggestionIndex];
                const selectedItem = suggestionItems[itemIndex];
                selectedItem.classList.add('is-selected');
                
                // For coffee shops item, highlight the specific business div
                if (selectedItem.classList.contains('local-business-wrapper') && businessIndex >= 0) {
                    const businessDivs = selectedItem.querySelectorAll('.local-business');
                    if (businessDivs[businessIndex]) {
                        businessDivs[businessIndex].classList.add('local-business--selected');
                    }
                }
                // For stocks item, highlight the specific stock div
                if (selectedItem.classList.contains('stocks-wrapper') && businessIndex >= 0) {
                    const stockDivs = selectedItem.querySelectorAll('.stock-item');
                    if (stockDivs[businessIndex]) {
                        stockDivs[businessIndex].classList.add('stock-item--selected');
                    }
                }
                
                if (selectedItem.classList.contains('sports-wrapper') && businessIndex >= 0) {
                    const sportsDivs = selectedItem.querySelectorAll('.sports-item');
                    if (sportsDivs[businessIndex]) {
                        sportsDivs[businessIndex].classList.add('sports-item--selected');
                    }
                }
                
                // Show "Search with Google" hint (Firefox URLs are always visible)
                const hintElement = selectedItem.querySelector('.search-hint:not(.firefox-url-display)');
                console.log('[SELECT] Selected item at index', selectedSuggestionIndex, '| hintElement found:', !!hintElement);
                if (hintElement) {
                    hintElement.style.display = 'inline';
                    console.log('[SELECT] Set hintElement display to inline');
                } else {
                    console.log('[SELECT] No hintElement found for selected item');
                }
                
                // If selected item is a Firefox suggestion, show preview box
                if (selectedItem.classList.contains('firefox-suggest-item')) {
                    const title = selectedItem.dataset.firefoxTitle;
                    const description = selectedItem.dataset.firefoxDescription;
                    const url = selectedItem.dataset.firefoxUrl;
                    
                    if (title && description && url) {
                        showFirefoxPreviewBox(selectedItem, title, description, url);
                    }
                } else {
                    // Hide preview box if not a Firefox suggestion
                    hideFirefoxPreviewBox();
                }
                
                // If this is keyboard navigation, update the search box text
                if (isKeyboardNavigation && searchBoxElement) {
                    if (selectedItem.classList.contains('gmail-suggestion')) {
                        // Clear search box text when selecting gmail suggestion
                        searchBoxElement.value = '';
                    } else {
                        const label = selectedItem.querySelector('.label');
                        if (label) {
                            // Extract text without HTML tags (removes <strong> tags but keeps text)
                            const suggestionText = label.textContent || label.innerText;
                            searchBoxElement.value = suggestionText.trim();
                        }
                    }
                }
            } else {
                // No item selected - but don't hide preview box
                // Preview box should stay open until a Google suggestion is hovered
            }
        }
        
        // Cache for preloaded Firefox suggestion images
        const firefoxImageCache = new Map();
        
        async function preloadFirefoxSuggestionImages(firefoxSuggestions) {
            const apiKey = window.API_CONFIG?.PEXELS_API_KEY || '';
            if (!apiKey) return;
            
            // Preload images for each Firefox suggestion
            const preloadPromises = firefoxSuggestions.map(async (suggestion) => {
                if (!suggestion || !suggestion.title) return;
                
                const title = suggestion.title;
                const cacheKey = title.toLowerCase();
                
                // Skip if already cached
                if (firefoxImageCache.has(cacheKey)) {
                    return;
                }
                
                try {
                    const response = await fetch(`https://api.pexels.com/v1/search?query=${encodeURIComponent(title)}&per_page=1`, {
                        headers: {
                            Authorization: apiKey
                        }
                    });
                    if (response.ok) {
                        const data = await response.json();
                        if (data.photos && data.photos[0]) {
                            const imageUrl = data.photos[0].src.large;
                            
                            // Preload the image by creating an Image object
                            return new Promise((resolve) => {
                                const img = new Image();
                                img.onload = () => {
                                    // Cache the image URL only after it's loaded
                                    firefoxImageCache.set(cacheKey, imageUrl);
                                    
                                    // Update any existing Firefox suggestion items with this image
                                    updateFirefoxSuggestionImage(cacheKey, imageUrl);
                                    
                                    resolve();
                                };
                                img.onerror = () => {
                                    console.error('Error loading image for Firefox suggestion:', title);
                                    resolve();
                                };
                                img.src = imageUrl;
                            });
                        }
                    }
                } catch (error) {
                    console.error('Error preloading image for Firefox suggestion:', title, error);
                }
            });
            
            // Don't await - let it happen in background
            Promise.all(preloadPromises).catch(error => {
                console.error('Error preloading Firefox suggestion images:', error);
            });
        }
        
        function updateFirefoxSuggestionImage(cacheKey, imageUrl) {
            // Find all Firefox suggestion items that match this cache key and update their images
            const suggestionItems = document.querySelectorAll('.firefox-suggest-item');
            suggestionItems.forEach((item) => {
                const title = item.dataset.firefoxTitle;
                if (title && title.toLowerCase() === cacheKey) {
                    // Check if image already exists (as img tag)
                    const existingImg = item.querySelector('.firefox-suggest-image-icon:not(.firefox-image-placeholder)');
                    if (!existingImg) {
                        // Find placeholder or create new image
                        const placeholder = item.querySelector('.firefox-image-placeholder');
                        
                        if (placeholder) {
                            // Replace placeholder with actual image
                            const img = document.createElement('img');
                            img.alt = '';
                            img.setAttribute('aria-hidden', 'true');
                            img.className = 'suggestion-icon firefox-suggest-image-icon';
                            
                            // Replace placeholder
                            placeholder.replaceWith(img);
                            
                            // Set src after setting up handlers (in case image loads from cache immediately)
                            img.onload = () => {
                                img.classList.add('loaded');
                            };
                            
                            // Check if image is already loaded (from cache)
                            img.src = imageUrl;
                            if (img.complete && img.naturalHeight !== 0) {
                                img.classList.add('loaded');
                            }
                        } else {
                            // No placeholder found, insert image at beginning
                            const img = document.createElement('img');
                            img.alt = '';
                            img.setAttribute('aria-hidden', 'true');
                            img.className = 'suggestion-icon firefox-suggest-image-icon';
                            
                            item.insertBefore(img, item.firstChild);
                            
                            // Set src after setting up handlers (in case image loads from cache immediately)
                            img.onload = () => {
                                img.classList.add('loaded');
                            };
                            
                            // Check if image is already loaded (from cache)
                            img.src = imageUrl;
                            if (img.complete && img.naturalHeight !== 0) {
                                img.classList.add('loaded');
                            }
                        }
                    }
                }
            });
        }
        
        // Helper functions for key points localStorage
        function getKeyPointsStorageKey(url) {
            // Normalize URL for storage key
            const normalizedUrl = url.replace(/^www\./i, '').toLowerCase().trim();
            return `firefox_suggest_keypoints_${normalizedUrl}`;
        }
        
        function saveKeyPoints(url, keyPoints) {
            try {
                const storageKey = getKeyPointsStorageKey(url);
                localStorage.setItem(storageKey, JSON.stringify(keyPoints));
            } catch (error) {
                console.error('[KEY POINTS] Error saving to localStorage:', error);
            }
        }
        
        function getKeyPoints(url) {
            try {
                const storageKey = getKeyPointsStorageKey(url);
                const saved = localStorage.getItem(storageKey);
                return saved ? JSON.parse(saved) : null;
            } catch (error) {
                console.error('[KEY POINTS] Error reading from localStorage:', error);
                return null;
            }
        }
        
        async function showFirefoxPreviewBox(item, title, description, url) {
            const previewBox = document.querySelector('.preview-box');
            const suggestionsContainer = document.querySelector('.search-suggestions-preview-column-container');
            if (!previewBox || !suggestionsContainer) return;
            
            // If carrot is visible, hide it so preview box can replace it
            if (suggestionsContainer.classList.contains('show-carrot')) {
                if (lastCarrotContext) {
                    suspendedCarrotContext = { ...lastCarrotContext };
                    // Track which Firefox suggestions are currently displayed
                    suspendedByFirefoxUrls.clear();
                    const firefoxItems = suggestionsList.querySelectorAll('.firefox-suggest-item');
                    firefoxItems.forEach(item => {
                        const url = item.dataset.firefoxUrl;
                        if (url) suspendedByFirefoxUrls.add(url);
                    });
                }
                suggestionsContainer.classList.remove('show-carrot');
            }
            
            // Ensure expand-left is set for proper layout
            suggestionsContainer.classList.add('expand-left');
            
            // Show preview box and container
            suggestionsContainer.classList.add('show-preview-box');
            previewBox.style.display = 'block';
            
            // Get image from cache or use placeholder
            const cacheKey = title.toLowerCase();
            let imageUrl = firefoxImageCache.get(cacheKey) || 'https://via.placeholder.com/400x250?text=Image';
            
            // If not in cache, try to fetch it (fallback for edge cases)
            if (!firefoxImageCache.has(cacheKey)) {
                const apiKey = window.API_CONFIG?.PEXELS_API_KEY || '';
                if (apiKey) {
                    try {
                        const response = await fetch(`https://api.pexels.com/v1/search?query=${encodeURIComponent(title)}&per_page=1`, {
                            headers: {
                                Authorization: apiKey
                            }
                        });
                        if (response.ok) {
                            const data = await response.json();
                            if (data.photos && data.photos[0]) {
                                imageUrl = data.photos[0].src.large;
                                firefoxImageCache.set(cacheKey, imageUrl);
                            }
                        }
                    } catch (error) {
                        console.error('Error fetching image for Firefox suggestion:', error);
                    }
                }
            }
            
            // Check for saved key points
            const savedKeyPoints = getKeyPoints(url);
            let keyPointsHtml = '';
            if (savedKeyPoints && Array.isArray(savedKeyPoints) && savedKeyPoints.length > 0) {
                // Display saved key points
                keyPointsHtml = `
                    <button class="preview-box-visit-button" type="button">Visit site →</button>
                    <ul class="preview-box-key-points">
                        ${savedKeyPoints.map(point => `<li>${point.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</li>`).join('')}
                    </ul>
                `;
            } else {
                // Show generate button
                keyPointsHtml = `
                    <button class="preview-box-visit-button" type="button">Visit site →</button>
                    <button class="preview-box-generate-button" data-preview-title="${title.replace(/"/g, '&quot;')}" data-preview-description="${description.replace(/"/g, '&quot;')}" data-preview-url="${url.replace(/"/g, '&quot;')}">
                        <img src="icons/sparkles.svg" alt="" class="preview-box-sparkles-icon" aria-hidden="true">
                        Generate key points
                    </button>
                `;
            }
            
            // Populate preview box
            previewBox.innerHTML = `
                <div class="preview-box-content">
                    <img src="${imageUrl}" alt="${title.replace(/"/g, '&quot;')}" class="preview-box-image">
                    <div class="preview-box-text">
                        <h3 class="preview-box-title">${title.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</h3>
                        <p class="preview-box-description">${description.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p>
                        <div class="preview-box-key-points-container">
                            ${keyPointsHtml}
                        </div>
                        <p class="preview-box-url">${url.replace(/^www\./i, '').toLowerCase().replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\//g, '/<wbr>')}</p>
                    </div>
                </div>
            `;
            
            // Attach click handler to generate button (if it exists)
            const generateButton = previewBox.querySelector('.preview-box-generate-button');
            if (generateButton) {
                generateButton.addEventListener('click', async () => {
                    const buttonTitle = generateButton.dataset.previewTitle;
                    const buttonDescription = generateButton.dataset.previewDescription;
                    const buttonUrl = generateButton.dataset.previewUrl;
                    await generateKeyPoints(buttonTitle, buttonDescription, buttonUrl, generateButton);
                });
            }
            
            // Attach hover handlers to keep preview box open when mouse is over it
            attachPreviewBoxHoverHandlers();
        }
        
        async function generateKeyPoints(title, description, url, buttonElement) {
            const container = buttonElement.parentElement;
            
            // Show loading state
            buttonElement.disabled = true;
            buttonElement.innerHTML = '<img src="icons/sparkles.svg" alt="" class="preview-box-sparkles-icon" aria-hidden="true"> Generating...';
            
            try {
                // Determine which API to use based on provider
                const isOpenRouter = AI_PROVIDER.startsWith('openrouter-');
                const isOpenAI = AI_PROVIDER === 'openai';
                const modelName = MODEL_MAP[AI_PROVIDER] || AI_PROVIDER;
                console.log(`[KEY-POINTS] Generating key points for: "${title}" (provider: ${AI_PROVIDER}, model: ${modelName})`);
                
                // Check API key based on provider
                if (AI_PROVIDER === 'claude' && !CLAUDE_API_KEY) {
                    throw new Error('Claude API key not set');
                } else if (AI_PROVIDER.startsWith('openrouter-') && !OPENROUTER_API_KEY) {
                    throw new Error('OpenRouter API key not set');
                } else if (isOpenAI && !OPENAI_API_KEY) {
                    throw new Error('OpenAI API key not set');
                }
                
                const systemPrompt = 'You are a helpful assistant that generates interesting facts from article titles and descriptions. Return exactly 3 interesting facts as a JSON array of strings. Each fact should be concise (6-10 words max) and be an interesting, surprising, or noteworthy fact about the topic. The first fact should be unexpected but not bizarre or untruthful. Example: ["Interesting fact one about the topic", "Surprising detail two with important information", "Noteworthy fact three that captures attention"]';
                const userPrompt = `Title: ${title}\n\nDescription: ${description}\n\nGenerate 3 interesting facts about this article topic. The first fact should be unexpected but not bizarre or untruthful. Make them engaging and informative. Return only a JSON array of 3 strings, nothing else.`;
                
                let response, data, content;
                
                if (isOpenAI) {
                    // OpenAI API request
                    const requestBody = {
                        model: 'gpt-4o-mini',
                        messages: [
                            {
                                role: 'system',
                                content: systemPrompt
                            },
                            {
                                role: 'user',
                                content: userPrompt
                            }
                        ],
                        max_tokens: 200,
                        temperature: 0.7
                    };
                    
                    response = await fetch(OPENAI_API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${OPENAI_API_KEY}`
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API error: ${response.status}`);
                    }
                    
                    data = await response.json();
                    content = data.choices?.[0]?.message?.content?.trim() || '';
                } else if (AI_PROVIDER === 'claude') {
                    // Claude API request
                    const requestBody = {
                        model: 'claude-3-5-haiku-20241022',
                        max_tokens: 200,
                        temperature: 0.7,
                        system: systemPrompt,
                        messages: [
                            {
                                role: 'user',
                                content: userPrompt
                            }
                        ]
                    };
                    
                    response = await fetch(CLAUDE_API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': CLAUDE_API_KEY,
                            'anthropic-version': '2023-06-01'
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API error: ${response.status}`);
                    }
                    
                    data = await response.json();
                    content = data.content?.[0]?.text?.trim() || '';
                } else {
                    // OpenRouter API request
                    const requestBody = {
                        model: MODEL_MAP[AI_PROVIDER] || 'anthropic/claude-3-haiku',
                        messages: [
                            {
                                role: 'system',
                                content: systemPrompt
                            },
                            {
                                role: 'user',
                                content: userPrompt
                            }
                        ],
                        max_tokens: 200,
                        temperature: 0.7
                    };
                    
                    response = await fetch(OPENROUTER_API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
                            'HTTP-Referer': window.location.origin,
                            'X-Title': 'Key Points Generator'
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API error: ${response.status}`);
                    }
                    
                    data = await response.json();
                    content = data.choices?.[0]?.message?.content?.trim() || '';
                }
                
                // Parse JSON array from response
                let keyPoints = [];
                try {
                    // Try to extract JSON array from the response
                    const jsonMatch = content.match(/\[.*\]/s);
                    if (jsonMatch) {
                        keyPoints = JSON.parse(jsonMatch[0]);
                    } else {
                        // Fallback: try parsing the whole content
                        keyPoints = JSON.parse(content);
                    }
                    
                    // Ensure we have an array of strings
                    if (!Array.isArray(keyPoints)) {
                        throw new Error('Response is not an array');
                    }
                    
                    // Limit to 3 key points
                    keyPoints = keyPoints.slice(0, 3).filter(point => typeof point === 'string' && point.length > 0);
                } catch (parseError) {
                    console.error('[KEY POINTS] Error parsing response:', parseError);
                    // Fallback: create key points from title/description
                    keyPoints = [
                        `Key insight about ${title}`,
                        `Important detail from the article`,
                        `Summary point related to ${title}`
                    ];
                }
                
                // Replace button with bulleted list
                if (keyPoints.length > 0) {
                    // Save to localStorage
                    saveKeyPoints(url, keyPoints);
                    
                    const keyPointsHtml = `
                        <button class="preview-box-visit-button" type="button">Visit site →</button>
                        <ul class="preview-box-key-points">
                            ${keyPoints.map(point => `<li>${point.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</li>`).join('')}
                        </ul>
                    `;
                    container.innerHTML = keyPointsHtml;
                } else {
                    throw new Error('No key points generated');
                }
            } catch (error) {
                console.error('[KEY POINTS] Error generating key points:', error);
                // Show error state
                buttonElement.disabled = false;
                buttonElement.innerHTML = '<img src="icons/sparkles.svg" alt="" class="preview-box-sparkles-icon" aria-hidden="true"> Error - Try again';
            }
        }
        
        function attachPreviewBoxHoverHandlers() {
            const previewBox = document.querySelector('.preview-box');
            if (!previewBox) return;
            
            // Check if handlers are already attached to prevent duplicates
            if (previewBox.dataset.handlersAttached === 'true') return;
            
            // Keep preview box open when mouse enters it
            previewBox.addEventListener('mouseenter', () => {
                // Preview box stays open - do nothing
            });
            
            // Don't close preview box when mouse leaves it
            // Preview box will only close when a Google suggestion is hovered
            previewBox.addEventListener('mouseleave', () => {
                // Do nothing - preview box stays open until Google suggestion is hovered
            });
            
            previewBox.dataset.handlersAttached = 'true';
        }
        
        function hideFirefoxPreviewBox() {
            const previewBox = document.querySelector('.preview-box');
            const suggestionsContainer = document.querySelector('.search-suggestions-preview-column-container');
            if (previewBox && suggestionsContainer) {
                previewBox.innerHTML = '';
                previewBox.style.display = 'none';
                suggestionsContainer.classList.remove('show-preview-box');
            }
        }
        
        
        let lastWeatherSnapshot = null;

        function logWeatherCarrotLayout(label) {
            const weatherCarrot = carrotList ? carrotList.querySelector('.carrot--weather') : null;
            const weatherHeader = weatherCarrot ? weatherCarrot.querySelector('.weather-header') : null;
            const pinButton = weatherCarrot ? weatherCarrot.querySelector('.weather-pin-button') : null;

            if (!weatherCarrot || !weatherHeader || !pinButton) {
                console.log(`[WEATHER] ${label} | Missing elements`, {
                    hasCarrot: !!weatherCarrot,
                    hasHeader: !!weatherHeader,
                    hasPin: !!pinButton
                });
                return;
            }

            const carrotRect = weatherCarrot.getBoundingClientRect();
            const headerRect = weatherHeader.getBoundingClientRect();
            const pinRect = pinButton.getBoundingClientRect();
            const pinStyles = window.getComputedStyle(pinButton);

            const snapshot = {
                label,
                carrot: { width: carrotRect.width, height: carrotRect.height, top: carrotRect.top, left: carrotRect.left },
                header: { width: headerRect.width, height: headerRect.height, top: headerRect.top, left: headerRect.left },
                pin: { width: pinRect.width, height: pinRect.height, top: pinRect.top, left: pinRect.left },
                pinVisibility: pinStyles.visibility,
                pinOpacity: pinStyles.opacity,
                pinPointerEvents: pinStyles.pointerEvents
            };

            if (lastWeatherSnapshot) {
                const sizeDelta = {
                    carrotHeight: snapshot.carrot.height - lastWeatherSnapshot.carrot.height,
                    headerHeight: snapshot.header.height - lastWeatherSnapshot.header.height
                };
                snapshot.sizeDelta = sizeDelta;
            }

            lastWeatherSnapshot = snapshot;
            console.log(`[WEATHER] ${label} ${JSON.stringify(snapshot)}`);
        }

        function setupWeatherPinLogging() {
            const weatherCarrot = carrotList ? carrotList.querySelector('.carrot--weather') : null;
            if (!weatherCarrot || weatherCarrot.dataset.loggingAttached === 'true') {
                return;
            }

            weatherCarrot.dataset.loggingAttached = 'true';
            logWeatherCarrotLayout('init');
            weatherCarrot.addEventListener('mouseenter', () => {
                requestAnimationFrame(() => logWeatherCarrotLayout('mouseenter'));
            });
            weatherCarrot.addEventListener('mouseleave', () => {
                requestAnimationFrame(() => logWeatherCarrotLayout('mouseleave'));
            });
        }

        function setCarrotContent(state, amountOrTerm, fromCurrencyOrTargetLanguage, toCurrencyOrTranslation) {
            if (!carrotList) {
                return;
            }

            lastCarrotContext = {
                state,
                amountOrTerm,
                fromCurrencyOrTargetLanguage,
                toCurrencyOrTranslation
            };

            // Use templates from carrot-templates.js
            switch(state) {
                case 0:
                    carrotList.innerHTML = carrotTemplates.local();
                    break;
                case 1:
                    carrotList.innerHTML = carrotTemplates.flights();
                    break;
                case 2:
                    carrotList.innerHTML = carrotTemplates.wikipedia();
                    break;
                case 3:
                    carrotList.innerHTML = carrotTemplates.placeholder();
                    break;
                case 4:
                    carrotList.innerHTML = carrotTemplates.weather();
                    // Attach pin button handler for weather
                    setTimeout(() => {
                        attachPinButtonHandler(4);
                        setupWeatherPinLogging();
                    }, 0);
                    break;
                case 5:
                    carrotList.innerHTML = carrotTemplates.sports();
                    break;
                case 6:
                    carrotList.innerHTML = carrotTemplates.stocks();
                    break;
                case 20:
                    carrotList.innerHTML = carrotTemplates.stocksETFs();
                    break;
                case 7:
                    carrotList.innerHTML = carrotTemplates.worldClock();
                    // Attach pin button handler for world clock
                    setTimeout(() => {
                        attachPinButtonHandler(7);
                    }, 0);
                    break;
                case 8:
                    carrotList.innerHTML = carrotTemplates.adMarketplace();
                    break;
                case 18:
                    carrotList.innerHTML = carrotTemplates.adMarketplaceRamen();
                    break;
                case 19:
                    carrotList.innerHTML = carrotTemplates.adMarketplaceSushi();
                    break;
                case 9:
                    carrotList.innerHTML = carrotTemplates.bigAd();
                    break;
                case 10:
                    carrotList.innerHTML = carrotTemplates.mdn();
                    break;
                case 11:
                    carrotList.innerHTML = carrotTemplates.happyEmoji();
                    // Add click handlers for emoji copying
                    setTimeout(() => {
                        const emojiItems = carrotList.querySelectorAll('.emoji-item');
                        emojiItems.forEach(item => {
                            item.addEventListener('click', () => {
                                const emoji = item.getAttribute('data-emoji');
                                if (emoji && navigator.clipboard) {
                                    navigator.clipboard.writeText(emoji).then(() => {
                                        // Visual feedback could be added here
                                    }).catch(err => {
                                        console.error('Failed to copy emoji:', err);
                                    });
                                }
                            });
                        });
                    }, 0);
                    break;
                case 12:
                    carrotList.innerHTML = carrotTemplates.youtube();
                    break;
                case 13:
                    carrotList.innerHTML = carrotTemplates.vpn();
                    // Add toggle functionality
                    setTimeout(() => {
                        const toggleInput = carrotList.querySelector('.vpn-toggle-input');
                        const statusIndicator = carrotList.querySelector('.vpn-status-indicator');
                        const statusText = carrotList.querySelector('.vpn-status-text');
                        const vpnIndicator = document.getElementById('vpn-indicator');
                        
                        if (toggleInput) {
                            toggleInput.addEventListener('change', (e) => {
                                if (e.target.checked) {
                                    statusIndicator.classList.remove('vpn-status-indicator--off');
                                    statusIndicator.classList.add('vpn-status-indicator--on');
                                    statusText.textContent = 'VPN is on';
                                    if (vpnIndicator) {
                                        vpnIndicator.classList.add('is-active');
                                    }
                                } else {
                                    statusIndicator.classList.remove('vpn-status-indicator--on');
                                    statusIndicator.classList.add('vpn-status-indicator--off');
                                    statusText.textContent = 'VPN is off';
                                    if (vpnIndicator) {
                                        vpnIndicator.classList.remove('is-active');
                                    }
                                }
                            });
                        }
                    }, 0);
                    break;
                case 14:
                    carrotList.innerHTML = carrotTemplates.currency(amountOrTerm, fromCurrencyOrTargetLanguage, toCurrencyOrTranslation);
                    break;
                case 15:
                    carrotList.innerHTML = carrotTemplates.translation(amountOrTerm, fromCurrencyOrTargetLanguage, toCurrencyOrTranslation);
                    break;
                case 16:
                    carrotList.innerHTML = carrotTemplates.renewableEnergy();
                    // Load the image for the renewable energy card
                    setTimeout(async () => {
                        const placeholder = carrotList.querySelector('.carrot--story-card .image-placeholder');
                        if (placeholder) {
                            try {
                                const response = await fetch(`https://api.pexels.com/v1/search?query=${encodeURIComponent('renewable energy')}&per_page=1`, {
                                    headers: {
                                        Authorization: 'bCm88s2aE42pgTVWHJn6CRvAf916qPGquNowlZue6tSbVSImQ0hdsWSX'
                                    }
                                });
                                if (response.ok) {
                                    const data = await response.json();
                                    const photoUrl = data.photos && data.photos[0] ? data.photos[0].src.medium : null;
                                    if (photoUrl) {
                                        const img = document.createElement('img');
                                        img.src = photoUrl;
                                        img.alt = 'Breakthroughs in Renewable Energy';
                                        img.style.width = '100%';
                                        img.style.height = '120px';
                                        img.style.objectFit = 'cover';
                                        placeholder.replaceWith(img);
                                    }
                                }
                            } catch (error) {
                                console.error('Error loading renewable energy image:', error);
                            }
                        }
                    }, 0);
                    break;
                default:
                    console.warn(`Unknown carrot state: ${state}`);
            }

            carrotList.dataset.carrotState = String(state);
        }
        
        function attachPinButtonHandler(carrotState) {
            if (!carrotList) return;
            
            const pinButtons = carrotList.querySelectorAll('.carrot-pin-button');
            pinButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Handle world clock carrot (state 7)
                    if (carrotState === 7) {
                        console.log('[PIN] Pin button clicked for world clock carrot');
                        const pinnedCard = replaceThirdCardWithWorldClock();
                        handlePinSuccess(pinnedCard);
                    }
                    // Handle stocks carrot
                    else {
                        // Find the parent stock-item or sports-item
                        const stockItem = button.closest('.stock-item');
                        const sportsItem = button.closest('.sports-item');
                        
                        if (stockItem) {
                            console.log('[PIN] Pin button clicked for stock item');
                            const pinnedCard = replaceThirdCardWithStock(stockItem);
                            handlePinSuccess(pinnedCard);
                        } else if (sportsItem) {
                            console.log('[PIN] Pin button clicked for sports item');
                            const pinnedCard = replaceThirdCardWithSports(sportsItem);
                            handlePinSuccess(pinnedCard);
                        }
                    }
                });
            });
            
            // Handle weather pin button (state 4)
            if (carrotState === 4) {
                const weatherPinButton = carrotList.querySelector('.weather-pin-button');
                if (weatherPinButton) {
                    // Remove any existing listeners by cloning the button
                    const newButton = weatherPinButton.cloneNode(true);
                    weatherPinButton.replaceWith(newButton);
                    
                    newButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('[PIN] Pin button clicked for weather carrot');
                        const pinnedCard = replaceThirdCardWithWeather();
                        handlePinSuccess(pinnedCard);
                    });
                }
            }
        }
        
        function handlePinSuccess(pinnedCard) {
            if (pinnedCard) {
                console.log('[PIN] Pinned card element:', pinnedCard);
                
                // Close the overlay the same way as cross button or Esc
                const existingStyle = document.getElementById('gradient-animation-style');
                if (existingStyle) {
                    existingStyle.remove();
                }
                if (gradientAnimationId) {
                    cancelAnimationFrame(gradientAnimationId);
                    gradientAnimationId = null;
                }
                setOverlayState(false);
                if (searchBoxElement) {
                    searchBoxElement.blur();
                    // Clear the search term
                    searchBoxElement.value = '';
                }
                
                // Add border color
                pinnedCard.classList.add('card--pinned-flash');
            } else {
                console.log('[PIN] ERROR: pinnedCard is null or undefined');
            }
        }
        
        function replaceThirdCardWithWorldClock() {
            console.log('[REPLACE] replaceThirdCardWithWorldClock called');
            const articlesGrid = document.querySelector('.articles-grid');
            console.log('[REPLACE] articlesGrid:', articlesGrid);
            if (!articlesGrid) {
                console.log('[REPLACE] ERROR: articlesGrid not found');
                return;
            }
            
            const cards = articlesGrid.querySelectorAll('.card');
            console.log('[REPLACE] Found cards:', cards.length);
            if (cards.length < 3) {
                console.log('[REPLACE] ERROR: Not enough cards, found:', cards.length);
                return;
            }
            
            const thirdCard = cards[2]; // Third card (0-indexed)
            console.log('[REPLACE] Third card:', thirdCard);
            
            // Store the original card HTML for restoration
            const originalCardHTML = thirdCard.outerHTML;
            
            // Get the world clock HTML (fresh calculation)
            const worldClockHTML = carrotTemplates.worldClock();
            
            // Create a wrapper div for the clock content
            const clockWrapper = document.createElement('div');
            clockWrapper.className = 'card card--world-clock';
            clockWrapper.style.cssText = 'display: flex; align-items: center; justify-content: center; min-height: 200px; padding: 20px; background: white; border-radius: 12px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); border: 5px solid transparent; position: relative;';
            
            // Store the original card HTML for restoration
            clockWrapper.dataset.originalCard = originalCardHTML;
            
            // Add control buttons (grab icon and cross)
            const controlsDiv = createCardControls(clockWrapper);
            clockWrapper.appendChild(controlsDiv);
            
            // Extract just the clock content from the world clock template (remove the <li> wrapper)
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = worldClockHTML;
            const clockContent = tempDiv.querySelector('.carrot--clock');
            
            if (clockContent) {
                // Clone the clock content and remove the pin button
                const clonedContent = clockContent.cloneNode(true);
                const pinButton = clonedContent.querySelector('.carrot-pin-button');
                if (pinButton) {
                    pinButton.remove();
                }
                
                // Remove the carrot class styling that might conflict
                clonedContent.classList.remove('carrot');
                clonedContent.style.cssText = 'width: 100%;';
                
                clockWrapper.appendChild(clonedContent);
                console.log('[REPLACE] Replacing third card with clockWrapper');
                thirdCard.replaceWith(clockWrapper);
                console.log('[REPLACE] Replacement complete, returning clockWrapper:', clockWrapper);
                console.log('[REPLACE] clockWrapper classes:', clockWrapper.className);
                console.log('[REPLACE] clockWrapper styles:', clockWrapper.style.cssText);
                
                return clockWrapper;
            }
            console.log('[REPLACE] ERROR: clockContent not found');
            return null;
        }
        
        function replaceThirdCardWithStock(stockItem) {
            console.log('[REPLACE] replaceThirdCardWithStock called');
            const articlesGrid = document.querySelector('.articles-grid');
            if (!articlesGrid) {
                console.log('[REPLACE] ERROR: articlesGrid not found');
                return null;
            }
            
            const cards = articlesGrid.querySelectorAll('.card');
            if (cards.length < 3) {
                console.log('[REPLACE] ERROR: Not enough cards');
                return null;
            }
            
            const thirdCard = cards[2];
            const originalCardHTML = thirdCard.outerHTML;
            
            // Clone the stock item content
            const clonedStockItem = stockItem.cloneNode(true);
            const pinButton = clonedStockItem.querySelector('.carrot-pin-button');
            if (pinButton) {
                pinButton.remove();
            }
            
            // Create wrapper
            const stockWrapper = document.createElement('div');
            stockWrapper.className = 'card card--stock';
            stockWrapper.style.cssText = 'padding: 24px; background: white; border-radius: 12px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); border: 5px solid transparent; position: relative;';
            stockWrapper.dataset.originalCard = originalCardHTML;
            
            // Add controls
            const controlsDiv = createCardControls(stockWrapper);
            stockWrapper.appendChild(controlsDiv);
            
            // Add stock content - ensure it maintains flex layout
            clonedStockItem.style.cssText = '';
            stockWrapper.appendChild(clonedStockItem);
            
            thirdCard.replaceWith(stockWrapper);
            return stockWrapper;
        }
        
        function replaceThirdCardWithSports(sportsItem) {
            console.log('[REPLACE] replaceThirdCardWithSports called');
            const articlesGrid = document.querySelector('.articles-grid');
            if (!articlesGrid) {
                console.log('[REPLACE] ERROR: articlesGrid not found');
                return null;
            }
            
            const cards = articlesGrid.querySelectorAll('.card');
            if (cards.length < 3) {
                console.log('[REPLACE] ERROR: Not enough cards');
                return null;
            }
            
            const thirdCard = cards[2];
            const originalCardHTML = thirdCard.outerHTML;
            
            // Clone the sports item content
            const clonedSportsItem = sportsItem.cloneNode(true);
            const pinButton = clonedSportsItem.querySelector('.carrot-pin-button');
            if (pinButton) {
                pinButton.remove();
            }
            
            // Create wrapper
            const sportsWrapper = document.createElement('div');
            sportsWrapper.className = 'card card--sports';
            sportsWrapper.style.cssText = 'padding: 24px; background: white; border-radius: 12px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); border: 5px solid transparent; position: relative;';
            sportsWrapper.dataset.originalCard = originalCardHTML;
            
            // Add controls
            const controlsDiv = createCardControls(sportsWrapper);
            sportsWrapper.appendChild(controlsDiv);
            
            // Add sports content - ensure it maintains flex layout
            clonedSportsItem.style.cssText = '';
            sportsWrapper.appendChild(clonedSportsItem);
            
            thirdCard.replaceWith(sportsWrapper);
            return sportsWrapper;
        }
        
        function replaceThirdCardWithWeather() {
            console.log('[REPLACE] replaceThirdCardWithWeather called');
            const articlesGrid = document.querySelector('.articles-grid');
            if (!articlesGrid) {
                console.log('[REPLACE] ERROR: articlesGrid not found');
                return null;
            }
            
            const cards = articlesGrid.querySelectorAll('.card');
            if (cards.length < 3) {
                console.log('[REPLACE] ERROR: Not enough cards');
                return null;
            }
            
            const thirdCard = cards[2];
            const originalCardHTML = thirdCard.outerHTML;
            
            // Get the weather HTML (fresh calculation)
            const weatherHTML = carrotTemplates.weather();
            
            // Create a wrapper div for the weather content
            const weatherWrapper = document.createElement('div');
            weatherWrapper.className = 'card card--weather';
            weatherWrapper.style.cssText = 'min-height: 200px; padding: 20px; background: white; border-radius: 12px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); border: 5px solid transparent; position: relative;';
            weatherWrapper.dataset.originalCard = originalCardHTML;
            
            // Add control buttons (grab icon and cross)
            const controlsDiv = createCardControls(weatherWrapper);
            weatherWrapper.appendChild(controlsDiv);
            
            // Extract just the weather content from the weather template (remove the <li> wrapper)
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = weatherHTML;
            const weatherContent = tempDiv.querySelector('.carrot--weather');
            
            if (weatherContent) {
                // Clone the weather content and remove the pin button
                const clonedContent = weatherContent.cloneNode(true);
                const pinButton = clonedContent.querySelector('.weather-pin-button');
                if (pinButton) {
                    pinButton.remove();
                }
                
                // Remove the carrot class styling that might conflict
                clonedContent.classList.remove('carrot');
                clonedContent.style.cssText = 'width: 100%;';
                
                weatherWrapper.appendChild(clonedContent);
                console.log('[REPLACE] Replacing third card with weatherWrapper');
                thirdCard.replaceWith(weatherWrapper);
                return weatherWrapper;
            }
            console.log('[REPLACE] ERROR: weatherContent not found');
            return null;
        }
        
        function createCardControls(wrapper) {
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'card-controls';
            
            // Grab/move icon button
            const grabButton = document.createElement('button');
            grabButton.className = 'card-control-button';
            grabButton.type = 'button';
            grabButton.setAttribute('aria-label', 'Move card');
            grabButton.innerHTML = `
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M9 5C9 6.10457 8.10457 7 7 7C5.89543 7 5 6.10457 5 5C5 3.89543 5.89543 3 7 3C8.10457 3 9 3.89543 9 5Z" fill="#1F2933"/>
                    <path d="M19 5C19 6.10457 18.1046 7 17 7C15.8954 7 15 6.10457 15 5C15 3.89543 15.8954 3 17 3C18.1046 3 19 3.89543 19 5Z" fill="#1F2933"/>
                    <path d="M9 12C9 13.1046 8.10457 14 7 14C5.89543 14 5 13.1046 5 12C5 10.8954 5.89543 10 7 10C8.10457 10 9 10.8954 9 12Z" fill="#1F2933"/>
                    <path d="M19 12C19 13.1046 18.1046 14 17 14C15.8954 14 15 13.1046 15 12C15 10.8954 15.8954 10 17 10C18.1046 10 19 10.8954 19 12Z" fill="#1F2933"/>
                    <path d="M9 19C9 20.1046 8.10457 21 7 21C5.89543 21 5 20.1046 5 19C5 17.8954 5.89543 17 7 17C8.10457 17 9 17.8954 9 19Z" fill="#1F2933"/>
                    <path d="M19 19C19 20.1046 18.1046 21 17 21C15.8954 21 15 20.1046 15 19C15 17.8954 15.8954 17 17 17C18.1046 17 19 17.8954 19 19Z" fill="#1F2933"/>
                </svg>
            `;
            grabButton.style.cursor = 'grab';
            
            // Close/cross button
            const closeButton = document.createElement('button');
            closeButton.className = 'card-control-button';
            closeButton.type = 'button';
            closeButton.setAttribute('aria-label', 'Remove pinned card');
            closeButton.innerHTML = `
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M18 6L6 18M6 6l12 12" stroke="#1F2933" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            `;
            
            closeButton.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                restoreOriginalCard(wrapper);
            });
            
            controlsDiv.appendChild(grabButton);
            controlsDiv.appendChild(closeButton);
            return controlsDiv;
        }
        
        function restoreOriginalCard(pinnedCard) {
            const originalCardHTML = pinnedCard.dataset.originalCard;
            if (!originalCardHTML) return;
            
            // Create a temporary container to parse the HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = originalCardHTML;
            const originalCard = tempDiv.firstElementChild;
            
            if (originalCard) {
                pinnedCard.replaceWith(originalCard);
            }
        }
        
        if (debugButtons.length > 0 && suggestionsContainer && carrotList) {
            // Button 0 (index 0): No enriched content (suggestions only)
            debugButtons[0].addEventListener('click', () => {
                currentState = 0;
                suggestionsContainer.classList.add('expand-left');
                suggestionsContainer.classList.remove('show-carrot');
            });

            // Button 1 (index 1): Local recommendations (placeholder)
            debugButtons[1].addEventListener('click', () => {
                if (currentState !== 0) {
                    // Transition to 0 first
                    suggestionsContainer.classList.add('expand-left');
                    suggestionsContainer.classList.remove('show-carrot');
                    
                    // Wait for slide out, then change content while hidden, then slide in
                    setTimeout(() => {
                        setCarrotContent(0);
                        currentState = 1;
                        suggestionsContainer.classList.remove('expand-left');
                        suggestionsContainer.classList.add('show-carrot');
                    }, 400);
                } else {
                    setCarrotContent(0);
                    currentState = 1;
                    suggestionsContainer.classList.remove('expand-left');
                    suggestionsContainer.classList.add('show-carrot');
                }
            });

            // Button 2 (index 2): Flights (AC 8170)
            debugButtons[2].addEventListener('click', () => {
                if (currentState !== 0) {
                    // Transition to 0 first
                    suggestionsContainer.classList.add('expand-left');
                    suggestionsContainer.classList.remove('show-carrot');
                    
                    // Wait for slide out, then change content while hidden, then slide in
                    setTimeout(() => {
                        setCarrotContent(1);
                        currentState = 2;
                        suggestionsContainer.classList.remove('expand-left');
                        suggestionsContainer.classList.add('show-carrot');
                    }, 400);
                } else {
                    setCarrotContent(1);
                    setCarrotColor(null);
                    currentState = 2;
                    suggestionsContainer.classList.remove('expand-left');
                    suggestionsContainer.classList.add('show-carrot');
                }
            });

            // Button 3 (index 3): Wikipedia
            debugButtons[3].addEventListener('click', () => {
                if (currentState !== 0) {
                    // Transition to 0 first
                    suggestionsContainer.classList.add('expand-left');
                    suggestionsContainer.classList.remove('show-carrot');
                    
                    // Wait for slide out, then change content while hidden, then slide in
                    setTimeout(() => {
                        setCarrotContent(2);
                        currentState = 3;
                        suggestionsContainer.classList.remove('expand-left');
                        suggestionsContainer.classList.add('show-carrot');
                    }, 400);
                } else {
                    setCarrotContent(2);
                    setCarrotColor(null);
                    currentState = 3;
                    suggestionsContainer.classList.remove('expand-left');
                    suggestionsContainer.classList.add('show-carrot');
                }
            });

            // Button 4 (index 4): Weather
            debugButtons[4].addEventListener('click', () => {
                if (currentState !== 0) {
                    // Transition to 0 first
                    suggestionsContainer.classList.add('expand-left');
                    suggestionsContainer.classList.remove('show-carrot');
                    
                    // Wait for slide out, then change content while hidden, then slide in
                    setTimeout(() => {
                        setCarrotContent(4);
                        currentState = 4;
                        suggestionsContainer.classList.remove('expand-left');
                        suggestionsContainer.classList.add('show-carrot');
                    }, 400);
                } else {
                    setCarrotContent(4);
                    setCarrotColor('green-text');
                    currentState = 4;
                    suggestionsContainer.classList.remove('expand-left');
                    suggestionsContainer.classList.add('show-carrot');
                }
            });

            // Button 5 (index 5): Sports
            debugButtons[5].addEventListener('click', () => {
                if (currentState !== 0) {
                    // Transition to 0 first
                    suggestionsContainer.classList.add('expand-left');
                    suggestionsContainer.classList.remove('show-carrot');
                    
                    // Wait for slide out, then change content while hidden, then slide in
                    setTimeout(() => {
                        setCarrotContent(5);
                        currentState = 5;
                        suggestionsContainer.classList.remove('expand-left');
                        suggestionsContainer.classList.add('show-carrot');
                    }, 400);
                } else {
                    setCarrotContent(5);
                    setCarrotColor(null);
                    currentState = 5;
                    suggestionsContainer.classList.remove('expand-left');
                    suggestionsContainer.classList.add('show-carrot');
                }
            });

            // Button 6 (index 6): Stocks
            debugButtons[6].addEventListener('click', () => {
                if (currentState !== 0) {
                    suggestionsContainer.classList.add('expand-left');
                    suggestionsContainer.classList.remove('show-carrot');
                    
                    setTimeout(() => {
                        setCarrotContent(6);
                        currentState = 6;
                        suggestionsContainer.classList.remove('expand-left');
                        suggestionsContainer.classList.add('show-carrot');
                    }, 400);
                } else {
                    setCarrotContent(6);
                    setCarrotColor(null);
                    currentState = 6;
                    suggestionsContainer.classList.remove('expand-left');
                    suggestionsContainer.classList.add('show-carrot');
                }
            });

            // Button 7 (index 7): World clock
            debugButtons[7].addEventListener('click', () => {
                if (currentState !== 0) {
                    suggestionsContainer.classList.add('expand-left');
                    suggestionsContainer.classList.remove('show-carrot');
                    
                    setTimeout(() => {
                        setCarrotContent(7);
                        currentState = 7;
                        suggestionsContainer.classList.remove('expand-left');
                        suggestionsContainer.classList.add('show-carrot');
                    }, 400);
                } else {
                    setCarrotContent(7);
                    setCarrotColor(null);
                    currentState = 7;
                    suggestionsContainer.classList.remove('expand-left');
                    suggestionsContainer.classList.add('show-carrot');
                }
            });
        }

        const flightNumberPattern = /ac\s*8170/i;

        if (searchBoxElement && suggestionsContainer && carrotList) {
            searchBoxElement.addEventListener('focus', () => {
                if (currentState !== 0 || suggestionsContainer.classList.contains('show-carrot')) {
                    setCarrotContent(0);
                    currentState = 0;
                    suggestionsContainer.classList.add('expand-left');
                    suggestionsContainer.classList.remove('show-carrot');
                }
                
                // Reset to default suggestions if search box is empty
                if (!searchBoxElement.value.trim()) {
                    // Clear AI suggestions tracking
                    aiSuggestionsSet.clear();
                    // Get default suggestions filtered by removed ones
                    const defaultSuggestions = getDefaultSuggestions();
                    updateSuggestions(defaultSuggestions);
                }
            });

            searchBoxElement.addEventListener('keydown', (event) => {
                if (!suggestionsList) return;
                
                const suggestionItems = suggestionsList.querySelectorAll('.search-suggestions-preview-item');
                if (suggestionItems.length === 0) return;
                
                // Calculate virtual item count (accounting for coffee shops having 2 businesses and stocks having 3 items)
                // Skip heading items (data-index="-1" or search-suggestions-preview-heading class)
                let virtualItemCount = 0;
                suggestionItems.forEach((item) => {
                    // Skip Firefox Suggest heading
                    if (item.classList.contains('search-suggestions-preview-heading') || item.dataset.index === '-1') {
                        return;
                    }
                    
                    if (item.classList.contains('local-business-wrapper')) {
                        const businessDivs = item.querySelectorAll('.local-business');
                        if (businessDivs.length === 2) {
                            virtualItemCount += 2; // Coffee shops
                        } else {
                            virtualItemCount += 1;
                        }
                    } else if (item.classList.contains('stocks-wrapper')) {
                        const stockDivs = item.querySelectorAll('.stock-item');
                        // Count each stock div as a virtual item
                        virtualItemCount += stockDivs.length > 0 ? stockDivs.length : 1;
                    } else if (item.classList.contains('sports-wrapper')) {
                        const sportsDivs = item.querySelectorAll('.sports-item');
                        virtualItemCount += sportsDivs.length > 0 ? sportsDivs.length : 1;
                    } else {
                        virtualItemCount += 1;
                    }
                });
                
                if (event.key === 'ArrowDown') {
                    event.preventDefault();
                    // Keyboard navigation steals selection from hovered item
                    // If nothing is selected, select the first item (index 0)
                    // Otherwise, move down one (wrap around to first if at last item)
                    if (selectedSuggestionIndex < 0) {
                        selectedSuggestionIndex = 0;
                    } else if (selectedSuggestionIndex < virtualItemCount - 1) {
                        selectedSuggestionIndex = selectedSuggestionIndex + 1;
                    } else {
                        // Wrap around to first item when at last item
                        selectedSuggestionIndex = 0;
                    }
                    updateSelectedSuggestion(true); // true = keyboard navigation
                    // Scroll into view if needed - find the actual DOM item
                    if (selectedSuggestionIndex >= 0 && selectedSuggestionIndex < virtualItemCount) {
                        // Find which DOM item contains this virtual index
                        let currentVirtualIndex = 0;
                        for (let i = 0; i < suggestionItems.length; i++) {
                            const item = suggestionItems[i];
                            
                            // Skip Firefox Suggest heading
                            if (item.classList.contains('search-suggestions-preview-heading') || item.dataset.index === '-1') {
                                continue;
                            }
                            
                            let itemVirtualCount = 1;
                            if (item.classList.contains('local-business-wrapper')) {
                                const businessDivs = item.querySelectorAll('.local-business');
                                itemVirtualCount = businessDivs.length === 2 ? 2 : 1;
                            } else if (item.classList.contains('stocks-wrapper')) {
                                const stockDivs = item.querySelectorAll('.stock-item');
                                itemVirtualCount = stockDivs.length > 0 ? stockDivs.length : 1;
                            } else if (item.classList.contains('sports-wrapper')) {
                                const sportsDivs = item.querySelectorAll('.sports-item');
                                itemVirtualCount = sportsDivs.length > 0 ? sportsDivs.length : 1;
                            }
                            if (selectedSuggestionIndex >= currentVirtualIndex && selectedSuggestionIndex < currentVirtualIndex + itemVirtualCount) {
                                item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                                break;
                            }
                            currentVirtualIndex += itemVirtualCount;
                        }
                    }
                } else if (event.key === 'ArrowUp') {
                    event.preventDefault();
                    // Keyboard navigation steals selection from hovered item
                    // If nothing is selected, select the last item
                    // Otherwise, move up one
                    if (selectedSuggestionIndex < 0) {
                        selectedSuggestionIndex = virtualItemCount - 1;
                    } else if (selectedSuggestionIndex <= 0) {
                        selectedSuggestionIndex = virtualItemCount - 1;
                    } else {
                        selectedSuggestionIndex--;
                    }
                    updateSelectedSuggestion(true); // true = keyboard navigation
                    // Scroll into view if needed - find the actual DOM item
                    if (selectedSuggestionIndex >= 0 && selectedSuggestionIndex < virtualItemCount) {
                        // Find which DOM item contains this virtual index
                        let currentVirtualIndex = 0;
                        for (let i = 0; i < suggestionItems.length; i++) {
                            const item = suggestionItems[i];
                            
                            // Skip Firefox Suggest heading
                            if (item.classList.contains('search-suggestions-preview-heading') || item.dataset.index === '-1') {
                                continue;
                            }
                            
                            let itemVirtualCount = 1;
                            if (item.classList.contains('local-business-wrapper')) {
                                const businessDivs = item.querySelectorAll('.local-business');
                                itemVirtualCount = businessDivs.length === 2 ? 2 : 1;
                            } else if (item.classList.contains('stocks-wrapper')) {
                                const stockDivs = item.querySelectorAll('.stock-item');
                                itemVirtualCount = stockDivs.length > 0 ? stockDivs.length : 1;
                            } else if (item.classList.contains('sports-wrapper')) {
                                const sportsDivs = item.querySelectorAll('.sports-item');
                                itemVirtualCount = sportsDivs.length > 0 ? sportsDivs.length : 1;
                            }
                            if (selectedSuggestionIndex >= currentVirtualIndex && selectedSuggestionIndex < currentVirtualIndex + itemVirtualCount) {
                                item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                                break;
                            }
                            currentVirtualIndex += itemVirtualCount;
                        }
                    }
                }
                // COMMENTED OUT: Google search on Enter disabled
                // else if (event.key === 'Enter' && selectedSuggestionIndex >= 0) {
                //     event.preventDefault();
                //     // Use the search box value (which should be updated by keyboard navigation)
                //     const searchText = searchBoxElement.value.trim();
                //     if (searchText) {
                //         performGoogleSearch(searchText);
                //     }
                // }
            });


            // Show/hide clear button based on input value
            const updateClearButton = () => {
                if (searchClearButton && searchBoxElement) {
                    if (searchBoxElement.value.trim().length > 0) {
                        searchClearButton.style.display = 'flex';
                    } else {
                        searchClearButton.style.display = 'none';
                    }
                }
            };

            // Clear button click handler
            if (searchClearButton) {
                searchClearButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (searchBoxElement) {
                        searchBoxElement.value = '';
                        searchBoxElement.focus();
                        // Reset to default suggestions
                        updateSuggestions([
                            'hoka',
                            'macbook',
                            '13 in macbook air',
                            'Coffee machines for sale',
                            'taylor swift',
                            'coffee grinder',
                            'gmail'
                        ]);
                        // Clear AI suggestions tracking
                        aiSuggestionsSet.clear();
                        // Remove skeletons
                        removeSkeletons();
                        // Clear any pending API calls
                        if (apiCallTimer) {
                            clearTimeout(apiCallTimer);
                            apiCallTimer = null;
                        }
                        lastApiQuery = '';
                        // Clear carrot state
                        if (suggestionsContainer) {
                            suggestionsContainer.classList.remove('show-carrot');
                            suggestionsContainer.classList.remove('show-preview-box');
                            suggestionsContainer.classList.add('expand-left');
                            const previewBox = document.querySelector('.preview-box');
                            if (previewBox) {
                                previewBox.innerHTML = '';
                                previewBox.style.display = 'none';
                            }
                        }
                        currentState = 0;
                        if (carrotList) {
                            carrotList.innerHTML = '';
                            carrotList.dataset.carrotState = '0';
                        }
                        // Restore product grid when cleared
                        restoreProductGrid();
                        updateClearButton();
                    }
                });
            }

            let shouldCloseCarrotOnInput = false;

            if (searchBoxElement) {
                searchBoxElement.addEventListener('beforeinput', (event) => {
                    const target = event.target;
                    if (!(target instanceof HTMLInputElement)) {
                        shouldCloseCarrotOnInput = false;
                        return;
                    }

                    const inputType = event.inputType || '';
                    const hasSelection = target.selectionStart !== null
                        && target.selectionEnd !== null
                        && target.selectionStart !== target.selectionEnd;

                    shouldCloseCarrotOnInput = inputType.startsWith('delete')
                        || (hasSelection && (inputType.startsWith('insert') || inputType === 'insertReplacementText'));
                });
            }

            // Update clear button on input
            searchBoxElement.addEventListener('input', (event) => {
                console.log('[INPUT] ===== INPUT EVENT STARTED =====');
                if (topOverlay && !topOverlay.classList.contains('is-focused')) {
                    setOverlayState(true);
                }
                updateClearButton();
                const value = (event.target.value || '').toString();
                const valueLower = value.toLowerCase().trim();
                console.log('[INPUT] Raw value:', value, '| Trimmed lower:', valueLower, '| Length:', valueLower.length);
                
                // Immediately close carrot when deleting text or overwriting a selection
                if (suggestionsContainer && suggestionsContainer.classList.contains('show-carrot') && shouldCloseCarrotOnInput) {
                    console.log('[INPUT] Delete or overwrite detected, closing carrot immediately');
                    suggestionsContainer.classList.remove('show-carrot');
                    suggestionsContainer.classList.add('expand-left');
                    currentState = 0;
                    if (carrotList) {
                        carrotList.innerHTML = '';
                        carrotList.dataset.carrotState = '0';
                    }
                    // Clear suspended carrot context since user is typing new input
                    suspendedCarrotContext = null;
                    suspendedByFirefoxUrls.clear();
                }
                shouldCloseCarrotOnInput = false;
                
                // Handle Winter Olympics schedule and background color (doesn't block suggestions)
                const isWinterOlympics = valueLower === 'winter ol' || valueLower.startsWith('winter ol');
                console.log('[INPUT] isWinterOlympics:', isWinterOlympics);
                if (isWinterOlympics) {
                    console.log('[INPUT] Setting winter olympics background and schedule');
                    if (topOverlay) {
                        topOverlay.classList.add('winter-olympics');
                    }
                    // Prevent scrolling
                    document.body.classList.add('winter-olympics-active');
                    document.documentElement.classList.add('winter-olympics-active');
                    renderWinterOlympicsSchedule();
                } else {
                    if (topOverlay) {
                        topOverlay.classList.remove('winter-olympics');
                    }
                    // Re-enable scrolling
                    document.body.classList.remove('winter-olympics-active');
                    document.documentElement.classList.remove('winter-olympics-active');
                    // Restore product grid if it was replaced
                    restoreProductGrid();
                }
                
                // Check if this matches a demo search that should show a carrot
                const matchedCarrot = showCarrotForDemoSearch(valueLower);
                console.log('[INPUT] matchedCarrot:', matchedCarrot);
                
                if (!matchedCarrot && valueLower.length === 0) {
                    console.log('[INPUT] Empty field, clearing carrot');
                    // Clear carrot when field is empty (already closed above, but ensure preview box is cleared)
                    if (suggestionsContainer) {
                        suggestionsContainer.classList.remove('show-preview-box');
                        const previewBox = document.querySelector('.preview-box');
                        if (previewBox) {
                            previewBox.innerHTML = '';
                            previewBox.style.display = 'none';
                        }
                    }
                    // Clear suspended carrot context since field is empty
                    suspendedCarrotContext = null;
                    suspendedByFirefoxUrls.clear();
                    // Restore product grid when search is cleared
                    restoreProductGrid();
                }
                
                // Continue to update suggestions even if a carrot is showing
                // The suggestions will appear in the left column while carrot stays in right column
                
                console.log('[INPUT] suggestionWords defined?', typeof suggestionWords !== 'undefined');
                console.log('[INPUT] suggestionWords available?', typeof suggestionWords !== 'undefined' && suggestionWords);
                
                // Check for 1-2 character suggestions from suggestionWords
                if (valueLower.length === 1) {
                    console.log('[INPUT] Branch: length === 1');
                    console.log('Processing 1 character:', valueLower);
                    // For single character, look for all two-character keys starting with that character
                    const matchingSuggestions = [];
                    if (typeof suggestionWords !== 'undefined' && suggestionWords) {
                        console.log('suggestionWords is available, searching keys...');
                        Object.keys(suggestionWords).forEach(key => {
                            if (key.startsWith(valueLower)) {
                                matchingSuggestions.push(...suggestionWords[key]);
                            }
                        });
                        console.log('Found matching suggestions:', matchingSuggestions.length);
                        // Limit to first 9 suggestions (typed text is shown separately as first item)
                        if (matchingSuggestions.length > 0) {
                            const suggestionsToShow = matchingSuggestions.slice(0, 9);
                            console.log('Updating suggestions with:', suggestionsToShow);
                            updateSuggestions(suggestionsToShow);
                            return;
                        } else {
                            console.log('No matching suggestions found');
                        }
                    } else {
                        console.log('suggestionWords is not available');
                    }
                } else if (valueLower.length === 2) {
                    console.log('[INPUT] Branch: length === 2');
                    // For two characters, use exact match
                    if (typeof suggestionWords !== 'undefined' && suggestionWords && suggestionWords[valueLower]) {
                        console.log('[INPUT] Found exact match:', suggestionWords[valueLower]);
                        updateSuggestions(suggestionWords[valueLower]);
                        console.log('[INPUT] Returning early from length === 2 branch');
                        return;
                    } else {
                        console.log('[INPUT] No exact match found for:', valueLower);
                    }
                } else if (valueLower.length >= 3) {
                    console.log('[INPUT] ===== Branch: length >= 3 =====');
                    console.log('[INPUT] Query:', valueLower, '| Length:', valueLower.length, '| isWinterOlympics:', isWinterOlympics);
                    
                    // Clear AI suggestions tracking when query changes
                    if (lastApiQuery && lastApiQuery !== valueLower) {
                        console.log('[INPUT] Query changed from', lastApiQuery, 'to', valueLower, '- clearing AI suggestions set');
                        aiSuggestionsSet.clear();
                    }
                    console.log('[INPUT] lastApiQuery:', lastApiQuery);
                    
                    // Check if we have existing suggestions to filter
                    const hasExistingSuggestions = currentDisplayedSuggestions.length > 0;
                    console.log('[INPUT] Has existing suggestions:', hasExistingSuggestions, 'count:', currentDisplayedSuggestions.length);
                    
                    let localSuggestions = [];
                    
                    if (hasExistingSuggestions) {
                        // Filter existing suggestions based on next character
                        // filterExistingSuggestions already handles adding skeletons to fill up to 9 total
                        console.log('[INPUT] Filtering existing suggestions for query:', valueLower);
                        const filteredSuggestions = filterExistingSuggestions(valueLower);
                        console.log('[INPUT] Filtered suggestions count:', filteredSuggestions.length);
                        // No need to add skeletons here - filterExistingSuggestions already did it
                    } else {
                        // No existing suggestions, show local results while waiting for AI
                        console.log('[INPUT] No existing suggestions, showing local results');
                        removeSkeletons();
                        if (typeof suggestionWords !== 'undefined' && suggestionWords) {
                            const allSuggestions = [];
                            Object.values(suggestionWords).forEach(suggestions => {
                                allSuggestions.push(...suggestions);
                            });
                            
                            // Filter to only suggestions that start with the query
                            const filtered = allSuggestions.filter(suggestion => {
                                const suggestionLower = suggestion.toLowerCase();
                                if (suggestionLower.startsWith(valueLower)) {
                                    return true;
                                }
                                const words = suggestionLower.split(/\s+/);
                                return words.some(word => word.startsWith(valueLower));
                            });
                            
                            localSuggestions = [...new Set(filtered)];
                            if (localSuggestions.length > 0) {
                                const localCount = Math.min(localSuggestions.length, 10);
                                updateSuggestions(localSuggestions.slice(0, localCount));
                                const skeletonCount = 9 - localCount;
                                if (skeletonCount > 0) {
                                    showSkeletonLoaders(skeletonCount);
                                }
                            } else {
                                updateSuggestions([]);
                                showSkeletonLoaders(9);
                            }
                        } else {
                            updateSuggestions([]);
                            showSkeletonLoaders(9);
                        }
                    }
                    
                    // Capture current displayed suggestions for use in async callback
                    const currentLocalSuggestions = hasExistingSuggestions ? [...currentDisplayedSuggestions] : localSuggestions;
                    
                    // Make API call immediately (no debounce)
                    console.log('[INPUT] Making immediate API call for query:', valueLower);
                    lastApiQuery = valueLower;
                    (async () => {
                        try {
                            console.log('[AI] Fetching AI suggestions for:', valueLower, 'winter olympics active:', isWinterOlympics);
                            
                            try {
                                console.log('[AI] Calling fetchAISuggestions...');
                                const aiSuggestions = await fetchAISuggestions(valueLower);
                                console.log('[AI] fetchAISuggestions returned:', aiSuggestions);
                                console.log('[AI] Number of suggestions:', aiSuggestions ? aiSuggestions.length : 0);
                                
                                // Only update if query hasn't changed during API call
                                const finalQuery = searchBoxElement.value.toLowerCase().trim();
                                console.log('[AI] Final query check:', finalQuery, '===', valueLower, '?', finalQuery === valueLower);
                                if (finalQuery === valueLower) {
                                    console.log('[AI] ✓ Query still matches after API call');
                                    console.log('[AI] aiSuggestions type:', typeof aiSuggestions);
                                    console.log('[AI] aiSuggestions isArray:', Array.isArray(aiSuggestions));
                                    console.log('[AI] aiSuggestions:', aiSuggestions);
                                    console.log('[AI] Received', aiSuggestions ? aiSuggestions.length : 0, 'AI suggestions for:', valueLower);
                                    if (aiSuggestions && Array.isArray(aiSuggestions) && aiSuggestions.length > 0) {
                                        console.log('[AI] AI suggestions:', aiSuggestions);
                                        
                                        // Track AI suggestions and Firefox suggestions for icon assignment
                                        const firefoxSuggestions = aiSuggestions._firefoxSuggestions || [];
                                        // Extract Firefox suggestion titles for comparison
                                        const firefoxTitles = firefoxSuggestions.map(fs => {
                                            if (typeof fs === 'object' && fs.title) {
                                                return fs.title.toLowerCase();
                                            }
                                            return typeof fs === 'string' ? fs.toLowerCase() : '';
                                        }).filter(t => t.length > 0);
                                        
                                        firefoxTitles.forEach(title => {
                                            firefoxSuggestionsSet.add(title);
                                        });
                                        
                                        aiSuggestions.forEach(aiSuggestion => {
                                            // Don't add Firefox suggestions to AI set
                                            const aiLower = aiSuggestion.toLowerCase();
                                            if (!firefoxTitles.includes(aiLower)) {
                                                aiSuggestionsSet.add(aiLower);
                                            }
                                        });
                                        
                                        // Get currently displayed suggestions from DOM (excluding Firefox Suggest items and skeletons)
                                        const currentlyDisplayed = [];
                                        if (suggestionsList) {
                                            const displayedItems = suggestionsList.querySelectorAll('.search-suggestions-preview-item:not(.skeleton):not(.search-suggestions-preview-heading):not(.firefox-suggest-item)');
                                            displayedItems.forEach(item => {
                                                const itemText = item.querySelector('.label')?.textContent?.trim();
                                                if (itemText) {
                                                    currentlyDisplayed.push(itemText);
                                                }
                                            });
                                        }
                                        
                                        console.log('[AI] Currently displayed suggestions:', currentlyDisplayed);
                                        
                                        // Start with currently displayed suggestions
                                        const allSuggestions = [...currentlyDisplayed];
                                        
                                        // Count existing skeletons to know how many AI suggestions to add
                                        const skeletonCount = suggestionsList ? suggestionsList.querySelectorAll('.skeleton').length : 0;
                                        console.log('[AI] Existing skeleton count:', skeletonCount);
                                        
                                        // Add AI suggestions to fill skeleton slots, avoiding duplicates
                                        // IMPORTANT: Exclude Firefox suggestions from regular suggestions - they're handled separately
                                        if (aiSuggestions && Array.isArray(aiSuggestions) && skeletonCount > 0) {
                                            // First pass: try to add suggestions that match the full query
                                            let addedCount = 0;
                                            for (const aiSuggestion of aiSuggestions) {
                                                if (addedCount >= skeletonCount) break;
                                                if (typeof aiSuggestion === 'string') {
                                                    const aiLower = aiSuggestion.toLowerCase();
                                                    // Skip Firefox suggestions - they're handled separately via _firefoxSuggestions
                                                    const isFirefoxSuggestion = firefoxTitles.includes(aiLower);
                                                    if (isFirefoxSuggestion) {
                                                        console.log('[AI] Skipping Firefox suggestion from regular list:', aiSuggestion);
                                                        continue;
                                                    }
                                                    // Only add if not already in displayed and matches full query exactly
                                                    const alreadyDisplayed = currentlyDisplayed.some(s => s.toLowerCase() === aiLower);
                                                    const matchesFullQuery = aiLower.startsWith(valueLower) || 
                                                                            aiSuggestion.split(/\s+/).some(word => word.toLowerCase().startsWith(valueLower));
                                                    if (!alreadyDisplayed && matchesFullQuery) {
                                                        allSuggestions.push(aiSuggestion);
                                                        addedCount++;
                                                    }
                                                }
                                            }
                                            
                                            // Second pass: if we still have skeleton slots, use looser matching (first 3 chars)
                                            if (addedCount < skeletonCount) {
                                                console.log('[AI] Only found', addedCount, 'exact matches, looking for partial matches to fill remaining', (skeletonCount - addedCount), 'slots');
                                                const queryPrefix = valueLower.slice(0, Math.min(valueLower.length, 3));
                                                for (const aiSuggestion of aiSuggestions) {
                                                    if (addedCount >= skeletonCount) break;
                                                    if (typeof aiSuggestion === 'string') {
                                                        const aiLower = aiSuggestion.toLowerCase();
                                                        const isFirefoxSuggestion = firefoxTitles.includes(aiLower);
                                                        if (isFirefoxSuggestion) continue;
                                                        
                                                        const alreadyAdded = allSuggestions.some(s => s.toLowerCase() === aiLower);
                                                        const matchesPrefix = aiLower.startsWith(queryPrefix) || 
                                                                            aiSuggestion.split(/\s+/).some(word => word.toLowerCase().startsWith(queryPrefix));
                                                        if (!alreadyAdded && matchesPrefix) {
                                                            allSuggestions.push(aiSuggestion);
                                                            addedCount++;
                                                        }
                                                    }
                                                }
                                            }
                                            
                                            console.log('[AI] Added', addedCount, 'new AI suggestions to fill', skeletonCount, 'skeleton slots');
                                        }
                                        
                                        console.log('[AI] allSuggestions after merge:', allSuggestions, 'length:', allSuggestions.length);
                                        
                                        // Preserve existing Firefox suggestions that match the query, only add new ones if needed
                                        const queryLower = valueLower.toLowerCase();
                                        const preservedFirefoxSuggestions = currentFirefoxSuggestions.filter(fs => {
                                            const fsTitle = (typeof fs === 'string' ? fs : fs.title || '').toLowerCase();
                                            return fsTitle.length >= queryLower.length && fsTitle.startsWith(queryLower);
                                        });
                                        
                                        // Only fetch new Firefox suggestions if we don't have enough matching ones
                                        // Use preserved ones if they exist, otherwise use new ones from API
                                        const finalFirefoxSuggestions = preservedFirefoxSuggestions.length > 0 
                                            ? preservedFirefoxSuggestions 
                                            : firefoxSuggestions;
                                        
                                        console.log('[AI] Preserved', preservedFirefoxSuggestions.length, 'Firefox suggestions from previous query');
                                        console.log('[AI] New Firefox suggestions from API:', firefoxSuggestions.length);
                                        console.log('[AI] Using', finalFirefoxSuggestions.length, 'Firefox suggestions total');
                                        
                                        // Calculate how many AI suggestions we can show
                                        // Total = 10 items (1 typed text + Firefox suggestions + AI suggestions)
                                        // So AI suggestions = 10 - 1 - Firefox count = 9 - Firefox count
                                        const maxAISuggestions = Math.max(0, 9 - finalFirefoxSuggestions.length);
                                        console.log('[AI] Max AI suggestions allowed (9 - Firefox count):', maxAISuggestions);
                                        
                                        // Limit AI suggestions to leave room for Firefox suggestions
                                        const mergedSuggestions = allSuggestions.slice(0, maxAISuggestions);
                                        
                                        // Store Firefox suggestions (full objects) for rendering
                                        mergedSuggestions._firefoxSuggestions = finalFirefoxSuggestions;
                                        console.log('[AI] Merged suggestions (local + AI):', mergedSuggestions);
                                        console.log('[AI] Merged suggestions length:', mergedSuggestions.length);
                                        console.log('[AI] Merged suggestions isArray:', Array.isArray(mergedSuggestions));
                                        console.log('[AI] Firefox suggestions (full objects):', firefoxSuggestions);
                                        console.log('[AI] Firefox suggestions length:', firefoxSuggestions.length);
                                        console.log('[AI] Firefox titles:', firefoxTitles);
                                        console.log('[AI] About to call updateSuggestions with:', mergedSuggestions);
                                        // updateSuggestions will add new suggestions where skeletons were
                                        updateSuggestions(mergedSuggestions);
                                    } else {
                                        // No AI suggestions - update with just local suggestions
                                        // This will remove skeletons and show local suggestions
                                        console.log('[AI] No AI suggestions, using local:', currentLocalSuggestions);
                                        if (currentLocalSuggestions.length > 0) {
                                            const localCount = Math.min(currentLocalSuggestions.length, 10);
                                            updateSuggestions(currentLocalSuggestions.slice(0, localCount));
                                        } else {
                                            // No suggestions at all - remove skeletons and clear list
                                            removeSkeletons();
                                            updateSuggestions([]);
                                        }
                                    }
                                } else {
                                    console.log('[AI] Query changed during API call, ignoring results');
                                }
                            } catch (error) {
                                console.error('[AI] Error fetching AI suggestions:', error);
                                // Fall back to local suggestions on error
                                if (currentLocalSuggestions.length > 0) {
                                    const localCount = Math.min(currentLocalSuggestions.length, 10);
                                    updateSuggestions(currentLocalSuggestions.slice(0, localCount));
                                } else {
                                    removeSkeletons();
                                    updateSuggestions([]);
                                }
                            }
                        } catch (apiError) {
                            console.error('[AI] ✗ Error in API call:', apiError);
                            console.error('[AI] Stack trace:', apiError.stack);
                        }
                    })();
                } else {
                    console.log('[INPUT] Query length is', valueLower.length, '- not processing (should be >= 3)');
                }

                // Reset to default suggestions when field is empty
                if (!value.trim()) {
                    console.log('[INPUT] Field is empty, resetting to default suggestions');
                    // Clear AI suggestions tracking when field is empty
                    aiSuggestionsSet.clear();
                    updateSuggestions([
                        'hoka',
                        '13 in macbook air',
                        'Coffee machines for sale',
                        'taylor swift',
                        'coffee grinder',
                        'gmail'
                    ]);
                    return;
                }
                
                console.log('No suggestions updated, continuing...');
            });
        }

        const overlayScrollTarget = searchContainer;
        if (overlayScrollTarget) {
            const handleOverlayScrollWheel = (event) => {
                const maxScroll = overlayScrollTarget.scrollHeight - overlayScrollTarget.clientHeight;
                if (maxScroll <= 0) {
                    return;
                }

                const currentScroll = overlayScrollTarget.scrollTop;
                const nextScroll = currentScroll + event.deltaY;

                if ((event.deltaY < 0 && currentScroll <= 0) || (event.deltaY > 0 && currentScroll >= maxScroll)) {
                    return;
                }

                event.preventDefault();
                overlayScrollTarget.scrollTop = Math.min(Math.max(nextScroll, 0), maxScroll);
            };

            const previewArea = document.querySelector('.search-suggestions-preview');
            if (previewArea) {
                previewArea.addEventListener('wheel', handleOverlayScrollWheel, { passive: false });
            }

            overlayScrollTarget.addEventListener('wheel', handleOverlayScrollWheel, { passive: false });
        }


        const bottomPane = document.querySelector('.pane--bottom');
        if (bottomPane && topOverlay) {
            const handleOverlayPosition = () => {
                if (topOverlay.classList.contains('is-focused')) {
                    return;
                }
                bottomOverlay.style.top = `${Math.max(130, 130 + bottomPane.scrollTop)}px`;
            };
            bottomPane.addEventListener('scroll', handleOverlayPosition, { passive: true });
        }

        // Server selector dropdown functionality
        const serverSelector = document.getElementById('server-selector');
        if (serverSelector) {
            // Set initial value based on current provider
            serverSelector.value = AI_PROVIDER;
            
            serverSelector.addEventListener('change', (event) => {
                const newProvider = event.target.value;
                AI_PROVIDER = newProvider;
                console.log('[SERVER] Switched to:', AI_PROVIDER);
                
                // Save the provider selection to localStorage
                try {
                    localStorage.setItem('ai_provider', newProvider);
                    console.log('[SERVER] Saved provider preference:', newProvider);
                } catch (e) {
                    console.error('[SERVER] Could not save provider preference:', e);
                }
                
                // Clear cache when switching providers to force fresh results
                try {
                    const keysToRemove = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && (key.startsWith('ai_suggestions_') || key.startsWith('firefox_suggestions_'))) {
                            keysToRemove.push(key);
                        }
                    }
                    keysToRemove.forEach(key => localStorage.removeItem(key));
                    console.log('[SERVER] Cleared', keysToRemove.length, 'cached items');
                } catch (e) {
                    console.error('[SERVER] Could not clear cache:', e);
                }
            });
        }
    </script>
</body>
</html>
