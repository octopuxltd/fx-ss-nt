<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>New Tab</title>
    <link rel="stylesheet" href="suggestions.css">
    <style>
        /* Override hover for ut.html - only show selection state, not hover */
        .ut-page .search-suggestions-preview-item:hover:not(.is-selected),
        .ut-page .search-suggestions-preview-item:focus-within:not(.is-selected) {
            background-color: transparent;
        }

        /* Chair carrot should have hover style like regular suggestions */
        .ut-page .search-suggestions-preview-item.carrot--ad-marketplace:hover:not(.is-selected),
        .ut-page .search-suggestions-preview-item.carrot--ad-marketplace:focus-within:not(.is-selected) {
            background-color: #EBE7FF;
        }

        /* Chair carrot should have 4 rounded corners, not pill-shaped */
        .ut-page .search-suggestions-preview-item.carrot--ad-marketplace {
            border-radius: 10px;
        }
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: Arial, sans-serif;
            min-height: 100vh;
            background-image: url('bg.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
        }

        .pane {
            padding: 24px;
        }

        .search-container {
            flex: 1;
            overflow-y: hidden;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: var(--search-wrapper-offset, 240px);
            padding-bottom: 80px;
        }

        .top-overlay.is-focused .search-container {
            overflow-y: auto;
        }

        .top-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 10;
            background-color: rgba(255, 255, 255, 0);
            padding: 16px 24px;
            display: flex;
            justify-content: center;
            border-bottom: 1px solid rgba(0, 0, 0, 0);
            height: 130px;
            box-sizing: border-box;
            overflow: hidden;
            transition: background-color 0.6s ease, border-bottom-color 0.6s ease, height 0.6s ease, border-bottom-left-radius 0.6s ease, border-bottom-right-radius 0.6s ease;
            display: flex;
            flex-direction: column;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }

        .top-overlay.is-scrolled {
            background-color: rgba(255, 255, 255, 0.95);
            border-bottom-color: rgba(0, 0, 0, 0.05);
        }

        .top-overlay.is-focused {
            height: 85vh;
            background-color: rgba(255, 255, 255, 0.85);
            border-bottom-color: rgba(0, 0, 0, 0.05);
            border-bottom-left-radius: 50px;
            border-bottom-right-radius: 50px;
            overflow-y: auto;
        }

        .top-overlay.is-focused.winter-olympics {
            background-color: #E0F2FE; /* Pale blue */
        }

        .top-overlay.no-transition {
            transition: none !important;
        }

        .top-overlay.no-transition .search-wrapper,
        .top-overlay.no-transition .search-description,
        .top-overlay.no-transition .search-suggestions-preview {
            transition: none !important;
        }

        .firefox-logo {
            position: fixed;
            top: 32px;
            left: 34px;
            width: 48px;
            height: 48px;
            z-index: 11;
        }

        .close-button {
            position: fixed;
            top: 32px;
            right: 34px;
            width: 48px;
            height: 48px;
            z-index: 11;
            background: none;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .top-overlay.is-focused .close-button {
            opacity: 0.5;
            pointer-events: auto;
        }

        .close-button:hover {
            opacity: 1 !important;
        }

        .close-button svg {
            width: 48px;
            height: 48px;
            stroke: #1F2933;
            stroke-width: 1;
            transition: stroke 0.2s ease, stroke-width 0.2s ease;
        }

        .close-button:hover svg {
            stroke: #000000;
            stroke-width: 1.5;
        }

        .vpn-indicator {
            position: fixed;
            top: 32px;
            right: 34px;
            display: none;
            align-items: center;
            gap: 8px;
            z-index: 11;
            font-size: 14px;
            font-weight: 600;
            color: #1F2933;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .vpn-indicator.is-active {
            display: flex;
        }

        .top-overlay.is-focused .vpn-indicator {
            top: 88px;
        }

        .vpn-indicator-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #10b981;
            flex-shrink: 0;
        }

        .demo-searches {
            position: fixed;
            top: 170px;
            left: 34px;
            font-size: 13px;
            color: #FFFFFF;
            line-height: 1.6;
            pointer-events: auto;
            transition: color 0.3s ease;
            z-index: 11;
            width: 150px;
        }

        .top-overlay.is-focused .demo-searches {
            color: #6B7280;
        }

        .demo-searches-title {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .demo-searches ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .demo-searches li {
            margin: 2px 0;
        }

        .demo-searches .not-implemented {
            text-decoration: line-through;
        }

        .info-icon-wrapper {
            position: fixed;
            bottom: 24px;
            left: 34px;
            z-index: 11;
        }

        .info-icon-button {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .info-icon-button:hover {
            background-color: rgba(255, 255, 255, 1);
            transform: scale(1.05);
        }

        .info-icon-button svg {
            width: 18px;
            height: 18px;
            stroke: #374151;
        }

        .demo-searches-card {
            position: absolute;
            bottom: 40px;
            left: 0;
            background-color: rgba(255, 255, 255, 0.98);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            min-width: 200px;
            max-width: 300px;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            z-index: 12;
        }

        .info-icon-wrapper.is-open .demo-searches-card {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        .demo-searches-earlier {
            font-size: 13px;
            color: #1F2933;
            line-height: 1.6;
        }

        .top-overlay.is-focused .demo-searches-earlier {
            color: #1F2933;
        }

        .demo-searches-earlier .demo-searches-title {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .demo-searches-earlier ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .demo-searches-earlier li {
            margin: 2px 0;
        }

        .search-wrapper {
            position: fixed;
            top: 32px;
            left: 50%;
            transform: translateX(-50%);
            width: 56%;
            margin: 0;
            transition: width 0.35s ease-in-out;
            border: 1px solid transparent;
            border-radius: 28px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            background-color: rgba(255, 255, 255, 0.7);
            box-shadow: 0 12px 12px rgba(15, 23, 42, 0.12);
        }

        .search-wrapper::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 28px;
            padding: 2px;
            background: conic-gradient(from 0deg, #945AF2 0%, #F37E49 71%, #945AF2 100%);
            -webkit-mask: 
                linear-gradient(#fff 0 0) content-box, 
                linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.35s ease-in-out;
        }

        .search-wrapper:focus-within::before {
            opacity: 1;
        }

        .search-wrapper.expanded {
            width: 70%;
        }

        .search-wrapper:focus-within {
            border: 1px solid transparent;
            background-color: rgba(255, 255, 255, 0.99);
        }

        .top-overlay.is-scrolled .search-wrapper,
        .top-overlay.is-focused .search-wrapper {
            border-color: rgba(15, 23, 42, 0.12);
        }

        .search-input-shell {
            position: relative;
            padding: 18px 18px 5px; padding-right: 50px;
            padding-left: 84px;
        }

        .search-input-shell {
            padding-right: 50px;
        }

        .search-clear-button {
            position: absolute;
            right: 18px;
            top: calc(50% + 7px);
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.5;
            transition: opacity 0.2s ease;
            z-index: 1;
        }

        .search-clear-button:hover {
            opacity: 1;
        }

        .search-clear-button svg {
            width: 16px;
            height: 16px;
            stroke: #1F2933;
        }

        .search-dropdown-button {
            position: absolute;
            left: 10px;
            top: calc(50% + 7px);
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            padding: 6px 8px;
            border-radius: 999px;
            background-color: #FFFFFF;
            transition: background-color 0.2s ease;
            z-index: 0;
        }
        
        /* When panel is open (is-focused), make the button grey */
        .top-overlay.is-focused .search-dropdown-button {
            background-color: #F3F4F6;
        }

        .circle-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            margin-right: 2px;
            border-radius: 50%;
            background-color: #FFFFFF;
            transition: background-color 0.2s ease;
        }
        
        /* When panel is open (is-focused), make the circle icon grey */
        .top-overlay.is-focused .circle-icon {
            background-color: #F3F4F6;
        }

        .circle-icon__image {
            width: 16px;
            height: 16px;
        }

        .chevron {
            width: 12px;
            height: 12px;
            margin-left: 2px;
            position: relative;
            top: 1px;
        }

        .search-box {
            width: 100%;
            padding: 0;
            border: none;
            background: transparent;
            font-size: 16px;
            color: #000000;
            position: relative;
            z-index: 1;
        }

        .search-box::placeholder {
            color: #000000;
        }

        .top-overlay.is-focused .search-box::placeholder {
            color: rgba(0, 0, 0, 0.5);
        }

        .search-box:focus {
            outline: none;
        }

        .search-description {
            width: 100%;
            margin: 0 auto;
            padding: 0 0 32px;
        }

        .top-overlay.is-focused .search-description {
            width: 100%;
        }

        .overlay-product-grid {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 16px;
            width: 70%;
            max-width: 1200px;
            margin: 0 auto;
            opacity: 0;
            transition: opacity 0.6s ease;
        }

        .top-overlay.is-focused .overlay-product-grid {
            opacity: 1;
        }

        .overlay-product-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .overlay-product-heading {
            margin: 0;
            font-size: 12px;
            font-weight: 400;
            letter-spacing: normal;
            color: #6B7280;
            opacity: 0;
            transition: opacity 0.6s ease;
        }

        .top-overlay.is-focused .overlay-product-heading {
            opacity: 1;
        }

        .overlay-product-card {
            background: #FFFFFF;
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: row;
            box-shadow: 0 4px 12px rgba(15, 23, 42, 0.12);
            text-decoration: none;
            color: inherit;
            height: 90px;
            transition: background-color 0.2s ease, opacity 0.6s ease;
            opacity: 0;
        }

        .top-overlay.is-focused .overlay-product-card {
            opacity: 1;
        }

        .overlay-product-card img:not(.overlay-product-favicon):not(.overlay-product-meta-favicon) {
            width: 90px;
            height: 90px;
            object-fit: cover;
            flex-shrink: 0;
        }

        .overlay-product-card--article img {
            width: 100% !important;
            height: 160px !important;
            object-fit: cover;
        }

        .overlay-product-card-body {
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            justify-content: center;
        }

        .overlay-product-title {
            font-size: 16px;
            font-weight: 600;
            margin: 0;
            color: #1F2933;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .overlay-product-meta {
            font-size: 12px;
            margin: 0;
            color: rgba(15, 23, 42, 0.6);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .overlay-product-meta-favicon {
            width: 16px !important;
            height: 16px !important;
            flex-shrink: 0;
            object-fit: contain;
            max-width: 16px !important;
            max-height: 16px !important;
        }

        .overlay-product-card:hover,
        .overlay-product-card:focus {
            background-color: #F3F4F6;
        }

        /* Winter Olympics card hover colors */
        .olympics-card-blue:hover {
            background-color: #0085C7 !important;
        }

        .olympics-card-blue:hover .overlay-product-title,
        .olympics-card-blue:hover div {
            color: #FFFFFF !important;
        }

        .olympics-card-black:hover {
            background-color: #000000 !important;
        }

        .olympics-card-black:hover .overlay-product-title,
        .olympics-card-black:hover div {
            color: #FFFFFF !important;
        }

        .olympics-card-red:hover {
            background-color: #DF0024 !important;
        }

        .olympics-card-red:hover .overlay-product-title,
        .olympics-card-red:hover div {
            color: #FFFFFF !important;
        }

        .olympics-card-yellow:hover {
            background-color: #F4C300 !important;
        }

        .olympics-card-yellow:hover .overlay-product-title,
        .olympics-card-yellow:hover div {
            color: #000000 !important;
        }

        .overlay-product-card--article {
            flex-direction: column;
            height: 290px;
        }

        .overlay-product-card--article .overlay-product-card-body {
            padding: 16px;
            flex-grow: 1;
        }

        .overlay-product-card--article .overlay-product-title {
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 8px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .overlay-product-card--article .overlay-product-meta {
            font-size: 12px;
            color: #777;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .overlay-product-card--article .overlay-product-meta-favicon {
            width: 16px !important;
            height: 16px !important;
            flex-shrink: 0;
            object-fit: contain;
            max-width: 16px !important;
            max-height: 16px !important;
        }

        .overlay-product-card--article:hover {
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        }

        .overlay-product-card--article:hover .overlay-product-title {
            color: #1E90FF;
        }

        .overlay-product-card--article:hover,
        .overlay-product-card--article:focus {
            background-color: #FFFFFF;
        }





        .pane--bottom {
            min-height: 100vh;
            background: transparent;
            color: #4a3419;
            overflow-y: auto;
            padding: 0;
            position: relative;
        }

        .bottom-overlay {
            position: fixed;
            top: 130px;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0);
            pointer-events: none;
            z-index: 5;
            margin-top: -50px;
            transition: top 0.6s ease, background-color 0.6s ease;
        }

        .bottom-overlay.no-transition {
            transition: none !important;
        }

        .bottom-content {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 32px;
            padding: 24px;
            padding-top: calc(130px + 24px);
        }

        .quick-tiles {
            width: 70%;
            max-width: 1200px;
            display: flex;
            justify-content: space-between;
            gap: 16px;
        }

        .quick-tiles__tile {
            flex: 0 0 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 6px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(6px);
            padding: 12px 8px;
            text-decoration: none;
            color: inherit;
            transition: background-color 0.2s ease;
        }

        .quick-tiles__tile:hover {
            background: rgba(255, 255, 255, 0.7);
        }

        .quick-tiles__favicon {
            width: 36px;
            height: 36px;
            object-fit: contain;
        }

        .quick-tiles__label {
            font-size: 11px;
            color: rgba(31, 41, 51, 0.7);
            text-align: center;
            font-weight: 500;
        }

        .heading {
            font-size: 16px;
            font-weight: bold;
            text-align: left;
            margin: 0;
            padding-top: 16px;
            width: 70%;
            max-width: 1200px;
            color: #FFFFFF;
        }

        .articles-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 26px;
            width: 70%;
            max-width: 1200px;
            transition: opacity 0.6s ease;
            opacity: 1;
        }

        .top-overlay.is-focused ~ .bottom-content .articles-grid {
            opacity: 0.5;
        }

        .card {
            background-color: #FFFFFF;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 275px;
            transition: box-shadow 0.15s ease-in-out;
            position: relative;
        }

        .card h2 {
            margin: 16px;
            font-size: 18px;
            text-align: left;
            color: #333;
            font-weight: 500;
            flex-grow: 1;
        }

        .card p {
            margin-left: 16px;
            margin-bottom: 16px;
            font-size: 12px;
        }

        .card .sponsored-label {
            position: absolute;
            bottom: 12px;
            right: 16px;
            font-size: 9px;
            color: #64748B;
            font-weight: 500;
            letter-spacing: 0.5px;
            margin: 0;
        }

        .card:hover {
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        }

        .card:hover h2 {
            color: #1E90FF;
        }

        .card--pinned-flash {
            border: 5px solid #D41CC1 !important;
        }

        .card--world-clock {
            position: relative;
        }

        .card--world-clock .card-controls,
        .card--stock .card-controls,
        .card--sports .card-controls,
        .card--weather .card-controls {
            position: absolute;
            top: 8px;
            right: 8px;
            display: none;
            flex-direction: row;
            align-items: center;
            gap: 4px;
            z-index: 10;
        }

        .card--world-clock:hover .card-controls,
        .card--stock:hover .card-controls,
        .card--sports:hover .card-controls,
        .card--weather:hover .card-controls {
            display: flex;
        }

        .card-control-button {
            width: 24px;
            height: 24px;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            padding: 0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s ease;
        }

        .card-control-button:hover {
            background: rgba(255, 255, 255, 1);
        }

        .card-control-button svg {
            width: 16px;
            height: 16px;
        }

        a.card {
            text-decoration: none;
            color: inherit;
            display: block;
            height: 100%;
        }

        .image-placeholder {
            width: 100%;
            height: 160px;
            background-color: #CCC;
        }

        p {
            line-height: 1.6;
            margin-bottom: 16px;
        }

        .no-transition {
            transition: none !important;
        }

        .search-background-bottom-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            height: 54px;
            border: none;
            background-color: #EBE7FF;
            cursor: pointer;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out, background-color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .top-overlay.is-focused .search-background-bottom-overlay {
            opacity: 1;
            pointer-events: auto;
        }

        .search-background-bottom-overlay svg {
            display: block;
        }

        .search-background-bottom-overlay .chevron-shallow {
            opacity: 1;
            transition: opacity 0.2s ease-in-out;
        }

        .search-background-bottom-overlay .chevron-steep {
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        .search-background-bottom-overlay:hover {
            background-color: rgba(255, 255, 255, 1);
            opacity: 1;
        }

        .search-background-bottom-overlay:hover .chevron-shallow {
            opacity: 0;
        }

        .search-background-bottom-overlay:hover .chevron-steep {
            opacity: 1;
            stroke: #374151;
        }

        .debug-buttons {
            position: fixed;
            top: 32px;
            right: 24px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 2px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .top-overlay.is-focused .debug-buttons {
            opacity: 1;
            pointer-events: auto;
        }

        .debug-buttons-bottom {
            position: absolute;
            bottom: 62px;
            right: 24px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 2px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .top-overlay.is-focused .debug-buttons-bottom {
            opacity: 1;
            pointer-events: auto;
        }

        .debug-button {
            width: auto;
            height: auto;
            padding: 4px 8px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            background-color: rgba(255, 255, 255, 0.9);
            color: #374151;
            font-size: 8px;
            font-weight: 400;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            transition: background-color 0.15s ease, border-color 0.15s ease;
            white-space: nowrap;
            text-align: left;
        }

        .debug-button:hover {
            background-color: rgba(229, 231, 235, 0.95);
            border-color: rgba(0, 0, 0, 0.2);
        }

        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }

        .phase-toggle {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 10px;
        }

        .phase-toggle__link {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 1px 6px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.4);
            background: rgba(15, 23, 42, 0.4);
            color: #FFFFFF;
            font-size: 11px;
            font-weight: 600;
            text-decoration: none;
            transition: background 0.2s ease, border-color 0.2s ease;
        }

        .phase-toggle-heading {
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 6px;
            width: 100%;
        }

        .phase-toggle__link:hover,
        .phase-toggle__link:focus {
            background: rgba(15, 23, 42, 0.6);
            border-color: rgba(255, 255, 255, 0.7);
            outline: none;
        }

        .phase-toggle__link.is-active {
            background: rgba(15, 23, 42, 0.8);
            border-color: rgba(255, 255, 255, 0.9);
        }

        .phase-toggle__label {
            display: none;
        }

        .phase-toggle__link.is-active .phase-toggle__label {
            display: inline;
        }

        .phase-toggle__number {
            margin-left: 0;
        }

        .phase-toggle__link.is-active .phase-toggle__number {
            margin-left: 4px;
        }

        .local-carrot-row {
            display: none;
            width: 100%;
            padding: 0 8px;
            margin-top: 12px;
        }

        .local-carrot-row.is-visible {
            display: flex;
        }

        .local-carrot-grid {
            display: flex;
            gap: 12px;
            list-style: none;
            padding: 0;
            margin: 0;
            width: 100%;
        }

        .local-carrot-grid .search-suggestions-preview-item {
            flex: 1 1 0;
        }

        .search-suggestions-preview-column-container.local-horizontal .search-suggestions-preview-list:first-child {
            flex: 0 0 100%;
        }

        .search-suggestions-preview-column-container.local-horizontal .search-suggestions-preview-list:last-child {
            display: none;
        }
    </style>
    <script src="product-sections/product-history.js"></script>
    <script src="product-sections/product-bookmarks.js"></script>
    <script src="product-sections/product-open-tabs.js"></script>
    <script src="product-sections/product-articles.js"></script>
    <script src="product-content.js"></script>
    <script src="carrot-templates.js"></script>
    <script src="suggestion-words.js"></script>
    <script src="image-preload.js"></script>
    <!-- Load API configuration (config.js is gitignored) -->
    <script src="config.js" onerror="console.warn('config.js not found. Using example config. Please create config.js from config.example.js'); window.API_CONFIG = window.API_CONFIG || { OPENROUTER_API_KEY: '', PEXELS_API_KEY: '' };"></script>
    <script>
        // OpenRouter API Configuration
        const OPENROUTER_API_KEY = window.API_CONFIG?.OPENROUTER_API_KEY || '';
        const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
        
        // Debounce timer for API calls
        let apiCallTimer = null;
        let lastApiQuery = '';
        
        // Track which suggestions are from AI (for icon assignment)
        let aiSuggestionsSet = new Set();
        
        // LocalStorage cache functions
        function getCacheKey(query) {
            return `ai_suggestions_${query.toLowerCase().trim()}`;
        }
        
        function getCachedSuggestions(query) {
            try {
                const cacheKey = getCacheKey(query);
                const cached = localStorage.getItem(cacheKey);
                if (cached) {
                    const parsed = JSON.parse(cached);
                    // Check if cache is still valid (24 hours)
                    const cacheAge = Date.now() - parsed.timestamp;
                    const maxAge = 24 * 60 * 60 * 1000; // 24 hours
                    if (cacheAge < maxAge) {
                        console.log('[API] Found cached suggestions:', parsed.suggestions);
                        // Filter cached suggestions to only include word-start matches
                        const queryLower = query.toLowerCase();
                        const filtered = parsed.suggestions.filter(suggestion => {
                            const suggestionLower = suggestion.toLowerCase();
                            // Check if suggestion starts with query
                            if (suggestionLower.startsWith(queryLower)) {
                                return true;
                            }
                            // Check if any word in the suggestion starts with the query
                            const words = suggestionLower.split(/\s+/);
                            return words.some(word => word.startsWith(queryLower));
                        });
                        return filtered.length > 0 ? filtered : null;
                    } else {
                        console.log('[API] Cache expired, removing old cache');
                        localStorage.removeItem(cacheKey);
                    }
                }
            } catch (error) {
                console.error('[API] Error reading from cache:', error);
            }
            return null;
        }
        
        function cacheSuggestions(query, suggestions) {
            try {
                const cacheKey = getCacheKey(query);
                const cacheData = {
                    suggestions: suggestions,
                    timestamp: Date.now()
                };
                localStorage.setItem(cacheKey, JSON.stringify(cacheData));
                console.log('[API] Cached suggestions for:', query);
            } catch (error) {
                console.error('[API] Error caching suggestions:', error);
                // localStorage might be full, try to clear old entries
                try {
                    const keysToRemove = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith('ai_suggestions_')) {
                            keysToRemove.push(key);
                        }
                    }
                    // Remove oldest 10 entries if cache is full
                    if (keysToRemove.length > 50) {
                        keysToRemove.slice(0, 10).forEach(key => localStorage.removeItem(key));
                        // Retry caching
                        localStorage.setItem(cacheKey, JSON.stringify(cacheData));
                    }
                } catch (e) {
                    console.error('[API] Could not clear cache:', e);
                }
            }
        }
        
        // Helper function to make a single request attempt
        async function makeRequestAttempt(query, attemptNumber, delayMs = 0) {
            if (delayMs > 0) {
                await new Promise(resolve => setTimeout(resolve, delayMs));
            }

            const startTime = Date.now();
            console.log(`[API] Making request attempt ${attemptNumber}...`);
            
            if (!OPENROUTER_API_KEY) {
                console.warn('[API] OpenRouter API key not set');
                throw new Error('API key not set');
            }
            
            const requestBody = {
                model: 'anthropic/claude-3-haiku',
                messages: [
                    {
                        role: 'system',
                        content: 'You are a search suggestion generator. Generate 10 popular search queries where at least one word starts with the user\'s query characters. Prioritize nouns - names of famous things like celebrities, bands, movies, places, politicians, news topics, or common questions (how to do things, why something happens). For example, if the user types "abc", return suggestions like "abc news", "abc store", "abc company" where words start with "abc". The query characters need not form a complete word - they are the beginning of words. Return ONLY a JSON array of strings, sorted by popularity (most popular first). No explanations, just the array.'
                    },
                    {
                        role: 'user',
                        content: `Generate 10 popular search suggestions where at least one word starts with: "${query}". Prioritize nouns - famous people, places, movies, bands, news topics, or common questions (how to, why).`
                    }
                ],
                temperature: 0.7,
                max_tokens: 200
            };
            
            const response = await fetch(OPENROUTER_API_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
                    'HTTP-Referer': window.location.origin,
                    'X-Title': 'Search Suggestions'
                },
                body: JSON.stringify(requestBody)
            });
            
            const requestDuration = Date.now() - startTime;
            console.log(`[API] Attempt ${attemptNumber} response received:`, {
                status: response.status,
                duration: `${requestDuration}ms`
            });
            
            if (!response.ok) {
                let errorText;
                try {
                    errorText = await response.text();
                } catch (e) {
                    errorText = 'Could not read error response';
                }
                
                const error = new Error(`API error: ${response.status} - ${errorText}`);
                error.hasResponse = true;
                throw error;
            }
            
            const data = await response.json();
            const content = data.choices[0]?.message?.content?.trim();
            
            if (!content) {
                const error = new Error('Empty content in response');
                error.hasResponse = true;
                throw error;
            }
            
            // Parse JSON array from response
            let suggestions = [];
            try {
                const jsonMatch = content.match(/\[.*\]/s);
                if (jsonMatch) {
                    suggestions = JSON.parse(jsonMatch[0]);
                } else {
                    suggestions = content.split('\n')
                        .map(line => line.trim().replace(/^[-•\d.\s"']+|[-•\d.\s"']+$/g, ''))
                        .filter(line => line.length > 0)
                        .slice(0, 10);
                }
            } catch (parseError) {
                const quotedMatches = content.match(/"([^"]+)"/g);
                if (quotedMatches) {
                    suggestions = quotedMatches.map(m => m.replace(/"/g, '')).slice(0, 10);
                }
            }
            
            const finalSuggestions = suggestions.filter(s => s && s.length > 0).slice(0, 10);
            console.log(`[API] Attempt ${attemptNumber} succeeded with ${finalSuggestions.length} suggestions`);
            
            if (finalSuggestions.length === 0) {
                const error = new Error('No suggestions parsed');
                error.hasResponse = true;
                throw error;
            }
            
            return finalSuggestions;
        }

        async function fetchAISuggestions(query, retryCount = 0) {
            const maxRetries = 2; // Retry up to 2 times (3 total attempts)
            console.log('[API] Starting fetchAISuggestions for query:', query, retryCount > 0 ? `(retry ${retryCount}/${maxRetries})` : '');
            
            // Check cache first (only on first attempt, not retries)
            if (retryCount === 0) {
                const cached = getCachedSuggestions(query);
                if (cached && cached.length > 0) {
                    console.log('[API] Returning cached suggestions');
                    return cached;
                }
            }
            
            let resolveFirst = null;
            let rejectFirst = null;
            const firstResponsePromise = new Promise((resolve, reject) => {
                resolveFirst = resolve;
                rejectFirst = reject;
            });

            const errors = [];
            const totalAttempts = maxRetries + 1;
            let completed = false;
            let finishedAttempts = 0;

            function handleAttemptResult(attemptNumber, result, error) {
                if (completed) {
                    return;
                }

                if (error) {
                    finishedAttempts++;
                    console.log(`[API] Attempt ${attemptNumber} failed:`, error.message);
                    errors.push({ attempt: attemptNumber, error });

                    if (finishedAttempts === totalAttempts) {
                        completed = true;
                        rejectFirst(new Error('All attempts failed'));
                    }
                    return;
                }

                completed = true;
                resolveFirst({ result, attempt: attemptNumber });
            }

            // Attempt 1 immediately, then additional attempts after 2s and 4s
            makeRequestAttempt(query, 1, 0)
                .then(result => handleAttemptResult(1, result, null))
                .catch(error => handleAttemptResult(1, null, error));

            setTimeout(() => {
                if (completed) {
                    return;
                }
                makeRequestAttempt(query, 2, 0)
                    .then(result => handleAttemptResult(2, result, null))
                    .catch(error => handleAttemptResult(2, null, error));
            }, 2000);

            setTimeout(() => {
                if (completed) {
                    return;
                }
                makeRequestAttempt(query, 3, 0)
                    .then(result => handleAttemptResult(3, result, null))
                    .catch(error => handleAttemptResult(3, null, error));
            }, 4000);

            try {
                const { result } = await firstResponsePromise;
                if (result.length > 0) {
                    cacheSuggestions(query, result);
                }
                return result;
            } catch (error) {
                console.error('[API] All attempts failed. Errors:', errors);
                return [];
            }
        }
    </script>
    <script>
        // Set phase number for image preloader
        window.currentPhase = 5;
        if (typeof preloadCarrotImages === 'function') {
            preloadCarrotImages(5);
        }
    </script>
</head>
<body class="ut-page">
    <section class="pane pane--bottom">
        <div class="bottom-overlay" aria-hidden="true"></div>
        <div class="top-overlay">
            <img src="icons/Fx-Browser-icon-fullColor-64.png" alt="Firefox" class="firefox-logo">
            <button class="close-button" type="button" aria-label="Close search panel">
                <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>
            <div class="vpn-indicator" id="vpn-indicator">
                <span class="vpn-indicator-dot"></span>
                <span>VPN</span>
            </div>
            <div class="info-icon-wrapper">
                <button class="info-icon-button" type="button" aria-label="Show demo searches">
                    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/>
                        <path d="M12 16V12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        <circle cx="12" cy="8" r="1" fill="currentColor"/>
                    </svg>
                </button>
                <div class="demo-searches-card">
                    <div class="demo-searches-earlier">
                        <ul>
                            <li>• fox wiki</li>
                            <li>• sneakers</li>
                            <li>• chair / ramen / sushi</li>
                            <li>• uber stock</li>
                            <li>• lakers game</li>
                            <li>• AC8170</li>
                            <li>• coffee shops</li>
                            <li>• weather</li>
                            <li>• time rome</li>
                            <li>• $100 in euros</li>
                            <li>• hello in italian</li>
                            <li>• renewable energy</li>
                            <li>• winter olympics</li>
                            <li>• vpn</li>
                            <li>• MDN</li>
                            <li>• youtube</li>
                            <li>• happy emoji</li>
                        </ul>
                        <button type="button" class="clear-history-button" style="margin-top: 12px; padding: 6px 12px; background-color: #F3F4F6; border: 1px solid #D1D5DB; border-radius: 6px; cursor: pointer; font-size: 12px; color: #374151; transition: background-color 0.2s ease;">Clear search history</button>
                    </div>
                </div>
            </div>
            <!-- DEBUG BUTTONS - DO NOT DELETE! Uncomment for testing/development -->
            <!--
            <div class="debug-buttons">
                <button class="debug-button" type="button">1. No enriched content</button>
                <button class="debug-button" type="button">2. Local recommendations</button>
                <button class="debug-button" type="button">3. Flights (AC 8170)</button>
                <button class="debug-button" type="button">4. Wikipedia</button>
                <button class="debug-button" type="button">5. Weather</button>
                <button class="debug-button" type="button">6. Sports</button>
                <button class="debug-button" type="button">7. Stocks</button>
                <button class="debug-button" type="button">8. World clock</button>
                </div>
            <div class="debug-buttons-bottom">
                <button class="debug-button" type="button">A</button>
                <button class="debug-button" type="button">B</button>
                <button class="debug-button" type="button">C</button>
                <button class="debug-button" type="button">D</button>
                <button class="debug-button" type="button">E</button>
                </div>
            -->
            <button class="search-background-bottom-overlay" type="button">
                <span class="visually-hidden">Collapse search overlay</span>
                <svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                    <path class="chevron-shallow" d="M4 20L16 15L28 20" stroke="#6B7280" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path class="chevron-steep" d="M6 20L16 12L26 20" stroke="#6B7280" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>
            <div class="search-container">
                <div class="search-wrapper">
                    <div class="search-input-shell">
                        <div class="search-dropdown-button">
                            <span class="circle-icon">
                                <img src="icons/Google.svg" alt="Search options" class="circle-icon__image">
                            </span>
                            <img src="icons/chevron.svg" alt="Expand" class="chevron">
            </div>
                        <input type="text" class="search-box" placeholder="Search or start browsing">
                        <button type="button" class="search-clear-button" aria-label="Clear search" style="display: none;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </button>
                </div>
                    <div class="search-suggestions-preview" aria-hidden="true">
                        <div class="search-suggestions-divider"></div>
                        <div class="local-carrot-row" aria-hidden="true"></div>
                        <div class="search-suggestions-preview-column-container expand-left">
                        <ul class="search-suggestions-preview-list">
                            <li class="search-suggestions-preview-item">
                                <img src="icons/clock.svg" alt="" aria-hidden="true" class="suggestion-icon">
                                <span class="label">hoka</span>
                            </li>
                            <li class="search-suggestions-preview-item">
                                <img src="icons/clock.svg" alt="" aria-hidden="true" class="suggestion-icon">
                                <span class="label">macbook</span>
                            </li>
                            <li class="search-suggestions-preview-item">
                                <img src="icons/clock.svg" alt="" aria-hidden="true" class="suggestion-icon">
                                <span class="label">13 in macbook air</span>
                            </li>
                            <li class="search-suggestions-preview-item">
                                <img src="icons/clock.svg" alt="" aria-hidden="true" class="suggestion-icon">
                                <span class="label">Coffee machines for sale</span>
                            </li>
                            <li class="search-suggestions-preview-item">
                                <img src="icons/clock.svg" alt="" aria-hidden="true" class="suggestion-icon">
                                <span class="label">taylor swift</span>
                            </li>
                            <li class="search-suggestions-preview-item">
                                <img src="icons/clock.svg" alt="" aria-hidden="true" class="suggestion-icon">
                                <span class="label">coffee grinder</span>
                            </li>
                            <li class="search-suggestions-preview-item">
                                <img src="icons/clock.svg" alt="" aria-hidden="true" class="suggestion-icon">
                                <span class="label">gmail</span>
                            </li>
                        </ul>
                            <ul class="search-suggestions-preview-list">
                                <li class="search-suggestions-preview-item carrot">
                                    <div class="carrot-tile" aria-hidden="true"></div>
                                    <div class="carrot-lines">
                                        <p class="carrot-line">Departure <strong>9:21pm</strong> Chicago (CHI)</p>
                                        <p class="carrot-line">Arrival <strong>11:42am</strong> Vancouver (VYR)</p>
                                        <p class="carrot-line carrot-line--meta"><span class="carrot-line green-text">In flight</span> · Today · AC 8170</p>
            </div>
                                </li>
                                <li class="search-suggestions-preview-item carrot">
                                    <div class="carrot-tile" aria-hidden="true"></div>
                                    <div class="carrot-lines">
                                        <p class="carrot-line">Departure <strong>7:05am</strong> New York (JFK)</p>
                                        <p class="carrot-line">Arrival <strong>9:18am</strong> Toronto (YYZ)</p>
                                        <p class="carrot-line carrot-line--meta">Boarding · Thu, June 5 · DL 4732</p>
        </div>
                                </li>
                                <li class="search-suggestions-preview-item carrot">
                                    <div class="carrot-tile" aria-hidden="true"></div>
                                    <div class="carrot-lines">
                                        <p class="carrot-line">Departure <strong>2:45pm</strong> Los Angeles (LAX)</p>
                                        <p class="carrot-line">Arrival <strong>6:10pm</strong> Seattle (SEA)</p>
                                        <p class="carrot-line carrot-line--meta">Scheduled · Fri, June 6 · AS 124</p>
                        </div>
                                </li>
                            </ul>
                    </div>
                </div>
                </div>
                <div class="search-description">
                    <div class="overlay-product-grid" data-product-grid data-product-sections="history,openTabs,bookmarks,articles"></div>
                </div>
            </div>
        </div>
        <div class="bottom-content">
                <div class="quick-tiles" aria-hidden="true">
                    <a href="https://www.google.com" target="_blank" class="quick-tiles__tile">
                        <img src="favicons/Google.svg" alt="" class="quick-tiles__favicon">
                        <span class="quick-tiles__label">Google</span>
                    </a>
                    <a href="https://www.youtube.com" target="_blank" class="quick-tiles__tile">
                        <img src="favicons/YouTube.svg" alt="" class="quick-tiles__favicon">
                        <span class="quick-tiles__label">YouTube</span>
                    </a>
                    <a href="https://www.instagram.com" target="_blank" class="quick-tiles__tile">
                        <img src="favicons/Instagram.svg" alt="" class="quick-tiles__favicon">
                        <span class="quick-tiles__label">Instagram</span>
                    </a>
                    <a href="https://www.reddit.com" target="_blank" class="quick-tiles__tile">
                        <img src="favicons/Reddit.svg" alt="" class="quick-tiles__favicon">
                        <span class="quick-tiles__label">Reddit</span>
                    </a>
                    <a href="https://twitter.com" target="_blank" class="quick-tiles__tile">
                        <img src="favicons/Twitter.svg" alt="" class="quick-tiles__favicon">
                        <span class="quick-tiles__label">Twitter</span>
                    </a>
                    <a href="https://www.wikipedia.org" target="_blank" class="quick-tiles__tile">
                        <img src="favicons/Wikipedia.svg" alt="" class="quick-tiles__favicon">
                        <span class="quick-tiles__label">Wikipedia</span>
                    </a>
                    <a href="https://www.facebook.com" target="_blank" class="quick-tiles__tile">
                        <img src="favicons/Facebook.svg" alt="" class="quick-tiles__favicon">
                        <span class="quick-tiles__label">Facebook</span>
                    </a>
                    <a href="https://slack.com" target="_blank" class="quick-tiles__tile">
                        <img src="favicons/Slack.svg" alt="" class="quick-tiles__favicon">
                        <span class="quick-tiles__label">Slack</span>
                    </a>
                </div>
                <h1 class="heading">Thought-provoking stories</h1>
                <div class="articles-grid">
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>The Surprising Science Behind Lightning</h2>
                    <p>SELF G</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>Ten People Go on Trial in Paris</h2>
                    <p>The Guardian</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>Can Dogs Sense Ghosts?</h2>
                    <p>Popular Science</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>11 One-Pot Gut-Healthy Dinners</h2>
                    <p>Eating Well</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>The Dark Side of Mirrors in Space</h2>
                    <p>Nautilus</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>UK Regional Airline Suspends Ops</h2>
                    <p>Sky</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>The Internet Is Going to Break Again</h2>
                    <p>Sky</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>The 1 Surprising Snack People Eat</h2>
                    <p>Eating Well</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>Reclaiming 72 Hours a Week</h2>
                    <p>Sky</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>Hidden Dangers in Fast Food</h2>
                    <p>Health Digest</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>Exploring Virtual Reality</h2>
                    <p>Tech Today</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>Unveiling the Quantum Age</h2>
                    <p>Scientific Insights</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>Breakthroughs in Renewable Energy</h2>
                    <p>Eco World</p>
                    <p class="sponsored-label">Sponsored</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>Astronomy's New Frontiers</h2>
                    <p>Space Observer</p>
                </a>
                <a href="#" class="card">
                    <div class="image-placeholder"></div>
                    <h2>Innovative Designs in Architecture</h2>
                    <p>Modern Home</p>
                </a>
            </div>
        </div>
    </section>
    <script>
        const apiKey = window.API_CONFIG?.PEXELS_API_KEY || '';
        const keywords = [
            'UTI', 'trial Paris', 'ghosts',
            'healthy dinner', 'mirrors space', 'UK airline',
            'internet', 'snack', 'productivity',
            'fast food', 'virtual reality', 'quantum physics',
            'renewable energy', 'astronomy', 'architecture'
        ];

        // Store original product grid content for restoration
        let originalProductGridContent = null;
        let originalProductGridSections = null;

        const renderOverlayProductGrid = () => {
            const container = document.querySelector('[data-product-grid]');
            if (!container || typeof productContent?.renderInto !== 'function') {
                return;
            }

            const sectionAttr = container.getAttribute('data-product-sections');
            const sectionKeys = sectionAttr ? sectionAttr.split(',').map((section) => section.trim()).filter(Boolean) : undefined;

            // Store original content if not already stored
            if (!originalProductGridSections) {
                originalProductGridSections = sectionKeys;
            }

            productContent.renderInto(container, sectionKeys);
        };

        // Function to render Winter Olympics schedule
        const renderWinterOlympicsSchedule = () => {
            const container = document.querySelector('[data-product-grid]');
            if (!container) return;

            // Store original content if not already stored
            if (!originalProductGridContent && container.innerHTML.trim()) {
                originalProductGridContent = container.innerHTML;
            }

            // Add class to suggestions container to make it half height
            const suggestionsPreview = document.querySelector('.search-suggestions-preview');
            if (suggestionsPreview) {
                suggestionsPreview.classList.add('winter-olympics-active');
            }

            container.innerHTML = `
                <div class="winter-olympics-schedule" style="grid-column: 1 / -1; display: flex; flex-direction: column; gap: 8px;">
                    <div class="overlay-product-column" style="grid-column: 1 / -1;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px;">
                            <div>
                                <p style="margin: 0 0 4px 0; font-size: 32px; font-weight: 500; color: #1F2933;">Winter Olympics 2026</p>
                                <p style="margin: 0; font-size: 12px; color: #6B7280;">Milan-Cortina, Italy</p>
                            </div>
                            <svg width="320" height="160" viewBox="0 0 120 60" xmlns="http://www.w3.org/2000/svg" style="flex-shrink: 0;">
                                <!-- Olympic Rings - Interlocking circles -->
                                <!-- Top row: Blue, Black, Red -->
                                <circle cx="25" cy="20" r="9" fill="none" stroke="#0085C7" stroke-width="2.5"/>
                                <circle cx="50" cy="20" r="9" fill="none" stroke="#000000" stroke-width="2.5"/>
                                <circle cx="75" cy="20" r="9" fill="none" stroke="#DF0024" stroke-width="2.5"/>
                                <!-- Bottom row: Yellow, Green -->
                                <circle cx="37.5" cy="35" r="9" fill="none" stroke="#F4C300" stroke-width="2.5"/>
                                <circle cx="62.5" cy="35" r="9" fill="none" stroke="#009F3D" stroke-width="2.5"/>
                            </svg>
                        </div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px;">
                        <div class="overlay-product-card olympics-card-blue" style="flex-direction: column; height: auto; padding: 16px;">
                            <div style="font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: #6B7280; margin-bottom: 8px;">Today</div>
                            <div class="overlay-product-title" style="font-size: 16px; font-weight: 500; margin-bottom: 4px; color: #1F2933;">Alpine Skiing</div>
                            <div style="font-size: 13px; color: #6B7280;">Men's Downhill • 10:00 AM</div>
                        </div>
                        <div class="overlay-product-card olympics-card-black" style="flex-direction: column; height: auto; padding: 16px;">
                            <div style="font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: #6B7280; margin-bottom: 8px;">Today</div>
                            <div class="overlay-product-title" style="font-size: 16px; font-weight: 500; margin-bottom: 4px; color: #1F2933;">Figure Skating</div>
                            <div style="font-size: 13px; color: #6B7280;">Pairs Short Program • 2:30 PM</div>
                        </div>
                        <div class="overlay-product-card olympics-card-red" style="flex-direction: column; height: auto; padding: 16px;">
                            <div style="font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: #6B7280; margin-bottom: 8px;">Tomorrow</div>
                            <div class="overlay-product-title" style="font-size: 16px; font-weight: 500; margin-bottom: 4px; color: #1F2933;">Ice Hockey</div>
                            <div style="font-size: 13px; color: #6B7280;">USA vs Canada • 8:00 PM</div>
                        </div>
                        <div class="overlay-product-card olympics-card-yellow" style="flex-direction: column; height: auto; padding: 16px;">
                            <div style="font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: #6B7280; margin-bottom: 8px;">Feb 8</div>
                            <div class="overlay-product-title" style="font-size: 16px; font-weight: 500; margin-bottom: 4px; color: #1F2933;">Snowboarding</div>
                            <div style="font-size: 13px; color: #6B7280;">Men's Halfpipe Final • 11:00 AM</div>
                        </div>
                    </div>
                </div>
            `;
        };

        // Function to restore original product grid
        const restoreProductGrid = () => {
            const container = document.querySelector('[data-product-grid]');
            if (!container) return;

            // Remove winter olympics class from suggestions container
            const suggestionsPreview = document.querySelector('.search-suggestions-preview');
            if (suggestionsPreview) {
                suggestionsPreview.classList.remove('winter-olympics-active');
            }

            if (originalProductGridContent) {
                container.innerHTML = originalProductGridContent;
            } else if (originalProductGridSections) {
                renderOverlayProductGrid();
            }
        };

        const fetchImages = async () => {
            const imageUrls = [];

            for (const keyword of keywords) {
                try {
                    const response = await fetch(`https://api.pexels.com/v1/search?query=${encodeURIComponent(keyword)}&per_page=1`, {
                    headers: {
                        Authorization: apiKey
                    }
                });

                    if (!response.ok) {
                        throw new Error(`Pexels request failed: ${response.status}`);
                    }

                const data = await response.json();
                    const photoUrl = data.photos && data.photos[0] ? data.photos[0].src.medium : null;
                    imageUrls.push(photoUrl || 'https://via.placeholder.com/600x400?text=Image');
                } catch (error) {
                    console.error('Error fetching image for keyword:', keyword, error);
                    imageUrls.push('https://via.placeholder.com/600x400?text=Image');
            }
            }

            return imageUrls;
        };

        const updateImages = async () => {
            const imagePlaceholders = document.querySelectorAll('.image-placeholder');
            if (!imagePlaceholders.length) {
                return;
            }

            const images = await fetchImages();

            imagePlaceholders.forEach((placeholder, index) => {
                const img = document.createElement('img');
                img.src = images[index] || 'https://via.placeholder.com/600x400?text=Image';
                img.alt = placeholder.nextElementSibling ? placeholder.nextElementSibling.textContent : 'Article image';
                img.style.width = '100%';
                img.style.height = '160px';
                img.style.objectFit = 'cover';
                placeholder.replaceWith(img);
            });
        };

        document.addEventListener('DOMContentLoaded', () => {
            renderOverlayProductGrid();
            updateImages();
            // Attach hover listeners to initial suggestions
            attachHoverListeners();
        });

        const topOverlay = document.querySelector('.top-overlay');
        const bottomOverlay = document.querySelector('.bottom-overlay');
        const searchWrapperElement = document.querySelector('.search-wrapper');
        const searchDescriptionElement = document.querySelector('.search-description');
        const searchSuggestionsPreviewElement = document.querySelector('.search-suggestions-preview');
        const searchBoxElement = document.querySelector('.search-box');
        const searchClearButton = document.querySelector('.search-clear-button');
        const searchContainer = document.querySelector('.search-container');
        const productContainers = Array.from(document.querySelectorAll('.search-wrapper-products, .search-description'));
        const resizeObservers = [];

        const updateSearchContentOffset = () => {
            if (!searchWrapperElement || !searchContainer) {
                return;
            }

            const wrapperRect = searchWrapperElement.getBoundingClientRect();
            const containerRect = searchContainer.getBoundingClientRect();
            const spacing = 32;
            const offset = Math.max(wrapperRect.bottom - containerRect.top + spacing, spacing);

            searchContainer.style.setProperty('--search-wrapper-offset', `${offset}px`);
        };

        if (searchWrapperElement && searchContainer) {
            updateSearchContentOffset();

            if (typeof ResizeObserver === 'function') {
                const wrapperObserver = new ResizeObserver(updateSearchContentOffset);
                wrapperObserver.observe(searchWrapperElement);
                resizeObservers.push(wrapperObserver);

                productContainers.forEach((container) => {
                    if (container) {
                        const containerObserver = new ResizeObserver(updateSearchContentOffset);
                        containerObserver.observe(container);
                        resizeObservers.push(containerObserver);
                    }
                });
            }

            window.addEventListener('resize', updateSearchContentOffset);
        }

        const localCarrotRow = document.querySelector('.local-carrot-row');
        const showAdMarketplaceCarrots = () => {
            if (!localCarrotRow) {
                return;
            }

            localCarrotRow.innerHTML = `<ul class="local-carrot-grid">${carrotTemplates.adMarketplace()}</ul>`;
            localCarrotRow.classList.add('is-visible');
            localCarrotRow.setAttribute('aria-hidden', 'false');

            if (suggestionsContainer) {
                suggestionsContainer.classList.add('local-horizontal');
                suggestionsContainer.classList.remove('show-carrot');
                suggestionsContainer.classList.remove('expand-left');
            }

            if (carrotList) {
                carrotList.innerHTML = '';
                carrotList.dataset.carrotState = '0';
            }
        };

        const hideLocalCarrots = () => {
            if (!localCarrotRow) {
                return;
            }

            localCarrotRow.innerHTML = '';
            localCarrotRow.classList.remove('is-visible');
            localCarrotRow.setAttribute('aria-hidden', 'true');

            if (suggestionsContainer) {
                suggestionsContainer.classList.remove('local-horizontal');
                if (!carrotList || !carrotList.innerHTML.trim()) {
                    suggestionsContainer.classList.remove('show-carrot');
                }
            }
        };

        if (document.readyState !== 'loading') {
            if (searchBoxElement) {
                searchBoxElement.value = '';
            }
        } else {
            document.addEventListener('DOMContentLoaded', () => {
                if (searchBoxElement) {
                    searchBoxElement.value = '';
                }
            });
        }
 
         const OVERLAY_STATE_KEY = 'overlayExpanded';
         const OVERLAY_RESTORE_KEY = 'overlayRestorePending';
 
         const elementsForTransitionControl = [topOverlay, bottomOverlay, searchWrapperElement, searchDescriptionElement, searchSuggestionsPreviewElement];

        const setOverlayState = (expanded, { suppressTransition = false } = {}) => {
            if (!topOverlay || !bottomOverlay || !searchWrapperElement || !searchDescriptionElement || !searchSuggestionsPreviewElement) {
                return;
            }

            if (suppressTransition) {
                elementsForTransitionControl.forEach((el) => el && el.classList.add('no-transition'));
            }

            if (expanded) {
                topOverlay.classList.add('is-focused');
                searchWrapperElement.classList.add('expanded');
                searchDescriptionElement.classList.add('expanded');
                bottomOverlay.style.top = '85vh';
                bottomOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
                bottomOverlay.style.pointerEvents = 'auto';
            } else {
                topOverlay.classList.remove('is-focused');
                topOverlay.classList.remove('winter-olympics');
                searchWrapperElement.classList.remove('expanded');
                searchDescriptionElement.classList.remove('expanded');
                bottomOverlay.style.top = '130px';
                bottomOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0)';
                bottomOverlay.style.pointerEvents = 'none';
            }

            sessionStorage.setItem(OVERLAY_STATE_KEY, expanded ? 'true' : 'false');

        if (typeof requestAnimationFrame === 'function') {
            requestAnimationFrame(() => updateSearchContentOffset());
        } else {
            updateSearchContentOffset();
        }

            if (suppressTransition) {
                requestAnimationFrame(() => {
                    elementsForTransitionControl.forEach((el) => el && el.classList.remove('no-transition'));
                });
            }
        };

        if (topOverlay && bottomOverlay) {
            const handleOverlayBackground = () => {
                const scrolled = window.scrollY > 0;
                topOverlay.classList.toggle('is-scrolled', scrolled);
            };
            handleOverlayBackground();
            window.addEventListener('scroll', handleOverlayBackground, { passive: true });
        }

        // Animate gradient border
        const searchWrapper = document.querySelector('.search-wrapper');
        let gradientAnimationId = null;
        let gradientAngle = 0;

        const animateGradient = () => {
            if (searchWrapper && searchBoxElement && document.activeElement === searchBoxElement) {
                gradientAngle = (gradientAngle + 1.2) % 360;
                const beforeElement = window.getComputedStyle(searchWrapper, '::before');
                searchWrapper.style.setProperty('--gradient-angle', `${gradientAngle}deg`);
                // Directly update the background of the pseudo-element
                const style = document.createElement('style');
                style.id = 'gradient-animation-style';
                const existingStyle = document.getElementById('gradient-animation-style');
                if (existingStyle) {
                    existingStyle.remove();
                }
                style.textContent = `.search-wrapper:focus-within::before { background: conic-gradient(from ${gradientAngle}deg, #945AF2 0%, #F37E49 71%, #945AF2 100%); }`;
                document.head.appendChild(style);
                gradientAnimationId = requestAnimationFrame(animateGradient);
            } else {
                const existingStyle = document.getElementById('gradient-animation-style');
                if (existingStyle) {
                    existingStyle.remove();
                }
                if (gradientAnimationId) {
                    cancelAnimationFrame(gradientAnimationId);
                    gradientAnimationId = null;
                }
            }
        };

        if (topOverlay && searchBoxElement && bottomOverlay) {
            searchBoxElement.addEventListener('focus', () => {
                setOverlayState(true);
                setTimeout(() => {
                    if (!gradientAnimationId) {
                        animateGradient();
                    }
                }, 50);
            });

            searchBoxElement.addEventListener('blur', () => {
                const existingStyle = document.getElementById('gradient-animation-style');
                if (existingStyle) {
                    existingStyle.remove();
                }
                if (gradientAnimationId) {
                    cancelAnimationFrame(gradientAnimationId);
                    gradientAnimationId = null;
                }
            });
        }

        const overlayCloseButton = document.querySelector('.search-background-bottom-overlay');
        if (overlayCloseButton && searchBoxElement) {
            overlayCloseButton.addEventListener('click', () => {
                setOverlayState(false);
                searchBoxElement.blur();
            });
        }

        const closeButton = document.querySelector('.close-button');
        if (closeButton && searchBoxElement) {
            closeButton.addEventListener('click', () => {
                const existingStyle = document.getElementById('gradient-animation-style');
                if (existingStyle) {
                    existingStyle.remove();
                }
                if (gradientAnimationId) {
                    cancelAnimationFrame(gradientAnimationId);
                    gradientAnimationId = null;
                }
                setOverlayState(false);
                searchBoxElement.blur();
            });
        }

        // Toggle demo searches card on info icon click
        const infoIconButton = document.querySelector('.info-icon-button');
        const infoIconWrapper = document.querySelector('.info-icon-wrapper');
        if (infoIconButton && infoIconWrapper) {
            infoIconButton.addEventListener('click', (e) => {
                e.stopPropagation();
                infoIconWrapper.classList.toggle('is-open');
            });
        }

        // Clear search history button
        const clearHistoryButton = document.querySelector('.clear-history-button');
        if (clearHistoryButton) {
            clearHistoryButton.addEventListener('click', (e) => {
                e.stopPropagation();
                try {
                    localStorage.removeItem('search_history');
                    clearHistoryButton.textContent = 'History cleared';
                    clearHistoryButton.style.backgroundColor = '#D1FAE5';
                    clearHistoryButton.style.color = '#065F46';
                    setTimeout(() => {
                        clearHistoryButton.textContent = 'Clear search history';
                        clearHistoryButton.style.backgroundColor = '#F3F4F6';
                        clearHistoryButton.style.color = '#374151';
                    }, 2000);
                } catch (error) {
                    console.error('Error clearing search history:', error);
                    clearHistoryButton.textContent = 'Error clearing history';
                    setTimeout(() => {
                        clearHistoryButton.textContent = 'Clear search history';
                    }, 2000);
                }
            });
        }

        if (bottomOverlay && searchBoxElement) {
            bottomOverlay.addEventListener('click', () => {
                if (topOverlay && topOverlay.classList.contains('is-focused')) {
                    setOverlayState(false);
                    searchBoxElement.blur();
                }
            });
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && topOverlay && topOverlay.classList.contains('is-focused') && searchBoxElement) {
                setOverlayState(false);
                searchBoxElement.blur();
            }
        });

        if (topOverlay && bottomOverlay) {
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'hidden') {
                    sessionStorage.setItem(OVERLAY_STATE_KEY, topOverlay.classList.contains('is-focused') ? 'true' : 'false');
                    sessionStorage.setItem(OVERLAY_RESTORE_KEY, 'true');
                } else if (document.visibilityState === 'visible') {
                    const shouldRestore = sessionStorage.getItem(OVERLAY_RESTORE_KEY) === 'true';
                    if (shouldRestore) {
                        const shouldExpand = sessionStorage.getItem(OVERLAY_STATE_KEY) === 'true';
                        setOverlayState(shouldExpand, { suppressTransition: true });
                        sessionStorage.setItem(OVERLAY_RESTORE_KEY, 'false');
                    }
                }
            });
        }

        // Debug button handlers
        const debugButtons = document.querySelectorAll('.debug-buttons .debug-button');
        const suggestionsContainer = document.querySelector('.search-suggestions-preview-column-container');
        const carrotList = document.querySelector('.search-suggestions-preview-list:last-child');
        const suggestionsList = document.querySelector('.search-suggestions-preview-list:first-child');
        
        let currentState = 0; // Track current state
        let selectedSuggestionIndex = -1; // Track selected suggestion index (only one at a time)
        let suggestionsJustUpdated = false; // Track if suggestions were just updated to prevent stale hover
        let isKeyboardNavigating = false; // Track if user is using keyboard navigation
        
        // Fixed skeleton widths for each row position (1-10)
        const skeletonWidths = [
            Math.floor(Math.random() * 130) + 30, // Row 1
            Math.floor(Math.random() * 130) + 30, // Row 2
            Math.floor(Math.random() * 130) + 30, // Row 3
            Math.floor(Math.random() * 130) + 30, // Row 4
            Math.floor(Math.random() * 130) + 30, // Row 5
            Math.floor(Math.random() * 130) + 30, // Row 6
            Math.floor(Math.random() * 130) + 30, // Row 7
            Math.floor(Math.random() * 130) + 30, // Row 8
            Math.floor(Math.random() * 130) + 30, // Row 9
            Math.floor(Math.random() * 130) + 30  // Row 10
        ];
        
        // Mapping of demo search terms to carrot states
        const demoSearchCarrots = {
            'fox wiki': 2,        // wikipedia
            'chair': 8,          // adMarketplace
            'ramen': 18,         // adMarketplaceRamen
            'sushi': 19,         // adMarketplaceSushi
            'sneakers': 9,       // bigAd
            'uber stock': 6,     // stocks
            'stocks': 20,        // stocksETFs
            'ac8170': 1,         // flights
            'lakers game': 5,    // sports
            'coffee shops': 0,   // local
            'weather': 4,         // weather
            'vpn': 13,           // vpn
            'mdn': 10,           // mdn
            'array': 10,         // mdn
            'youtube': 12,       // youtube
            'time rome': 7,     // worldClock
            'happy emoji': 11,   // happyEmoji
            'renewable energy': 16  // renewableEnergy
        };
        
        // Function to detect currency conversion patterns
        const detectCurrencyMatch = (query) => {
            const queryLower = query.toLowerCase().trim();
            
            // Currency codes mapping
            const currencyCodes = {
                'usd': 'USD', 'dollar': 'USD', 'dollars': 'USD', 'us': 'USD',
                'eur': 'EUR', 'euro': 'EUR', 'euros': 'EUR', '€': 'EUR',
                'gbp': 'GBP', 'pound': 'GBP', 'pounds': 'GBP', 'sterling': 'GBP', 'uk': 'GBP',
                'jpy': 'JPY', 'yen': 'JPY', 'japan': 'JPY',
                'cad': 'CAD', 'canadian': 'CAD', 'canada': 'CAD',
                'aud': 'AUD', 'australian': 'AUD', 'australia': 'AUD'
            };
            
            // Country to currency mapping
            const countryToCurrency = {
                'italy': 'EUR', 'france': 'EUR', 'germany': 'EUR', 'spain': 'EUR', 'portugal': 'EUR',
                'netherlands': 'EUR', 'belgium': 'EUR', 'austria': 'EUR', 'greece': 'EUR',
                'uk': 'GBP', 'united kingdom': 'GBP', 'britain': 'GBP', 'england': 'GBP',
                'japan': 'JPY',
                'canada': 'CAD',
                'australia': 'AUD'
            };
            
            // Pattern 1: $XX in euros / $XX in italy / $XX EUR / $XX in [country]
            let match = queryLower.match(/^\$(\d{1,4})\s+(?:in\s+)?(italy|france|germany|spain|portugal|netherlands|belgium|austria|greece|uk|united kingdom|britain|england|japan|canada|australia|euros?|eur|euro|€)/);
            if (match) {
                const amount = match[1];
                const target = match[2];
                const toCurrency = countryToCurrency[target] || currencyCodes[target] || 'EUR';
                return { amount, fromCurrency: 'USD', toCurrency, state: 14 };
            }
            
            // Pattern 2: XXUSD in italy / XX USD in italy / XXUSD EUR
            match = queryLower.match(/^(\d{1,4})\s*(?:usd|dollars?|dollar)\s+(?:in\s+)?(italy|france|germany|spain|portugal|netherlands|belgium|austria|greece|eur|euros?|euro|€)/);
            if (match) {
                const amount = match[1];
                const target = match[2];
                const toCurrency = countryToCurrency[target] || currencyCodes[target] || 'EUR';
                return { amount, fromCurrency: 'USD', toCurrency, state: 14 };
            }
            
            // Pattern 3: XX USD to EUR / XX USD EUR / convert XX USD to EUR
            match = queryLower.match(/(?:convert\s+)?(\d{1,4})\s*(?:usd|dollars?|dollar)\s+(?:to\s+)?(eur|euros?|euro|gbp|pounds?|pound|jpy|yen|cad|aud|€)/);
            if (match) {
                const amount = match[1];
                const toCurrency = currencyCodes[match[2]] || match[2].toUpperCase();
                return { amount, fromCurrency: 'USD', toCurrency, state: 14 };
            }
            
            // Pattern 4: XX EUR to USD / XX euros to dollars
            match = queryLower.match(/(?:convert\s+)?(\d{1,4})\s*(eur|euros?|euro|gbp|pounds?|pound|jpy|yen|cad|aud|€)\s+(?:to\s+)?(usd|dollars?|dollar|eur|euros?|euro|gbp|pounds?|pound|jpy|yen|cad|aud|€)/);
            if (match) {
                const amount = match[1];
                const fromCurrency = currencyCodes[match[2]] || match[2].toUpperCase();
                const toCurrency = currencyCodes[match[3]] || match[3].toUpperCase();
                return { amount, fromCurrency, toCurrency, state: 14 };
            }
            
            return null;
        };
        
        // Function to detect translation patterns
        const detectTranslationMatch = (query) => {
            const queryLower = query.toLowerCase().trim();
            
            // Language mapping for display (normalize common variations)
            const languageMap = {
                'italian': 'italian', 'italy': 'italian', 'it': 'italian',
                'spanish': 'spanish', 'spain': 'spanish', 'es': 'spanish',
                'french': 'french', 'france': 'french', 'fr': 'french',
                'german': 'german', 'germany': 'german', 'de': 'german',
                'portuguese': 'portuguese', 'portugal': 'portuguese', 'pt': 'portuguese',
                'japanese': 'japanese', 'japan': 'japanese', 'jp': 'japanese',
                'chinese': 'chinese', 'china': 'chinese', 'zh': 'chinese',
                'korean': 'korean', 'korea': 'korean', 'ko': 'korean',
                'russian': 'russian', 'russia': 'russian', 'ru': 'russian'
            };
            
            // Pattern 1: "how do i say {term} in {language}" (check first to avoid matching generic pattern)
            let match = queryLower.match(/^how\s+do\s+i\s+say\s+(.+?)\s+in\s+(\w+)$/);
            if (match) {
                const term = match[1].trim();
                const languageKey = match[2].toLowerCase();
                const targetLanguage = languageMap[languageKey] || languageKey;
                if (term.length > 0 && languageKey.length > 0) {
                    return { term, targetLanguage, state: 15 };
                }
            }
            
            // Pattern 2: "how to say {term} in {language}" (check second to avoid matching generic pattern)
            match = queryLower.match(/^how\s+to\s+say\s+(.+?)\s+in\s+(\w+)$/);
            if (match) {
                const term = match[1].trim();
                const languageKey = match[2].toLowerCase();
                const targetLanguage = languageMap[languageKey] || languageKey;
                if (term.length > 0 && languageKey.length > 0) {
                    return { term, targetLanguage, state: 15 };
                }
            }
            
            // Pattern 3: "translate {term} to {language}"
            match = queryLower.match(/^translate\s+(.+?)\s+to\s+(\w+)$/);
            if (match) {
                const term = match[1].trim();
                const languageKey = match[2].toLowerCase();
                const targetLanguage = languageMap[languageKey] || languageKey;
                if (term.length > 0 && languageKey.length > 0) {
                    return { term, targetLanguage, state: 15 };
                }
            }
            
            // Pattern 4: "{term} in {language}" (check last as it's the most generic)
            match = queryLower.match(/^(.+?)\s+in\s+(\w+)$/);
            if (match) {
                const term = match[1].trim();
                const languageKey = match[2].toLowerCase();
                const targetLanguage = languageMap[languageKey] || languageKey;
                if (term.length > 0 && languageKey.length > 0) {
                    return { term, targetLanguage, state: 15 };
                }
            }
            
            return null;
        };
        
        // Function to fetch translation from AI
        async function fetchTranslation(query, term) {
            console.log('[TRANSLATION] Fetching translation for query:', query);
            
            if (!OPENROUTER_API_KEY) {
                console.warn('[TRANSLATION] OpenRouter API key not set');
                return { translation: 'Translation unavailable', language: null };
            }
            
            const requestBody = {
                model: 'anthropic/claude-3-haiku',
                messages: [
                    {
                        role: 'system',
                        content: 'You are a translation assistant. Translate the user\'s query. Return a JSON object with "translation" (the translated text) and "language" (the target language name, capitalized, e.g. "Italian", "Spanish"). Example: {"translation": "Ciao", "language": "Italian"}'
                    },
                    {
                        role: 'user',
                        content: query
                    }
                ],
                temperature: 0.3,
                max_tokens: 150
            };
            
            try {
                const response = await fetch(OPENROUTER_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
                    },
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    console.error('[TRANSLATION] API error:', response.status, response.statusText);
                    return { translation: 'Translation unavailable', language: null };
                }
                
                const data = await response.json();
                const content = data.choices?.[0]?.message?.content?.trim() || '';
                console.log('[TRANSLATION] Received response:', content);
                
                // Try to parse as JSON first
                let translationResult = { translation: 'Translation unavailable', language: null };
                try {
                    // Look for JSON object in the response
                    const jsonMatch = content.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        const parsed = JSON.parse(jsonMatch[0]);
                        translationResult = {
                            translation: parsed.translation || content,
                            language: parsed.language || null
                        };
                    } else {
                        // Fallback: use the content as translation
                        translationResult = {
                            translation: content,
                            language: null
                        };
                    }
                } catch (parseError) {
                    console.warn('[TRANSLATION] Failed to parse JSON, using raw content');
                    translationResult = {
                        translation: content,
                        language: null
                    };
                }
                
                console.log('[TRANSLATION] Parsed result:', translationResult);
                return translationResult;
            } catch (error) {
                console.error('[TRANSLATION] Error fetching translation:', error);
                return { translation: 'Translation unavailable', language: null };
            }
        }
        
        // Function to check if a query uniquely matches a carrot (disambiguates it)
        const findUniqueCarrotMatch = (query) => {
            const queryLower = query.toLowerCase().trim();
            
            // If query starts with $, a number, or "dollars", prioritize currency over translation
            // This prevents translation from matching partial patterns
            const queryTrimmed = query.trim();
            const startsWithCurrency = /^[\$0-9]/.test(queryTrimmed) || /^\d+\s*(?:usd|dollars?|dollar)/i.test(queryTrimmed);
            
            if (startsWithCurrency) {
                // Check for currency conversion patterns first
                const currencyMatch = detectCurrencyMatch(query);
                if (currencyMatch) {
                    return currencyMatch;
                }
                // If starts with currency indicator but pattern doesn't match yet,
                // don't check translation - return null to wait for complete pattern
                return null;
            }
            
            // Check for translation patterns (only if not a currency query)
            const translationMatch = detectTranslationMatch(query);
            if (translationMatch) {
                return translationMatch;
            }
            
            // Then check for currency conversion patterns (if not already checked)
            const currencyMatch = detectCurrencyMatch(query);
            if (currencyMatch) {
                return currencyMatch;
            }
            
            // Then check for exact match
            if (demoSearchCarrots[queryLower] !== undefined) {
                return { term: queryLower, state: demoSearchCarrots[queryLower] };
            }
            
            // Check for partial matches that uniquely identify a carrot
            const matchingTerms = Object.keys(demoSearchCarrots).filter(term => 
                term.startsWith(queryLower)
            );
            
            // If exactly one match, check if it's long enough to disambiguate
            if (matchingTerms.length === 1) {
                const matchedTerm = matchingTerms[0];
                
                // Minimum length requirements to show user intent
                // Analysis of each trigger in real-world search context:
                const minLengths = {
                    // 'time rome': "time" alone could be "time management", "time travel", "time zones", "time converter"
                    //            "time r" could be "time rome", "time right now", "time remaining", "time range"
                    //            "time ro" (7 chars) is clearer - likely "time rome" or "time round"
                    //            "time rom" (8 chars) is even clearer
                    'time rome': 8,        // Require "time rom" (8 chars) - clear intent for Rome time
                    
                    // 'uber stock': "uber" alone could be "uber eats", "uber driver", "uber app", "uber login"
                    //              "uber s" could be "uber stock", "uber support", "uber sign up", "uber store"
                    //              "uber st" (7 chars) is better - likely "uber stock" or "uber store"
                    //              "uber sto" (8 chars) is clearer
                    'uber stock': 8,        // Require "uber sto" (8 chars) - clear intent for stock info
                    
                    // 'lakers game': "lakers" alone could be "lakers game", "lakers schedule", "lakers tickets", "lakers roster"
                    //               All are Lakers-related, so showing game info is useful regardless
                    'lakers game': 7,      // "lakers" (7 chars) is enough - clear Lakers intent
                    
                    // 'coffee shops': "coffee" alone could be "coffee shops", "coffee cake", "coffee beans", "coffee maker", "coffee recipe"
                    //                "coffee s" could be "coffee shops", "coffee store", "coffee shop near me", "coffee subscription"
                    //                "coffee sh" (10 chars) is better - likely "coffee shop" or "coffee shops"
                    'coffee shops': 10,    // Require "coffee sh" (10 chars) - clear intent for shops
                    
                    // 'happy emoji': "happy" alone could be "happy emoji", "happy birthday", "happy new year", "happy quotes", "happy song"
                    //               "happy e" could be "happy emoji", "happy ending", "happy easter", "happy expression"
                    //               "happy em" (8 chars) is better - likely "happy emoji" or "happy emotion"
                    //               "happy emo" (9 chars) is even clearer
                    'happy emoji': 9,      // Require "happy emo" (9 chars) - clear intent for emoji
                    
                    // 'fox wiki': "fox" alone could be "fox wiki", "fox news", "fox sports", "fox weather", "fox channel"
                    //            "fox w" could be "fox wiki", "fox weather", "fox website", "fox watch"
                    //            "fox wi" (6 chars) is better - likely "fox wiki" or "fox weather"
                    //            "fox wik" (7 chars) is even clearer
                    'fox wiki': 7,         // Require "fox wik" (7 chars) - clear intent for wiki
                    
                    // 'chair': "chair" alone could be buying a chair (our carrot) or "chair design", "chair covers", "chair exercises"
                    //          But "chair" (5 chars) is the full word, so it's acceptable
                    'chair': 5,            // "chair" (5 chars) - full word, acceptable
                    'ramen': 5,            // "ramen" (5 chars) - full word, acceptable
                    'sushi': 5,            // "sushi" (5 chars) - full word, acceptable
                    
                    // 'sneakers': "sneaker" (singular) is fine - clear intent for sneakers
                    'sneakers': 7,        // "sneaker" (7 chars) - clear intent
                    
                    // 'weather': "weather" alone could be "weather", "weather forecast", "weather today", "weather app"
                    //            But "weather" (7 chars) is the full word, so it's acceptable
                    'weather': 7,          // "weather" (7 chars) - full word, acceptable
                    
                    // 'array': "array" alone could be MDN docs (our carrot) or "array javascript", "array python", "array methods"
                    //          But "array" (5 chars) is the full word, so it's acceptable
                    'array': 5,            // "array" (5 chars) - full word, acceptable
                    
                    // 'youtube': "youtube" alone could be "youtube", "youtube music", "youtube tv", "youtube downloader"
                    //            But "youtube" (7 chars) is the full word, so it's acceptable
                    'youtube': 7,          // "youtube" (7 chars) - full word, acceptable
                    
                    // 'ac8170': Flight numbers are specific - partial matches could match other flights
                    'ac8170': 6,           // Require full flight number "ac8170" (6 chars)
                    
                    // 'vpn': Exact match, specific term
                    'vpn': 3,              // Exact match, 3 chars is fine
                    
                    // 'mdn': Exact match, specific term
                    'mdn': 3,              // Exact match, 3 chars is fine
                    
                    // 'renewable energy': "renewable" alone could be "renewable resources", "renewable energy", "renewable power"
                    //                      "renewable e" could be "renewable energy", "renewable electricity", "renewable energy sources"
                    //                      "renewable en" (12 chars) is clearer - likely "renewable energy"
                    'renewable energy': 12,  // Require "renewable en" (12 chars) - clear intent for renewable energy
                    
                    // 'stocks': "stocks" alone could be "stocks", "stocks market", "stocks today", "stocks to buy"
                    //           But "stocks" (6 chars) is the full word, so it's acceptable
                    'stocks': 6              // "stocks" (6 chars) - full word, acceptable
                };
                
                const minLength = minLengths[matchedTerm] || 3;
                
                if (queryLower.length < minLength) {
                    return null;
                }
                
                return { term: matchedTerm, state: demoSearchCarrots[matchedTerm] };
            }
            
            // If multiple matches or no matches, return null
            return null;
        };
        
        // Function to show carrot for demo searches
        const showCarrotForDemoSearch = (query) => {
            const queryLower = query.toLowerCase().trim();
            const queryTrimmed = query.trim();
            
            // If query starts with $, a number, or "dollars", prioritize currency over translation
            // This prevents translation from matching partial patterns like "ital" in "$100 in ital"
            const startsWithCurrency = /^[\$0-9]/.test(queryTrimmed) || /^\d+\s*(?:usd|dollars?|dollar)/i.test(queryTrimmed);
            
            if (startsWithCurrency) {
                // Check for currency conversion first - don't check translation at all
                const currencyMatch = detectCurrencyMatch(query);
                if (currencyMatch && carrotList && suggestionsContainer) {
                    const needsSlide = currentState !== 0 && currentState !== currencyMatch.state;
                    
                    if (needsSlide) {
                        suggestionsContainer.classList.add('expand-left');
                        suggestionsContainer.classList.remove('show-carrot');
                        
                        setTimeout(() => {
                            setCarrotContent(currencyMatch.state, currencyMatch.amount, currencyMatch.fromCurrency, currencyMatch.toCurrency);
                            currentState = currencyMatch.state;
                            suggestionsContainer.classList.remove('expand-left');
                            suggestionsContainer.classList.add('show-carrot');
                        }, 400);
                    } else {
                        setCarrotContent(currencyMatch.state, currencyMatch.amount, currencyMatch.fromCurrency, currencyMatch.toCurrency);
                        currentState = currencyMatch.state;
                        suggestionsContainer.classList.remove('expand-left');
                        suggestionsContainer.classList.add('show-carrot');
                    }
                    return true;
                }
                // If currency pattern doesn't match yet but starts with $/number/dollars, 
                // don't show translation - wait for complete currency pattern
                return false;
            }
            
            // Check for translation (only if not a currency query)
            const translationMatch = detectTranslationMatch(query);
            if (translationMatch && carrotList && suggestionsContainer) {
                const needsSlide = currentState !== 0 && currentState !== translationMatch.state;
                
                // Show carrot immediately with loading state
                const showTranslationCarrot = (translationResult, language) => {
                    // Use AI-returned language if available, otherwise use detected language
                    const displayLanguage = language || translationMatch.targetLanguage;
                    
                    if (needsSlide) {
                        suggestionsContainer.classList.add('expand-left');
                        suggestionsContainer.classList.remove('show-carrot');
                        
                        setTimeout(() => {
                            setCarrotContent(translationMatch.state, translationMatch.term, displayLanguage, translationResult);
                            currentState = translationMatch.state;
                            suggestionsContainer.classList.remove('expand-left');
                            suggestionsContainer.classList.add('show-carrot');
                        }, 400);
                    } else {
                        setCarrotContent(translationMatch.state, translationMatch.term, displayLanguage, translationResult);
                        currentState = translationMatch.state;
                        suggestionsContainer.classList.remove('expand-left');
                        suggestionsContainer.classList.add('show-carrot');
                    }
                };
                
                // Show loading state first
                showTranslationCarrot('Loading translation...', null);
                
                // Fetch translation from AI - send the full original query, let AI figure out the language
                fetchTranslation(query, translationMatch.term).then(result => {
                    const translation = typeof result === 'string' ? result : result.translation;
                    const language = typeof result === 'string' ? null : result.language;
                    showTranslationCarrot(translation, language);
                });
                
                return true;
            }
            
            // Check for currency conversion (only if not already checked above)
            if (!startsWithCurrency) {
                const currencyMatch = detectCurrencyMatch(query);
                if (currencyMatch && carrotList && suggestionsContainer) {
                    const needsSlide = currentState !== 0 && currentState !== currencyMatch.state;
                    
                    if (needsSlide) {
                        suggestionsContainer.classList.add('expand-left');
                        suggestionsContainer.classList.remove('show-carrot');
                        
                        setTimeout(() => {
                            setCarrotContent(currencyMatch.state, currencyMatch.amount, currencyMatch.fromCurrency, currencyMatch.toCurrency);
                            currentState = currencyMatch.state;
                            suggestionsContainer.classList.remove('expand-left');
                            suggestionsContainer.classList.add('show-carrot');
                        }, 400);
                    } else {
                        setCarrotContent(currencyMatch.state, currencyMatch.amount, currencyMatch.fromCurrency, currencyMatch.toCurrency);
                        currentState = currencyMatch.state;
                        suggestionsContainer.classList.remove('expand-left');
                        suggestionsContainer.classList.add('show-carrot');
                    }
                    return true;
                }
            }
            
            // Check for exact match first
            let carrotState = demoSearchCarrots[queryLower];
            let matchedTerm = queryLower;
            
            // If no exact match, check for unique partial match
            if (carrotState === undefined) {
                const uniqueMatch = findUniqueCarrotMatch(queryLower);
                if (uniqueMatch) {
                    carrotState = uniqueMatch.state;
                    matchedTerm = uniqueMatch.term;
                }
            }
            
            if (carrotState !== undefined && carrotList && suggestionsContainer) {
                // Special handling for ad marketplace carrots (chair, ramen, sushi), local carrots (coffee shops), stocks (uber stock, stocks), and sports (lakers game) - show as regular suggestion, not as carrot
                // Check both queryLower and matchedTerm to catch exact and partial matches
                if ((carrotState === 8 && (queryLower === 'chair' || matchedTerm === 'chair')) || 
                    (carrotState === 18 && (queryLower === 'ramen' || matchedTerm === 'ramen')) || 
                    (carrotState === 19 && (queryLower === 'sushi' || matchedTerm === 'sushi')) ||
                    (carrotState === 0 && (queryLower === 'coffee shops' || matchedTerm === 'coffee shops')) ||
                    (carrotState === 6 && (queryLower === 'uber stock' || matchedTerm === 'uber stock')) ||
                    (carrotState === 20 && (queryLower === 'stocks' || matchedTerm === 'stocks')) ||
                    (carrotState === 5 && ((queryLower === 'lakers game' || matchedTerm === 'lakers game') || (queryLower.startsWith('lakers') && queryLower.length >= 7)))) {
                    // Don't show these carrots as right panel carrots - they're handled in updateSuggestions
                    return false;
                }
                
                // Check if we need to slide in from the right
                const needsSlide = currentState !== 0 && currentState !== carrotState;
                
                if (needsSlide) {
                    // Slide out current carrot, then slide in new one
                    suggestionsContainer.classList.add('expand-left');
                    suggestionsContainer.classList.remove('show-carrot');
                    
                    setTimeout(() => {
                        setCarrotContent(carrotState);
                        currentState = carrotState;
                        suggestionsContainer.classList.remove('expand-left');
                        suggestionsContainer.classList.add('show-carrot');
                    }, 400);
                } else {
                    // Just show the carrot directly
                    setCarrotContent(carrotState);
                    currentState = carrotState;
                    suggestionsContainer.classList.remove('expand-left');
                    suggestionsContainer.classList.add('show-carrot');
                }
                return true;
            }
            
            // Check if query is a prefix of any demo search (don't hide carrot while typing)
            const isPrefix = Object.keys(demoSearchCarrots).some(term => term.startsWith(queryLower));
            if (isPrefix) {
                // User is typing a demo search, don't hide carrot yet
                return false;
            }
            
            return false;
        };
        
        // Minimal iconMappings for ut.html (since suggestion-paths.js was removed)
        const iconMappings = {
            lightning: [],
            search: []
        };
        
        // Search history management
        function getSearchHistory() {
            try {
                const history = localStorage.getItem('search_history');
                return history ? JSON.parse(history) : [];
            } catch (error) {
                console.error('Error reading search history:', error);
                return [];
            }
        }

        function saveToSearchHistory(text) {
            try {
                const history = getSearchHistory();
                const textLower = text.toLowerCase();
                
                // Remove if already exists (case-insensitive)
                const filteredHistory = history.filter(item => item.toLowerCase() !== textLower);
                
                // Add to top of list
                filteredHistory.unshift(text);
                
                // Limit to 100 items
                const limitedHistory = filteredHistory.slice(0, 100);
                
                localStorage.setItem('search_history', JSON.stringify(limitedHistory));
            } catch (error) {
                console.error('Error saving to search history:', error);
            }
        }

        function isInSearchHistory(text) {
            try {
                const history = getSearchHistory();
                const textLower = text.toLowerCase();
                return history.some(item => item.toLowerCase() === textLower);
            } catch (error) {
                console.error('Error checking search history:', error);
                return false;
            }
        }

        function moveToTopOfHistory(text) {
            try {
                const history = getSearchHistory();
                const textLower = text.toLowerCase();
                const index = history.findIndex(item => item.toLowerCase() === textLower);
                
                if (index !== -1) {
                    // Remove from current position and add to top
                    history.splice(index, 1);
                    history.unshift(text);
                    localStorage.setItem('search_history', JSON.stringify(history));
                }
            } catch (error) {
                console.error('Error moving to top of history:', error);
            }
        }

        function getIconForSuggestion(text, forceClock = false) {
            try {
                const textLower = text.toLowerCase();
                
                // Force clock icon if specified (for random assignment)
                if (forceClock) {
                    return 'icons/clock.svg';
                }
                
                // Check if in search history
                if (isInSearchHistory(text)) {
                    return 'icons/clock.svg';
                }
                
                // AI suggestions always get search icon
                if (aiSuggestionsSet.has(textLower)) {
                    return 'icons/search.svg';
                }
                
                if (typeof iconMappings !== 'undefined' && iconMappings) {
                    if (iconMappings.lightning && iconMappings.lightning.includes(textLower)) {
                        return 'icons/lightning.svg';
                    } else if (iconMappings.search && iconMappings.search.includes(textLower)) {
                        return 'icons/search.svg';
                    }
                }
                return 'icons/search.svg';
            } catch (error) {
                console.error('Error in getIconForSuggestion:', error);
                return 'icons/search.svg';
            }
        }
        
        function showSkeletonLoaders(count = 3) {
            console.log('[Skeleton] showSkeletonLoaders called, count:', count);
            if (!suggestionsList) {
                console.log('[Skeleton] suggestionsList is null/undefined');
                return;
            }
            
            // Get current number of real suggestions (non-skeleton items)
            const existingItems = suggestionsList.querySelectorAll('.search-suggestions-preview-item:not(.skeleton)');
            const startRowIndex = existingItems.length; // Row position where skeletons will start (0-indexed)
            
            // Generate skeletons with fixed widths based on their row positions
            const skeletonHTML = Array.from({ length: count }, (_, i) => {
                const rowPosition = startRowIndex + i; // Actual row position (0-9 for rows 1-10)
                const width = skeletonWidths[rowPosition]; // Use fixed width for this row position
                return `
                    <li class="search-suggestions-preview-item skeleton" data-index="-1">
                        <div class="suggestion-icon" style="background-color: #E5E7EB; width: 16px; height: 16px; border-radius: 2px; opacity: 0.6; display: block; flex-shrink: 0;"></div>
                        <span class="skeleton-text" style="width: ${width}px; height: 14px; background-color: #E5E7EB; border-radius: 4px; opacity: 0.6; display: block;"></span>
                    </li>
                `;
            }).join('');
            
            console.log('[Skeleton] Generated HTML:', skeletonHTML);
            console.log('[Skeleton] Current innerHTML length:', suggestionsList.innerHTML.length);
            console.log('[Skeleton] Start row index:', startRowIndex, 'Skeleton count:', count);
            
            // Append skeletons to existing suggestions
            suggestionsList.innerHTML += skeletonHTML;
            
            console.log('[Skeleton] New innerHTML length:', suggestionsList.innerHTML.length);
            console.log('[Skeleton] Number of skeleton elements:', suggestionsList.querySelectorAll('.skeleton').length);
        }
        
        function removeSkeletons() {
            if (!suggestionsList) return;
            const skeletons = suggestionsList.querySelectorAll('.skeleton');
            skeletons.forEach(skeleton => skeleton.remove());
        }
        
        function updateSuggestions(suggestions) {
            console.log('updateSuggestions called with:', suggestions);
            console.log('suggestionsList:', suggestionsList);
            if (!suggestionsList) {
                console.log('suggestionsList is null/undefined, returning early');
                return;
            }
            
            // Remove any existing skeletons when updating with real suggestions
            removeSkeletons();
            
            // Check if these are the default suggestions - if so, ensure they're all in history
            const defaultSuggestions = ['hoka', 'macbook', '13 in macbook air', 'Coffee machines for sale', 'taylor swift', 'coffee grinder', 'gmail'];
            const isDefaultSuggestions = suggestions.length === defaultSuggestions.length && 
                suggestions.every(s => defaultSuggestions.some(ds => ds.toLowerCase() === s.toLowerCase()));
            
            if (isDefaultSuggestions) {
                // Add all default suggestions to history if not already there
                defaultSuggestions.forEach(suggestion => {
                    if (!isInSearchHistory(suggestion)) {
                        saveToSearchHistory(suggestion);
                    }
                });
            }
            
            console.log('Sorting suggestions...');
            try {
                // Get current search value for highlighting
                const searchValue = searchBoxElement ? searchBoxElement.value.toLowerCase() : '';
                const searchValueTrimmed = searchBoxElement ? searchBoxElement.value.trim() : '';
                console.log('Search value for highlighting:', searchValue);
                
                // Separate suggestions into history and non-history
                const historySuggestions = [];
                const nonHistorySuggestions = [];
                
                suggestions.forEach(suggestion => {
                    // Skip typed text - it will be added separately
                    if (searchValueTrimmed && suggestion.toLowerCase() === searchValueTrimmed.toLowerCase()) {
                        return;
                    }
                    
                    if (isInSearchHistory(suggestion)) {
                        historySuggestions.push(suggestion);
                        // Move to top of history when shown
                        moveToTopOfHistory(suggestion);
                    } else {
                        nonHistorySuggestions.push(suggestion);
                    }
                });
                
                // Only randomly assign clock icons if there are NO history items in the current list
                const suggestionsToMarkWithClock = [];
                if (historySuggestions.length === 0) {
                    // Randomly assign clock icons to 1-3 suggestions from non-history
                    const clockCount = Math.floor(Math.random() * 3) + 1; // 1-3
                    const availableSuggestions = [...nonHistorySuggestions];
                    
                    for (let i = 0; i < clockCount && availableSuggestions.length > 0; i++) {
                        const randomIndex = Math.floor(Math.random() * availableSuggestions.length);
                        const selected = availableSuggestions.splice(randomIndex, 1)[0];
                        suggestionsToMarkWithClock.push(selected);
                        // Save to history
                        saveToSearchHistory(selected);
                    }
                }
                
                // Sort history suggestions by icon type (lightning first, then clock)
                const sortedHistory = historySuggestions.sort((a, b) => {
                    try {
                        const iconA = getIconForSuggestion(a);
                        const iconB = getIconForSuggestion(b);
                        const iconOrder = {
                            'icons/lightning.svg': 0,
                            'icons/clock.svg': 1,
                            'icons/search.svg': 2
                        };
                        return (iconOrder[iconA] || 2) - (iconOrder[iconB] || 2);
                    } catch (e) {
                        return 0;
                    }
                });
                
                // Sort non-history suggestions by icon type
                const sortedNonHistory = nonHistorySuggestions.sort((a, b) => {
                    try {
                        const aIsForcedClock = suggestionsToMarkWithClock.some(s => s.toLowerCase() === a.toLowerCase());
                        const bIsForcedClock = suggestionsToMarkWithClock.some(s => s.toLowerCase() === b.toLowerCase());
                        const iconA = getIconForSuggestion(a, aIsForcedClock);
                        const iconB = getIconForSuggestion(b, bIsForcedClock);
                        const iconOrder = {
                            'icons/lightning.svg': 0,
                            'icons/clock.svg': 1,
                            'icons/search.svg': 2
                        };
                        return (iconOrder[iconA] || 2) - (iconOrder[iconB] || 2);
                    } catch (e) {
                        return 0;
                    }
                });
                
                // Combine: history first, then non-history
                const sortedSuggestions = [...sortedHistory, ...sortedNonHistory];
                
                console.log('Sorted suggestions:', sortedSuggestions.length);
                
                // Prepend the typed text as the first suggestion if there's text
                // Check case-insensitively to avoid duplicates
                const typedTextInSuggestions = sortedSuggestions.some(s => s.toLowerCase() === searchValueTrimmed.toLowerCase());
                const suggestionsToShow = searchValueTrimmed && !typedTextInSuggestions
                    ? [searchValueTrimmed, ...sortedSuggestions]
                    : sortedSuggestions;
                
                console.log('Mapping suggestions to HTML...');
                const htmlString = suggestionsToShow.map((text, index) => {
                // First suggestion (typed text) - check if it's in history
                const isTypedText = index === 0 && searchValueTrimmed && text === searchValueTrimmed;
                
                // Check if this suggestion was randomly assigned clock icon (for new additions)
                const isForcedClock = suggestionsToMarkWithClock.some(s => s.toLowerCase() === text.toLowerCase());
                // Check if it's in history (will also get clock icon)
                const isInHistory = isInSearchHistory(text);
                
                // For typed text, show clock if in history, otherwise search icon
                const icon = isTypedText 
                    ? (isInSearchHistory(text) ? 'icons/clock.svg' : 'icons/search.svg')
                    : getIconForSuggestion(text, isForcedClock);
                
                // Bold matching characters (ignore spaces in search value)
                // Skip bolding for the typed text itself (first item)
                let displayText = text;
                if (searchValue && !isTypedText) {
                    const searchNoSpaces = searchValue.replace(/\s/g, '');
                    const textLower = text.toLowerCase();
                    const textNoSpaces = textLower.replace(/\s/g, '');
                    const matchIndex = textNoSpaces.indexOf(searchNoSpaces);
                    
                    if (matchIndex !== -1) {
                        // Find the actual position in the original text
                        let charCount = 0;
                        let startIndex = -1;
                        let endIndex = -1;
                        
                        for (let i = 0; i < text.length; i++) {
                            if (text[i] !== ' ') {
                                if (charCount === matchIndex) {
                                    startIndex = i;
                                }
                                if (charCount === matchIndex + searchNoSpaces.length - 1) {
                                    endIndex = i + 1;
                                    break;
                                }
                                charCount++;
                            }
                        }
                        
                        if (startIndex !== -1 && endIndex !== -1) {
                            const before = text.substring(0, startIndex);
                            const match = text.substring(startIndex, endIndex);
                            const after = text.substring(endIndex);
                            displayText = `${before}<strong>${match}</strong>${after}`;
                        }
                    }
                }
                
                return `
                    <li class="search-suggestions-preview-item" data-index="${index}">
                        <img src="${icon}" alt="" aria-hidden="true" class="suggestion-icon">
                        <span class="label">${displayText}</span>
                        <span class="search-hint" style="display: none;">&nbsp;•&nbsp;&nbsp;Search with Google</span>
                    </li>
                `;
                }).join('');
                
                // If query is "chair", "ramen", "sushi", or "coffee shops", insert carrot as second item (after typed text)
                const queryLower = searchValueTrimmed.toLowerCase();
                const isAdMarketplaceQuery = queryLower === 'chair' || queryLower === 'ramen' || queryLower === 'sushi';
                // Check if query matches "coffee shops" (exact or partial match that would trigger the carrot)
                const isCoffeeShopsQuery = queryLower === 'coffee shops' || (queryLower.startsWith('coffee sh') && queryLower.length >= 10);
                // Check if query matches "lakers game" (exact or partial match that would trigger the carrot)
                const isLakersGameQuery = queryLower === 'lakers game' || (queryLower.startsWith('lakers') && queryLower.length >= 7);
                let finalHtml = htmlString;
                if (isAdMarketplaceQuery) {
                    let adMarketplaceCarrotHtml;
                    if (queryLower === 'chair') {
                        adMarketplaceCarrotHtml = carrotTemplates.adMarketplace();
                    } else if (queryLower === 'ramen') {
                        adMarketplaceCarrotHtml = carrotTemplates.adMarketplaceRamen();
                    } else if (queryLower === 'sushi') {
                        adMarketplaceCarrotHtml = carrotTemplates.adMarketplaceSushi();
                    }
                    // Insert ad marketplace carrot after first item (typed text)
                    const firstItemEnd = htmlString.indexOf('</li>');
                    if (firstItemEnd !== -1 && adMarketplaceCarrotHtml) {
                        finalHtml = htmlString.substring(0, firstItemEnd + 5) + adMarketplaceCarrotHtml + htmlString.substring(firstItemEnd + 5);
                    } else if (adMarketplaceCarrotHtml) {
                        finalHtml = htmlString + adMarketplaceCarrotHtml;
                    }
                } else if (isCoffeeShopsQuery) {
                    // Insert coffee shops carrot after first item (typed text)
                    // Insert both coffee shop items directly - CSS will display them side by side
                    const coffeeShopsCarrotHtml = carrotTemplates.local();
                    const firstItemEnd = htmlString.indexOf('</li>');
                    if (firstItemEnd !== -1) {
                        finalHtml = htmlString.substring(0, firstItemEnd + 5) + coffeeShopsCarrotHtml + htmlString.substring(firstItemEnd + 5);
                    } else {
                        finalHtml = htmlString + coffeeShopsCarrotHtml;
                    }
                } else if (queryLower === 'uber stock' || (queryLower.startsWith('uber sto') && queryLower.length >= 8)) {
                    // Insert stocks carrot after first item (typed text)
                    // Insert all three stock items directly - CSS will display them side by side
                    const stocksCarrotHtml = carrotTemplates.stocks();
                    const firstItemEnd = htmlString.indexOf('</li>');
                    if (firstItemEnd !== -1) {
                        finalHtml = htmlString.substring(0, firstItemEnd + 5) + stocksCarrotHtml + htmlString.substring(firstItemEnd + 5);
                    } else {
                        finalHtml = htmlString + stocksCarrotHtml;
                    }
                } else if (queryLower === 'stocks') {
                    // Insert stocks ETFs carrot after first item (typed text)
                    // Insert all three ETF items directly - CSS will display them side by side
                    const stocksETFsCarrotHtml = carrotTemplates.stocksETFs();
                    const firstItemEnd = htmlString.indexOf('</li>');
                    if (firstItemEnd !== -1) {
                        finalHtml = htmlString.substring(0, firstItemEnd + 5) + stocksETFsCarrotHtml + htmlString.substring(firstItemEnd + 5);
                    } else {
                        finalHtml = htmlString + stocksETFsCarrotHtml;
                    }
                } else if (isLakersGameQuery) {
                    // Insert sports carrot after first item (typed text)
                    // Insert all three sports items directly - CSS will display them side by side
                    const sportsCarrotHtml = carrotTemplates.sports();
                    const firstItemEnd = htmlString.indexOf('</li>');
                    if (firstItemEnd !== -1) {
                        finalHtml = htmlString.substring(0, firstItemEnd + 5) + sportsCarrotHtml + htmlString.substring(firstItemEnd + 5);
                    } else {
                        finalHtml = htmlString + sportsCarrotHtml;
                    }
                } else if (isLakersGameQuery) {
                    // Insert sports carrot after first item (typed text)
                    // Insert all three sports items directly - CSS will display them side by side
                    const sportsCarrotHtml = carrotTemplates.sports();
                    const firstItemEnd = htmlString.indexOf('</li>');
                    if (firstItemEnd !== -1) {
                        finalHtml = htmlString.substring(0, firstItemEnd + 5) + sportsCarrotHtml + htmlString.substring(firstItemEnd + 5);
                    } else {
                        finalHtml = htmlString + sportsCarrotHtml;
                    }
                }
                
                console.log('Generated HTML length:', finalHtml.length);
                console.log('Generated HTML preview:', finalHtml.substring(0, 200));
                console.log('About to set innerHTML...');
                suggestionsList.innerHTML = finalHtml;
                console.log('innerHTML set, new innerHTML length:', suggestionsList.innerHTML.length);
                console.log('Number of child elements:', suggestionsList.children.length);
            } catch (error) {
                console.error('Error in updateSuggestions:', error);
                console.error('Error stack:', error.stack);
            }
            
            // Set first suggestion as selected by default only if there's text typed
            const suggestionItems = suggestionsList.querySelectorAll('.search-suggestions-preview-item');
            const hasTypedText = searchBoxElement && searchBoxElement.value.trim().length > 0;
            if (suggestionItems.length > 0 && hasTypedText) {
                selectedSuggestionIndex = 0;
                // Enable keyboard navigation mode to prevent hover from interfering
                suggestionsList.classList.add('keyboard-navigating');
            } else {
                selectedSuggestionIndex = -1;
                suggestionsList.classList.remove('keyboard-navigating');
            }
            updateSelectedSuggestion();
            
            // Mark that suggestions were just updated to prevent stale hover
            suggestionsJustUpdated = true;
            // Clear the flag after a short delay to allow mouse movement to be detected
            setTimeout(() => {
                suggestionsJustUpdated = false;
            }, 100);
            
            // Attach click handlers to suggestions (this clones nodes, so do it first)
            attachClickListeners();
            
            // Attach hover listeners to the new suggestions (after click listeners)
            attachHoverListeners();
            
            // Attach pin button handlers for stocks and sports items
            attachPinButtonHandlersForSuggestions();
            
        }
        
        function attachPinButtonHandlersForSuggestions() {
            if (!suggestionsList) return;
            
            const pinButtons = suggestionsList.querySelectorAll('.carrot-pin-button');
            pinButtons.forEach(button => {
                // Remove any existing listeners by cloning the button
                const newButton = button.cloneNode(true);
                button.replaceWith(newButton);
                
                newButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Find the parent stock-item or sports-item
                    const stockItem = newButton.closest('.stock-item');
                    const sportsItem = newButton.closest('.sports-item');
                    
                    if (stockItem) {
                        console.log('[PIN] Pin button clicked for stock item');
                        const pinnedCard = replaceThirdCardWithStock(stockItem);
                        handlePinSuccess(pinnedCard);
                    } else if (sportsItem) {
                        console.log('[PIN] Pin button clicked for sports item');
                        const pinnedCard = replaceThirdCardWithSports(sportsItem);
                        handlePinSuccess(pinnedCard);
                    }
                });
            });
        }
        
        // COMMENTED OUT: Google search functionality disabled
        // function performGoogleSearch(suggestionText) {
        //     if (!suggestionText || !suggestionText.trim()) return;
        //     const searchUrl = `https://www.google.com/search?q=${encodeURIComponent(suggestionText.trim())}`;
        //     window.open(searchUrl, '_blank');
        // }
        
        function attachClickListeners() {
            if (!suggestionsList) return;
            
            const suggestionItems = suggestionsList.querySelectorAll('.search-suggestions-preview-item:not(.skeleton)');
            suggestionItems.forEach((item) => {
                // Remove existing click listener if any
                const newItem = item.cloneNode(true);
                item.parentNode.replaceChild(newItem, item);
                
                // Add click handler
                newItem.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // COMMENTED OUT: Google search on click disabled
                    // Get the suggestion text from the label
                    // const labelElement = newItem.querySelector('.label');
                    // if (labelElement) {
                    //     // Get text content, removing any HTML tags (like <strong>)
                    //     const suggestionText = labelElement.textContent.trim();
                    //     performGoogleSearch(suggestionText);
                    // }
                });
            });
        }
        
        function attachHoverListeners() {
            if (!suggestionsList) return;
            
            const suggestionItems = suggestionsList.querySelectorAll('.search-suggestions-preview-item');
            suggestionItems.forEach((item, index) => {
                item.addEventListener('mouseenter', handleSuggestionHover);
                
                // For local business items, attach hover to the business divs
                // Both businesses are now in a single <li>, so we need to handle them separately
                if (item.classList.contains('local-business-wrapper')) {
                    const businessDivs = item.querySelectorAll('.local-business');
                    businessDivs.forEach((businessDiv, divIndex) => {
                        businessDiv.addEventListener('mouseenter', (e) => {
                            e.stopPropagation();
                            // Ignore hover if suggestions were just updated or keyboard navigating
                            if (suggestionsJustUpdated || suggestionsList.classList.contains('keyboard-navigating')) {
                                return;
                            }
                            // Set the selected index based on which business div is hovered
                            // We need to find the index of this list item, then add the divIndex
                            const allItems = Array.from(suggestionsList.querySelectorAll('.search-suggestions-preview-item'));
                            const itemIndex = allItems.indexOf(item);
                            // For coffee shops, the first business is at itemIndex, second is at itemIndex + 1
                            // But since they're in the same <li>, we need to track them separately
                            // Use a custom approach: store the business index on the div
                            const businessIndex = parseInt(businessDiv.dataset.businessIndex || '0');
                            // Calculate the actual suggestion index
                            // If this is the coffee shops item, first business = itemIndex, second = itemIndex + 1
                            const actualIndex = itemIndex + businessIndex;
                            selectedSuggestionIndex = actualIndex;
                            updateSelectedSuggestion();
                        });
                    });
                }
                
                // For stocks items, attach hover to the stock divs
                // All three stocks are now in a single <li>, so we need to handle them separately
                if (item.classList.contains('stocks-wrapper')) {
                    const stockDivs = item.querySelectorAll('.stock-item');
                    stockDivs.forEach((stockDiv, divIndex) => {
                        stockDiv.addEventListener('mouseenter', (e) => {
                            e.stopPropagation();
                            // Ignore hover if suggestions were just updated or keyboard navigating
                            if (suggestionsJustUpdated || suggestionsList.classList.contains('keyboard-navigating')) {
                                return;
                            }
                            // Set the selected index based on which stock div is hovered
                            const allItems = Array.from(suggestionsList.querySelectorAll('.search-suggestions-preview-item'));
                            const itemIndex = allItems.indexOf(item);
                            // For stocks, first stock = itemIndex, second = itemIndex + 1, third = itemIndex + 2
                            const stockIndex = parseInt(stockDiv.dataset.stockIndex || '0');
                            const actualIndex = itemIndex + stockIndex;
                            selectedSuggestionIndex = actualIndex;
                            updateSelectedSuggestion();
                        });
                    });
                }
                
                // For sports items, attach hover to the sports divs
                // All three sports items are now in a single <li>, so we need to handle them separately
                if (item.classList.contains('sports-wrapper')) {
                    const sportsDivs = item.querySelectorAll('.sports-item');
                    sportsDivs.forEach((sportsDiv, divIndex) => {
                        sportsDiv.addEventListener('mouseenter', (e) => {
                            e.stopPropagation();
                            // Ignore hover if suggestions were just updated or keyboard navigating
                            if (suggestionsJustUpdated || suggestionsList.classList.contains('keyboard-navigating')) {
                                return;
                            }
                            // Set the selected index based on which sports div is hovered
                            const allItems = Array.from(suggestionsList.querySelectorAll('.search-suggestions-preview-item'));
                            const itemIndex = allItems.indexOf(item);
                            // For sports, first item = itemIndex, second = itemIndex + 1, third = itemIndex + 2
                            const sportsIndex = parseInt(sportsDiv.dataset.sportsIndex || '0');
                            const actualIndex = itemIndex + sportsIndex;
                            selectedSuggestionIndex = actualIndex;
                            updateSelectedSuggestion();
                        });
                    });
                }
            });
            
            // Clear selection when mouse leaves the suggestions list
            const suggestionsContainer = suggestionsList.closest('.search-suggestions-preview-column-container');
            if (suggestionsContainer) {
                suggestionsContainer.addEventListener('mouseleave', () => {
                    selectedSuggestionIndex = -1;
                    suggestionsList.classList.remove('keyboard-navigating');
                    updateSelectedSuggestion();
                });
            }
            
            // Reset keyboard navigation flag when mouse moves (allows hover to work again)
            suggestionsList.addEventListener('mousemove', () => {
                suggestionsList.classList.remove('keyboard-navigating');
            });
        }
        
        function handleSuggestionHover(event) {
            if (!suggestionsList) return;
            
            // Ignore hover if suggestions were just updated or keyboard navigating (prevents stale hover from mouse already being over an item)
            if (suggestionsJustUpdated || suggestionsList.classList.contains('keyboard-navigating')) {
                return;
            }
            
            const suggestionItems = suggestionsList.querySelectorAll('.search-suggestions-preview-item');
            const item = event.currentTarget;
            
            // If hovering over a carrot, clear the selection
            if (item.classList.contains('carrot')) {
                selectedSuggestionIndex = -1;
                updateSelectedSuggestion();
                return;
            }
            
            // Calculate virtual index (accounting for coffee shops counting as 2 items and stocks counting as 3 items)
            const itemIndex = Array.from(suggestionItems).indexOf(item);
            if (itemIndex >= 0) {
                let virtualIndex = 0;
                for (let i = 0; i < itemIndex; i++) {
                    const currentItem = suggestionItems[i];
                    if (currentItem.classList.contains('local-business-wrapper')) {
                        const businessDivs = currentItem.querySelectorAll('.local-business');
                        if (businessDivs.length === 2) {
                            // Coffee shops item - counts as 2 virtual items
                            virtualIndex += 2;
                        } else {
                            // Regular local business - counts as 1
                            virtualIndex += 1;
                        }
                    } else if (currentItem.classList.contains('stocks-wrapper')) {
                        const stockDivs = currentItem.querySelectorAll('.stock-item');
                        // Stocks item - count each stock div as a virtual item
                        virtualIndex += stockDivs.length > 0 ? stockDivs.length : 1;
                    } else if (currentItem.classList.contains('sports-wrapper')) {
                        const sportsDivs = currentItem.querySelectorAll('.sports-item');
                        // Sports item - count each sports div as a virtual item
                        virtualIndex += sportsDivs.length > 0 ? sportsDivs.length : 1;
                    } else {
                        // Regular suggestion - counts as 1
                        virtualIndex += 1;
                    }
                }
                // For the hovered item itself, if it's coffee shops or stocks, determine which sub-item
                if (item.classList.contains('local-business-wrapper')) {
                    const businessDivs = item.querySelectorAll('.local-business');
                    if (businessDivs.length === 2) {
                        // This is coffee shops - default to first business (index 0)
                        // The business div hover handler will override this
                        selectedSuggestionIndex = virtualIndex;
                    } else {
                        selectedSuggestionIndex = virtualIndex;
                    }
                } else if (item.classList.contains('stocks-wrapper')) {
                    const stockDivs = item.querySelectorAll('.stock-item');
                    // This is stocks - default to first stock (index 0)
                    // The stock div hover handler will override this
                    selectedSuggestionIndex = virtualIndex;
                } else if (item.classList.contains('sports-wrapper')) {
                    const sportsDivs = item.querySelectorAll('.sports-item');
                    // This is sports - default to first sports item (index 0)
                    // The sports div hover handler will override this
                    selectedSuggestionIndex = virtualIndex;
                } else {
                    selectedSuggestionIndex = virtualIndex;
                }
                updateSelectedSuggestion();
            }
        }
        
        function updateSelectedSuggestion(isKeyboardNavigation = false) {
            if (!suggestionsList) return;
            
            // Add/remove class to disable hover styles during keyboard navigation
            if (isKeyboardNavigation) {
                suggestionsList.classList.add('keyboard-navigating');
            } else {
                suggestionsList.classList.remove('keyboard-navigating');
            }
            
            const suggestionItems = suggestionsList.querySelectorAll('.search-suggestions-preview-item');
            
            // Remove selection from ALL items first
            suggestionItems.forEach((item) => {
                item.classList.remove('is-selected');
                // Also remove selected state from local-business divs (for side-by-side coffee shops)
                const localBusinesses = item.querySelectorAll('.local-business');
                localBusinesses.forEach((business) => {
                    business.classList.remove('local-business--selected');
                });
                // Also remove selected state from stock-item divs (for side-by-side stocks)
                const stockItems = item.querySelectorAll('.stock-item');
                stockItems.forEach((stock) => {
                    stock.classList.remove('stock-item--selected');
                });
                // Also remove selected state from sports-item divs (for side-by-side sports)
                const sportsItems = item.querySelectorAll('.sports-item');
                sportsItems.forEach((sports) => {
                    sports.classList.remove('sports-item--selected');
                });
                // Hide "Search with Google" hint
                const hintElement = item.querySelector('.search-hint');
                if (hintElement) {
                    hintElement.style.display = 'none';
                }
            });
            
            // Calculate total virtual items (accounting for coffee shops having 2 businesses and stocks having 3 items)
            let virtualItemCount = 0;
            const virtualItemMap = []; // Maps virtual index to [itemIndex, businessIndex/stockIndex]
            suggestionItems.forEach((item, itemIndex) => {
                if (item.classList.contains('local-business-wrapper')) {
                    const businessDivs = item.querySelectorAll('.local-business');
                    if (businessDivs.length === 2) {
                        // Coffee shops item - counts as 2 virtual items
                        virtualItemMap.push([itemIndex, 0]); // First business
                        virtualItemMap.push([itemIndex, 1]); // Second business
                        virtualItemCount += 2;
                    } else {
                        // Regular local business - counts as 1
                        virtualItemMap.push([itemIndex, 0]);
                        virtualItemCount += 1;
                    }
                } else if (item.classList.contains('stocks-wrapper')) {
                    const stockDivs = item.querySelectorAll('.stock-item');
                    // Stocks item - each stock div counts as a virtual item
                    stockDivs.forEach((stockDiv, stockIndex) => {
                        virtualItemMap.push([itemIndex, stockIndex]);
                        virtualItemCount += 1;
                    });
                    // If no stock divs found, treat as single item
                    if (stockDivs.length === 0) {
                        virtualItemMap.push([itemIndex, -1]);
                        virtualItemCount += 1;
                    }
                } else if (item.classList.contains('sports-wrapper')) {
                    const sportsDivs = item.querySelectorAll('.sports-item');
                    // Sports item - each sports div counts as a virtual item
                    sportsDivs.forEach((sportsDiv, sportsIndex) => {
                        virtualItemMap.push([itemIndex, sportsIndex]);
                        virtualItemCount += 1;
                    });
                    // If no sports divs found, treat as single item
                    if (sportsDivs.length === 0) {
                        virtualItemMap.push([itemIndex, -1]);
                        virtualItemCount += 1;
                    }
                } else {
                    // Regular suggestion - counts as 1
                    virtualItemMap.push([itemIndex, -1]); // -1 means no sub-item div
                    virtualItemCount += 1;
                }
            });
            
            // Then add selection to ONLY the selected item (if one is selected)
            if (selectedSuggestionIndex >= 0 && selectedSuggestionIndex < virtualItemCount) {
                const [itemIndex, businessIndex] = virtualItemMap[selectedSuggestionIndex];
                const selectedItem = suggestionItems[itemIndex];
                selectedItem.classList.add('is-selected');
                
                // For coffee shops item, highlight the specific business div
                if (selectedItem.classList.contains('local-business-wrapper') && businessIndex >= 0) {
                    const businessDivs = selectedItem.querySelectorAll('.local-business');
                    if (businessDivs[businessIndex]) {
                        businessDivs[businessIndex].classList.add('local-business--selected');
                    }
                }
                // For stocks item, highlight the specific stock div
                if (selectedItem.classList.contains('stocks-wrapper') && businessIndex >= 0) {
                    const stockDivs = selectedItem.querySelectorAll('.stock-item');
                    if (stockDivs[businessIndex]) {
                        stockDivs[businessIndex].classList.add('stock-item--selected');
                    }
                }
                
                if (selectedItem.classList.contains('sports-wrapper') && businessIndex >= 0) {
                    const sportsDivs = selectedItem.querySelectorAll('.sports-item');
                    if (sportsDivs[businessIndex]) {
                        sportsDivs[businessIndex].classList.add('sports-item--selected');
                    }
                }
                
                // Show "Search with Google" hint
                const hintElement = selectedItem.querySelector('.search-hint');
                if (hintElement) {
                    hintElement.style.display = 'inline';
                }
                
                // If this is keyboard navigation, update the search box text
                if (isKeyboardNavigation && searchBoxElement) {
                    const label = selectedItem.querySelector('.label');
                    if (label) {
                        // Extract text without HTML tags (removes <strong> tags but keeps text)
                        const suggestionText = label.textContent || label.innerText;
                        searchBoxElement.value = suggestionText.trim();
                    }
                }
            }
        }
        
        
        function setCarrotContent(state, amountOrTerm, fromCurrencyOrTargetLanguage, toCurrencyOrTranslation) {
            if (!carrotList) {
                return;
            }

            // Use templates from carrot-templates.js
            switch(state) {
                case 0:
                    carrotList.innerHTML = carrotTemplates.local();
                    break;
                case 1:
                    carrotList.innerHTML = carrotTemplates.flights();
                    break;
                case 2:
                    carrotList.innerHTML = carrotTemplates.wikipedia();
                    break;
                case 3:
                    carrotList.innerHTML = carrotTemplates.placeholder();
                    break;
                case 4:
                    carrotList.innerHTML = carrotTemplates.weather();
                    // Attach pin button handler for weather
                    setTimeout(() => {
                        attachPinButtonHandler(4);
                    }, 0);
                    break;
                case 5:
                    carrotList.innerHTML = carrotTemplates.sports();
                    break;
                case 6:
                    carrotList.innerHTML = carrotTemplates.stocks();
                    break;
                case 20:
                    carrotList.innerHTML = carrotTemplates.stocksETFs();
                    break;
                case 7:
                    carrotList.innerHTML = carrotTemplates.worldClock();
                    // Attach pin button handler for world clock
                    setTimeout(() => {
                        attachPinButtonHandler(7);
                    }, 0);
                    break;
                case 8:
                    carrotList.innerHTML = carrotTemplates.adMarketplace();
                    break;
                case 18:
                    carrotList.innerHTML = carrotTemplates.adMarketplaceRamen();
                    break;
                case 19:
                    carrotList.innerHTML = carrotTemplates.adMarketplaceSushi();
                    break;
                case 9:
                    carrotList.innerHTML = carrotTemplates.bigAd();
                    break;
                case 10:
                    carrotList.innerHTML = carrotTemplates.mdn();
                    break;
                case 11:
                    carrotList.innerHTML = carrotTemplates.happyEmoji();
                    // Add click handlers for emoji copying
                    setTimeout(() => {
                        const emojiItems = carrotList.querySelectorAll('.emoji-item');
                        emojiItems.forEach(item => {
                            item.addEventListener('click', () => {
                                const emoji = item.getAttribute('data-emoji');
                                if (emoji && navigator.clipboard) {
                                    navigator.clipboard.writeText(emoji).then(() => {
                                        // Visual feedback could be added here
                                    }).catch(err => {
                                        console.error('Failed to copy emoji:', err);
                                    });
                                }
                            });
                        });
                    }, 0);
                    break;
                case 12:
                    carrotList.innerHTML = carrotTemplates.youtube();
                    break;
                case 13:
                    carrotList.innerHTML = carrotTemplates.vpn();
                    // Add toggle functionality
                    setTimeout(() => {
                        const toggleInput = carrotList.querySelector('.vpn-toggle-input');
                        const statusIndicator = carrotList.querySelector('.vpn-status-indicator');
                        const statusText = carrotList.querySelector('.vpn-status-text');
                        const vpnIndicator = document.getElementById('vpn-indicator');
                        
                        if (toggleInput) {
                            toggleInput.addEventListener('change', (e) => {
                                if (e.target.checked) {
                                    statusIndicator.classList.remove('vpn-status-indicator--off');
                                    statusIndicator.classList.add('vpn-status-indicator--on');
                                    statusText.textContent = 'VPN is on';
                                    if (vpnIndicator) {
                                        vpnIndicator.classList.add('is-active');
                                    }
                                } else {
                                    statusIndicator.classList.remove('vpn-status-indicator--on');
                                    statusIndicator.classList.add('vpn-status-indicator--off');
                                    statusText.textContent = 'VPN is off';
                                    if (vpnIndicator) {
                                        vpnIndicator.classList.remove('is-active');
                                    }
                                }
                            });
                        }
                    }, 0);
                    break;
                case 14:
                    carrotList.innerHTML = carrotTemplates.currency(amountOrTerm, fromCurrencyOrTargetLanguage, toCurrencyOrTranslation);
                    break;
                case 15:
                    carrotList.innerHTML = carrotTemplates.translation(amountOrTerm, fromCurrencyOrTargetLanguage, toCurrencyOrTranslation);
                    break;
                case 16:
                    carrotList.innerHTML = carrotTemplates.renewableEnergy();
                    // Load the image for the renewable energy card
                    setTimeout(async () => {
                        const placeholder = carrotList.querySelector('.carrot--story-card .image-placeholder');
                        if (placeholder) {
                            try {
                                const response = await fetch(`https://api.pexels.com/v1/search?query=${encodeURIComponent('renewable energy')}&per_page=1`, {
                                    headers: {
                                        Authorization: 'bCm88s2aE42pgTVWHJn6CRvAf916qPGquNowlZue6tSbVSImQ0hdsWSX'
                                    }
                                });
                                if (response.ok) {
                                    const data = await response.json();
                                    const photoUrl = data.photos && data.photos[0] ? data.photos[0].src.medium : null;
                                    if (photoUrl) {
                                        const img = document.createElement('img');
                                        img.src = photoUrl;
                                        img.alt = 'Breakthroughs in Renewable Energy';
                                        img.style.width = '100%';
                                        img.style.height = '120px';
                                        img.style.objectFit = 'cover';
                                        placeholder.replaceWith(img);
                                    }
                                }
                            } catch (error) {
                                console.error('Error loading renewable energy image:', error);
                            }
                        }
                    }, 0);
                    break;
                default:
                    console.warn(`Unknown carrot state: ${state}`);
            }

            carrotList.dataset.carrotState = String(state);
        }
        
        function attachPinButtonHandler(carrotState) {
            if (!carrotList) return;
            
            const pinButtons = carrotList.querySelectorAll('.carrot-pin-button');
            pinButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Handle world clock carrot (state 7)
                    if (carrotState === 7) {
                        console.log('[PIN] Pin button clicked for world clock carrot');
                        const pinnedCard = replaceThirdCardWithWorldClock();
                        handlePinSuccess(pinnedCard);
                    }
                    // Handle stocks carrot
                    else {
                        // Find the parent stock-item or sports-item
                        const stockItem = button.closest('.stock-item');
                        const sportsItem = button.closest('.sports-item');
                        
                        if (stockItem) {
                            console.log('[PIN] Pin button clicked for stock item');
                            const pinnedCard = replaceThirdCardWithStock(stockItem);
                            handlePinSuccess(pinnedCard);
                        } else if (sportsItem) {
                            console.log('[PIN] Pin button clicked for sports item');
                            const pinnedCard = replaceThirdCardWithSports(sportsItem);
                            handlePinSuccess(pinnedCard);
                        }
                    }
                });
            });
            
            // Handle weather pin button (state 4)
            if (carrotState === 4) {
                const weatherPinButton = carrotList.querySelector('.weather-pin-button');
                if (weatherPinButton) {
                    // Remove any existing listeners by cloning the button
                    const newButton = weatherPinButton.cloneNode(true);
                    weatherPinButton.replaceWith(newButton);
                    
                    newButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('[PIN] Pin button clicked for weather carrot');
                        const pinnedCard = replaceThirdCardWithWeather();
                        handlePinSuccess(pinnedCard);
                    });
                }
            }
        }
        
        function handlePinSuccess(pinnedCard) {
            if (pinnedCard) {
                console.log('[PIN] Pinned card element:', pinnedCard);
                
                // Close the overlay the same way as cross button or Esc
                const existingStyle = document.getElementById('gradient-animation-style');
                if (existingStyle) {
                    existingStyle.remove();
                }
                if (gradientAnimationId) {
                    cancelAnimationFrame(gradientAnimationId);
                    gradientAnimationId = null;
                }
                setOverlayState(false);
                if (searchBoxElement) {
                    searchBoxElement.blur();
                    // Clear the search term
                    searchBoxElement.value = '';
                }
                
                // Add border color
                pinnedCard.classList.add('card--pinned-flash');
            } else {
                console.log('[PIN] ERROR: pinnedCard is null or undefined');
            }
        }
        
        function replaceThirdCardWithWorldClock() {
            console.log('[REPLACE] replaceThirdCardWithWorldClock called');
            const articlesGrid = document.querySelector('.articles-grid');
            console.log('[REPLACE] articlesGrid:', articlesGrid);
            if (!articlesGrid) {
                console.log('[REPLACE] ERROR: articlesGrid not found');
                return;
            }
            
            const cards = articlesGrid.querySelectorAll('.card');
            console.log('[REPLACE] Found cards:', cards.length);
            if (cards.length < 3) {
                console.log('[REPLACE] ERROR: Not enough cards, found:', cards.length);
                return;
            }
            
            const thirdCard = cards[2]; // Third card (0-indexed)
            console.log('[REPLACE] Third card:', thirdCard);
            
            // Store the original card HTML for restoration
            const originalCardHTML = thirdCard.outerHTML;
            
            // Get the world clock HTML (fresh calculation)
            const worldClockHTML = carrotTemplates.worldClock();
            
            // Create a wrapper div for the clock content
            const clockWrapper = document.createElement('div');
            clockWrapper.className = 'card card--world-clock';
            clockWrapper.style.cssText = 'display: flex; align-items: center; justify-content: center; min-height: 200px; padding: 20px; background: white; border-radius: 12px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); border: 5px solid transparent; position: relative;';
            
            // Store the original card HTML for restoration
            clockWrapper.dataset.originalCard = originalCardHTML;
            
            // Add control buttons (grab icon and cross)
            const controlsDiv = createCardControls(clockWrapper);
            clockWrapper.appendChild(controlsDiv);
            
            // Extract just the clock content from the world clock template (remove the <li> wrapper)
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = worldClockHTML;
            const clockContent = tempDiv.querySelector('.carrot--clock');
            
            if (clockContent) {
                // Clone the clock content and remove the pin button
                const clonedContent = clockContent.cloneNode(true);
                const pinButton = clonedContent.querySelector('.carrot-pin-button');
                if (pinButton) {
                    pinButton.remove();
                }
                
                // Remove the carrot class styling that might conflict
                clonedContent.classList.remove('carrot');
                clonedContent.style.cssText = 'width: 100%;';
                
                clockWrapper.appendChild(clonedContent);
                console.log('[REPLACE] Replacing third card with clockWrapper');
                thirdCard.replaceWith(clockWrapper);
                console.log('[REPLACE] Replacement complete, returning clockWrapper:', clockWrapper);
                console.log('[REPLACE] clockWrapper classes:', clockWrapper.className);
                console.log('[REPLACE] clockWrapper styles:', clockWrapper.style.cssText);
                
                return clockWrapper;
            }
            console.log('[REPLACE] ERROR: clockContent not found');
            return null;
        }
        
        function replaceThirdCardWithStock(stockItem) {
            console.log('[REPLACE] replaceThirdCardWithStock called');
            const articlesGrid = document.querySelector('.articles-grid');
            if (!articlesGrid) {
                console.log('[REPLACE] ERROR: articlesGrid not found');
                return null;
            }
            
            const cards = articlesGrid.querySelectorAll('.card');
            if (cards.length < 3) {
                console.log('[REPLACE] ERROR: Not enough cards');
                return null;
            }
            
            const thirdCard = cards[2];
            const originalCardHTML = thirdCard.outerHTML;
            
            // Clone the stock item content
            const clonedStockItem = stockItem.cloneNode(true);
            const pinButton = clonedStockItem.querySelector('.carrot-pin-button');
            if (pinButton) {
                pinButton.remove();
            }
            
            // Create wrapper
            const stockWrapper = document.createElement('div');
            stockWrapper.className = 'card card--stock';
            stockWrapper.style.cssText = 'padding: 24px; background: white; border-radius: 12px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); border: 5px solid transparent; position: relative;';
            stockWrapper.dataset.originalCard = originalCardHTML;
            
            // Add controls
            const controlsDiv = createCardControls(stockWrapper);
            stockWrapper.appendChild(controlsDiv);
            
            // Add stock content - ensure it maintains flex layout
            clonedStockItem.style.cssText = '';
            stockWrapper.appendChild(clonedStockItem);
            
            thirdCard.replaceWith(stockWrapper);
            return stockWrapper;
        }
        
        function replaceThirdCardWithSports(sportsItem) {
            console.log('[REPLACE] replaceThirdCardWithSports called');
            const articlesGrid = document.querySelector('.articles-grid');
            if (!articlesGrid) {
                console.log('[REPLACE] ERROR: articlesGrid not found');
                return null;
            }
            
            const cards = articlesGrid.querySelectorAll('.card');
            if (cards.length < 3) {
                console.log('[REPLACE] ERROR: Not enough cards');
                return null;
            }
            
            const thirdCard = cards[2];
            const originalCardHTML = thirdCard.outerHTML;
            
            // Clone the sports item content
            const clonedSportsItem = sportsItem.cloneNode(true);
            const pinButton = clonedSportsItem.querySelector('.carrot-pin-button');
            if (pinButton) {
                pinButton.remove();
            }
            
            // Create wrapper
            const sportsWrapper = document.createElement('div');
            sportsWrapper.className = 'card card--sports';
            sportsWrapper.style.cssText = 'padding: 24px; background: white; border-radius: 12px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); border: 5px solid transparent; position: relative;';
            sportsWrapper.dataset.originalCard = originalCardHTML;
            
            // Add controls
            const controlsDiv = createCardControls(sportsWrapper);
            sportsWrapper.appendChild(controlsDiv);
            
            // Add sports content - ensure it maintains flex layout
            clonedSportsItem.style.cssText = '';
            sportsWrapper.appendChild(clonedSportsItem);
            
            thirdCard.replaceWith(sportsWrapper);
            return sportsWrapper;
        }
        
        function replaceThirdCardWithWeather() {
            console.log('[REPLACE] replaceThirdCardWithWeather called');
            const articlesGrid = document.querySelector('.articles-grid');
            if (!articlesGrid) {
                console.log('[REPLACE] ERROR: articlesGrid not found');
                return null;
            }
            
            const cards = articlesGrid.querySelectorAll('.card');
            if (cards.length < 3) {
                console.log('[REPLACE] ERROR: Not enough cards');
                return null;
            }
            
            const thirdCard = cards[2];
            const originalCardHTML = thirdCard.outerHTML;
            
            // Get the weather HTML (fresh calculation)
            const weatherHTML = carrotTemplates.weather();
            
            // Create a wrapper div for the weather content
            const weatherWrapper = document.createElement('div');
            weatherWrapper.className = 'card card--weather';
            weatherWrapper.style.cssText = 'min-height: 200px; padding: 20px; background: white; border-radius: 12px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); border: 5px solid transparent; position: relative;';
            weatherWrapper.dataset.originalCard = originalCardHTML;
            
            // Add control buttons (grab icon and cross)
            const controlsDiv = createCardControls(weatherWrapper);
            weatherWrapper.appendChild(controlsDiv);
            
            // Extract just the weather content from the weather template (remove the <li> wrapper)
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = weatherHTML;
            const weatherContent = tempDiv.querySelector('.carrot--weather');
            
            if (weatherContent) {
                // Clone the weather content and remove the pin button
                const clonedContent = weatherContent.cloneNode(true);
                const pinButton = clonedContent.querySelector('.weather-pin-button');
                if (pinButton) {
                    pinButton.remove();
                }
                
                // Remove the carrot class styling that might conflict
                clonedContent.classList.remove('carrot');
                clonedContent.style.cssText = 'width: 100%;';
                
                weatherWrapper.appendChild(clonedContent);
                console.log('[REPLACE] Replacing third card with weatherWrapper');
                thirdCard.replaceWith(weatherWrapper);
                return weatherWrapper;
            }
            console.log('[REPLACE] ERROR: weatherContent not found');
            return null;
        }
        
        function createCardControls(wrapper) {
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'card-controls';
            
            // Grab/move icon button
            const grabButton = document.createElement('button');
            grabButton.className = 'card-control-button';
            grabButton.type = 'button';
            grabButton.setAttribute('aria-label', 'Move card');
            grabButton.innerHTML = `
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M9 5C9 6.10457 8.10457 7 7 7C5.89543 7 5 6.10457 5 5C5 3.89543 5.89543 3 7 3C8.10457 3 9 3.89543 9 5Z" fill="#1F2933"/>
                    <path d="M19 5C19 6.10457 18.1046 7 17 7C15.8954 7 15 6.10457 15 5C15 3.89543 15.8954 3 17 3C18.1046 3 19 3.89543 19 5Z" fill="#1F2933"/>
                    <path d="M9 12C9 13.1046 8.10457 14 7 14C5.89543 14 5 13.1046 5 12C5 10.8954 5.89543 10 7 10C8.10457 10 9 10.8954 9 12Z" fill="#1F2933"/>
                    <path d="M19 12C19 13.1046 18.1046 14 17 14C15.8954 14 15 13.1046 15 12C15 10.8954 15.8954 10 17 10C18.1046 10 19 10.8954 19 12Z" fill="#1F2933"/>
                    <path d="M9 19C9 20.1046 8.10457 21 7 21C5.89543 21 5 20.1046 5 19C5 17.8954 5.89543 17 7 17C8.10457 17 9 17.8954 9 19Z" fill="#1F2933"/>
                    <path d="M19 19C19 20.1046 18.1046 21 17 21C15.8954 21 15 20.1046 15 19C15 17.8954 15.8954 17 17 17C18.1046 17 19 17.8954 19 19Z" fill="#1F2933"/>
                </svg>
            `;
            grabButton.style.cursor = 'grab';
            
            // Close/cross button
            const closeButton = document.createElement('button');
            closeButton.className = 'card-control-button';
            closeButton.type = 'button';
            closeButton.setAttribute('aria-label', 'Remove pinned card');
            closeButton.innerHTML = `
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M18 6L6 18M6 6l12 12" stroke="#1F2933" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            `;
            
            closeButton.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                restoreOriginalCard(wrapper);
            });
            
            controlsDiv.appendChild(grabButton);
            controlsDiv.appendChild(closeButton);
            return controlsDiv;
        }
        
        function restoreOriginalCard(pinnedCard) {
            const originalCardHTML = pinnedCard.dataset.originalCard;
            if (!originalCardHTML) return;
            
            // Create a temporary container to parse the HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = originalCardHTML;
            const originalCard = tempDiv.firstElementChild;
            
            if (originalCard) {
                pinnedCard.replaceWith(originalCard);
            }
        }
        
        if (debugButtons.length > 0 && suggestionsContainer && carrotList) {
            // Button 0 (index 0): No enriched content (suggestions only)
            debugButtons[0].addEventListener('click', () => {
                currentState = 0;
                suggestionsContainer.classList.add('expand-left');
                suggestionsContainer.classList.remove('show-carrot');
            });

            // Button 1 (index 1): Local recommendations (placeholder)
            debugButtons[1].addEventListener('click', () => {
                if (currentState !== 0) {
                    // Transition to 0 first
                    suggestionsContainer.classList.add('expand-left');
                    suggestionsContainer.classList.remove('show-carrot');
                    
                    // Wait for slide out, then change content while hidden, then slide in
                    setTimeout(() => {
                        setCarrotContent(0);
                        currentState = 1;
                        suggestionsContainer.classList.remove('expand-left');
                        suggestionsContainer.classList.add('show-carrot');
                    }, 400);
                } else {
                    setCarrotContent(0);
                    currentState = 1;
                    suggestionsContainer.classList.remove('expand-left');
                    suggestionsContainer.classList.add('show-carrot');
                }
            });

            // Button 2 (index 2): Flights (AC 8170)
            debugButtons[2].addEventListener('click', () => {
                if (currentState !== 0) {
                    // Transition to 0 first
                    suggestionsContainer.classList.add('expand-left');
                    suggestionsContainer.classList.remove('show-carrot');
                    
                    // Wait for slide out, then change content while hidden, then slide in
                    setTimeout(() => {
                        setCarrotContent(1);
                        currentState = 2;
                        suggestionsContainer.classList.remove('expand-left');
                        suggestionsContainer.classList.add('show-carrot');
                    }, 400);
                } else {
                    setCarrotContent(1);
                    setCarrotColor(null);
                    currentState = 2;
                    suggestionsContainer.classList.remove('expand-left');
                    suggestionsContainer.classList.add('show-carrot');
                }
            });

            // Button 3 (index 3): Wikipedia
            debugButtons[3].addEventListener('click', () => {
                if (currentState !== 0) {
                    // Transition to 0 first
                    suggestionsContainer.classList.add('expand-left');
                    suggestionsContainer.classList.remove('show-carrot');
                    
                    // Wait for slide out, then change content while hidden, then slide in
                    setTimeout(() => {
                        setCarrotContent(2);
                        currentState = 3;
                        suggestionsContainer.classList.remove('expand-left');
                        suggestionsContainer.classList.add('show-carrot');
                    }, 400);
                } else {
                    setCarrotContent(2);
                    setCarrotColor(null);
                    currentState = 3;
                    suggestionsContainer.classList.remove('expand-left');
                    suggestionsContainer.classList.add('show-carrot');
                }
            });

            // Button 4 (index 4): Weather
            debugButtons[4].addEventListener('click', () => {
                if (currentState !== 0) {
                    // Transition to 0 first
                    suggestionsContainer.classList.add('expand-left');
                    suggestionsContainer.classList.remove('show-carrot');
                    
                    // Wait for slide out, then change content while hidden, then slide in
                    setTimeout(() => {
                        setCarrotContent(4);
                        currentState = 4;
                        suggestionsContainer.classList.remove('expand-left');
                        suggestionsContainer.classList.add('show-carrot');
                    }, 400);
                } else {
                    setCarrotContent(4);
                    setCarrotColor('green-text');
                    currentState = 4;
                    suggestionsContainer.classList.remove('expand-left');
                    suggestionsContainer.classList.add('show-carrot');
                }
            });

            // Button 5 (index 5): Sports
            debugButtons[5].addEventListener('click', () => {
                if (currentState !== 0) {
                    // Transition to 0 first
                    suggestionsContainer.classList.add('expand-left');
                    suggestionsContainer.classList.remove('show-carrot');
                    
                    // Wait for slide out, then change content while hidden, then slide in
                    setTimeout(() => {
                        setCarrotContent(5);
                        currentState = 5;
                        suggestionsContainer.classList.remove('expand-left');
                        suggestionsContainer.classList.add('show-carrot');
                    }, 400);
                } else {
                    setCarrotContent(5);
                    setCarrotColor(null);
                    currentState = 5;
                    suggestionsContainer.classList.remove('expand-left');
                    suggestionsContainer.classList.add('show-carrot');
                }
            });

            // Button 6 (index 6): Stocks
            debugButtons[6].addEventListener('click', () => {
                if (currentState !== 0) {
                    suggestionsContainer.classList.add('expand-left');
                    suggestionsContainer.classList.remove('show-carrot');
                    
                    setTimeout(() => {
                        setCarrotContent(6);
                        currentState = 6;
                        suggestionsContainer.classList.remove('expand-left');
                        suggestionsContainer.classList.add('show-carrot');
                    }, 400);
                } else {
                    setCarrotContent(6);
                    setCarrotColor(null);
                    currentState = 6;
                    suggestionsContainer.classList.remove('expand-left');
                    suggestionsContainer.classList.add('show-carrot');
                }
            });

            // Button 7 (index 7): World clock
            debugButtons[7].addEventListener('click', () => {
                if (currentState !== 0) {
                    suggestionsContainer.classList.add('expand-left');
                    suggestionsContainer.classList.remove('show-carrot');
                    
                    setTimeout(() => {
                        setCarrotContent(7);
                        currentState = 7;
                        suggestionsContainer.classList.remove('expand-left');
                        suggestionsContainer.classList.add('show-carrot');
                    }, 400);
                } else {
                    setCarrotContent(7);
                    setCarrotColor(null);
                    currentState = 7;
                    suggestionsContainer.classList.remove('expand-left');
                    suggestionsContainer.classList.add('show-carrot');
                }
            });
        }

        const flightNumberPattern = /ac\s*8170/i;

        if (searchBoxElement && suggestionsContainer && carrotList) {
            searchBoxElement.addEventListener('focus', () => {
                if (currentState !== 0 || suggestionsContainer.classList.contains('show-carrot')) {
                    setCarrotContent(0);
                    currentState = 0;
                    suggestionsContainer.classList.add('expand-left');
                    suggestionsContainer.classList.remove('show-carrot');
                }
                
                // Reset to default suggestions if search box is empty
                if (!searchBoxElement.value.trim()) {
                    // Clear AI suggestions tracking
                    aiSuggestionsSet.clear();
                    updateSuggestions([
                        'hoka',
                        'macbook',
                        '13 in macbook air',
                        'Coffee machines for sale',
                        'taylor swift',
                        'coffee grinder',
                        'gmail'
                    ]);
                }
            });

            searchBoxElement.addEventListener('keydown', (event) => {
                if (!suggestionsList) return;
                
                const suggestionItems = suggestionsList.querySelectorAll('.search-suggestions-preview-item');
                if (suggestionItems.length === 0) return;
                
                // Calculate virtual item count (accounting for coffee shops having 2 businesses and stocks having 3 items)
                let virtualItemCount = 0;
                suggestionItems.forEach((item) => {
                    if (item.classList.contains('local-business-wrapper')) {
                        const businessDivs = item.querySelectorAll('.local-business');
                        if (businessDivs.length === 2) {
                            virtualItemCount += 2; // Coffee shops
                        } else {
                            virtualItemCount += 1;
                        }
                    } else if (item.classList.contains('stocks-wrapper')) {
                        const stockDivs = item.querySelectorAll('.stock-item');
                        // Count each stock div as a virtual item
                        virtualItemCount += stockDivs.length > 0 ? stockDivs.length : 1;
                    } else {
                        virtualItemCount += 1;
                    }
                });
                
                if (event.key === 'ArrowDown') {
                    event.preventDefault();
                    // Keyboard navigation steals selection from hovered item
                    // If nothing is selected, select the first item (index 0)
                    // Otherwise, move down one
                    if (selectedSuggestionIndex < 0) {
                        selectedSuggestionIndex = 0;
                    } else {
                        selectedSuggestionIndex = (selectedSuggestionIndex + 1) % virtualItemCount;
                    }
                    updateSelectedSuggestion(true); // true = keyboard navigation
                    // Scroll into view if needed - find the actual DOM item
                    if (selectedSuggestionIndex >= 0 && selectedSuggestionIndex < virtualItemCount) {
                        // Find which DOM item contains this virtual index
                        let currentVirtualIndex = 0;
                        for (let i = 0; i < suggestionItems.length; i++) {
                            const item = suggestionItems[i];
                            let itemVirtualCount = 1;
                            if (item.classList.contains('local-business-wrapper')) {
                                const businessDivs = item.querySelectorAll('.local-business');
                                itemVirtualCount = businessDivs.length === 2 ? 2 : 1;
                            } else if (item.classList.contains('stocks-wrapper')) {
                                const stockDivs = item.querySelectorAll('.stock-item');
                                itemVirtualCount = stockDivs.length > 0 ? stockDivs.length : 1;
                            } else if (item.classList.contains('sports-wrapper')) {
                                const sportsDivs = item.querySelectorAll('.sports-item');
                                itemVirtualCount = sportsDivs.length > 0 ? sportsDivs.length : 1;
                            }
                            if (selectedSuggestionIndex >= currentVirtualIndex && selectedSuggestionIndex < currentVirtualIndex + itemVirtualCount) {
                                item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                                break;
                            }
                            currentVirtualIndex += itemVirtualCount;
                        }
                    }
                } else if (event.key === 'ArrowUp') {
                    event.preventDefault();
                    // Keyboard navigation steals selection from hovered item
                    // If nothing is selected, select the last item
                    // Otherwise, move up one
                    if (selectedSuggestionIndex < 0) {
                        selectedSuggestionIndex = virtualItemCount - 1;
                    } else if (selectedSuggestionIndex <= 0) {
                        selectedSuggestionIndex = virtualItemCount - 1;
                    } else {
                        selectedSuggestionIndex--;
                    }
                    updateSelectedSuggestion(true); // true = keyboard navigation
                    // Scroll into view if needed - find the actual DOM item
                    if (selectedSuggestionIndex >= 0 && selectedSuggestionIndex < virtualItemCount) {
                        // Find which DOM item contains this virtual index
                        let currentVirtualIndex = 0;
                        for (let i = 0; i < suggestionItems.length; i++) {
                            const item = suggestionItems[i];
                            let itemVirtualCount = 1;
                            if (item.classList.contains('local-business-wrapper')) {
                                const businessDivs = item.querySelectorAll('.local-business');
                                itemVirtualCount = businessDivs.length === 2 ? 2 : 1;
                            } else if (item.classList.contains('stocks-wrapper')) {
                                const stockDivs = item.querySelectorAll('.stock-item');
                                itemVirtualCount = stockDivs.length > 0 ? stockDivs.length : 1;
                            } else if (item.classList.contains('sports-wrapper')) {
                                const sportsDivs = item.querySelectorAll('.sports-item');
                                itemVirtualCount = sportsDivs.length > 0 ? sportsDivs.length : 1;
                            }
                            if (selectedSuggestionIndex >= currentVirtualIndex && selectedSuggestionIndex < currentVirtualIndex + itemVirtualCount) {
                                item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                                break;
                            }
                            currentVirtualIndex += itemVirtualCount;
                        }
                    }
                }
                // COMMENTED OUT: Google search on Enter disabled
                // else if (event.key === 'Enter' && selectedSuggestionIndex >= 0) {
                //     event.preventDefault();
                //     // Use the search box value (which should be updated by keyboard navigation)
                //     const searchText = searchBoxElement.value.trim();
                //     if (searchText) {
                //         performGoogleSearch(searchText);
                //     }
                // }
            });


            // Show/hide clear button based on input value
            const updateClearButton = () => {
                if (searchClearButton && searchBoxElement) {
                    if (searchBoxElement.value.trim().length > 0) {
                        searchClearButton.style.display = 'flex';
                    } else {
                        searchClearButton.style.display = 'none';
                    }
                }
            };

            // Clear button click handler
            if (searchClearButton) {
                searchClearButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (searchBoxElement) {
                        searchBoxElement.value = '';
                        searchBoxElement.focus();
                        // Reset to default suggestions
                        updateSuggestions([
                            'hoka',
                            'macbook',
                            '13 in macbook air',
                            'Coffee machines for sale',
                            'taylor swift',
                            'coffee grinder',
                            'gmail'
                        ]);
                        // Clear AI suggestions tracking
                        aiSuggestionsSet.clear();
                        // Remove skeletons
                        removeSkeletons();
                        // Clear any pending API calls
                        if (apiCallTimer) {
                            clearTimeout(apiCallTimer);
                            apiCallTimer = null;
                        }
                        lastApiQuery = '';
                        // Clear carrot state
                        if (suggestionsContainer) {
                            suggestionsContainer.classList.remove('show-carrot');
                            suggestionsContainer.classList.add('expand-left');
                        }
                        currentState = 0;
                        if (carrotList) {
                            carrotList.innerHTML = '';
                            carrotList.dataset.carrotState = '0';
                        }
                        // Restore product grid when cleared
                        restoreProductGrid();
                        updateClearButton();
                    }
                });
            }

            // Update clear button on input
            searchBoxElement.addEventListener('input', (event) => {
                updateClearButton();
                const value = (event.target.value || '').toString();
                const valueLower = value.toLowerCase().trim();
                
                // Check for "winter olympics" to change background color
                if (valueLower === 'winter olympics' || valueLower.includes('winter olympics')) {
                    if (topOverlay) {
                        topOverlay.classList.add('winter-olympics');
                    }
                } else {
                    if (topOverlay) {
                        topOverlay.classList.remove('winter-olympics');
                    }
                }
                
                // Check for "winter ol" to trigger Winter Olympics schedule
                if (valueLower === 'winter ol' || valueLower.startsWith('winter ol')) {
                    renderWinterOlympicsSchedule();
                } else {
                    // Restore product grid if it was replaced
                    restoreProductGrid();
                }
                
                // Check if this matches a demo search that should show a carrot
                const matchedCarrot = showCarrotForDemoSearch(valueLower);
                
                if (!matchedCarrot && valueLower.length === 0) {
                    // Clear carrot when field is empty
                    if (suggestionsContainer) {
                        suggestionsContainer.classList.remove('show-carrot');
                        suggestionsContainer.classList.add('expand-left');
                    }
                    currentState = 0;
                    if (carrotList) {
                        carrotList.innerHTML = '';
                        carrotList.dataset.carrotState = '0';
                    }
                    // Restore product grid when search is cleared
                    restoreProductGrid();
                } else if (!matchedCarrot && valueLower.trim().length > 0) {
                    // Check if this could be a prefix of a demo search
                    const couldBeDemoSearch = Object.keys(demoSearchCarrots).some(term => term.startsWith(valueLower));
                    
                    if (!couldBeDemoSearch && suggestionsContainer && suggestionsContainer.classList.contains('show-carrot')) {
                        // User is typing something that's not a demo search, hide carrot
                        suggestionsContainer.classList.remove('show-carrot');
                        suggestionsContainer.classList.add('expand-left');
                        currentState = 0;
                        if (carrotList) {
                            carrotList.innerHTML = '';
                            carrotList.dataset.carrotState = '0';
                        }
                    }
                }
                
                // Continue to update suggestions even if a carrot is showing
                // The suggestions will appear in the left column while carrot stays in right column
                
                console.log('Input event:', { value, valueLower, length: valueLower.length });
                console.log('suggestionWords defined?', typeof suggestionWords !== 'undefined');
                console.log('suggestionWords value:', typeof suggestionWords !== 'undefined' ? suggestionWords : 'undefined');
                
                // Check for 1-2 character suggestions from suggestionWords
                if (valueLower.length === 1) {
                    console.log('Processing 1 character:', valueLower);
                    // For single character, look for all two-character keys starting with that character
                    const matchingSuggestions = [];
                    if (typeof suggestionWords !== 'undefined' && suggestionWords) {
                        console.log('suggestionWords is available, searching keys...');
                        Object.keys(suggestionWords).forEach(key => {
                            if (key.startsWith(valueLower)) {
                                matchingSuggestions.push(...suggestionWords[key]);
                            }
                        });
                        console.log('Found matching suggestions:', matchingSuggestions.length);
                        // Limit to first 10 suggestions
                        if (matchingSuggestions.length > 0) {
                            const suggestionsToShow = matchingSuggestions.slice(0, 10);
                            console.log('Updating suggestions with:', suggestionsToShow);
                            updateSuggestions(suggestionsToShow);
                            return;
                        } else {
                            console.log('No matching suggestions found');
                        }
                    } else {
                        console.log('suggestionWords is not available');
                    }
                } else if (valueLower.length === 2) {
                    console.log('Processing 2 characters:', valueLower);
                    // For two characters, use exact match
                    if (typeof suggestionWords !== 'undefined' && suggestionWords && suggestionWords[valueLower]) {
                        console.log('Found exact match:', suggestionWords[valueLower]);
                        updateSuggestions(suggestionWords[valueLower]);
                        return;
                    } else {
                        console.log('No exact match found for:', valueLower);
                    }
                } else if (valueLower.length >= 3) {
                    console.log('Processing 3+ characters:', valueLower);
                    
                    // Clear any pending API call
                    if (apiCallTimer) {
                        clearTimeout(apiCallTimer);
                    }
                    
                    // Clear AI suggestions tracking and skeletons when query changes
                    if (lastApiQuery && lastApiQuery !== valueLower) {
                        aiSuggestionsSet.clear();
                    }
                    
                    // Always remove skeletons before updating suggestions
                    removeSkeletons();
                    
                    // Show immediate local results while waiting for AI
                    let localSuggestions = [];
                    if (typeof suggestionWords !== 'undefined' && suggestionWords) {
                        const allSuggestions = [];
                        Object.values(suggestionWords).forEach(suggestions => {
                            allSuggestions.push(...suggestions);
                        });
                        
                        // Filter to only suggestions that start with the query (word-start matching)
                        const filtered = allSuggestions.filter(suggestion => {
                            const suggestionLower = suggestion.toLowerCase();
                            // Check if suggestion starts with query
                            if (suggestionLower.startsWith(valueLower)) {
                                return true;
                            }
                            // Check if any word in the suggestion starts with the query
                            const words = suggestionLower.split(/\s+/);
                            return words.some(word => word.startsWith(valueLower));
                        });
                        
                        localSuggestions = [...new Set(filtered)];
                        if (localSuggestions.length > 0) {
                            const localCount = Math.min(localSuggestions.length, 10);
                            // Update suggestions with filtered list (this will clear old suggestions)
                            updateSuggestions(localSuggestions.slice(0, localCount));
                            // Show skeleton loaders to fill up to 10 total
                            const skeletonCount = 10 - localCount;
                            if (skeletonCount > 0) {
                                showSkeletonLoaders(skeletonCount);
                            }
                        } else {
                            // If no local suggestions, clear list and show 10 skeletons
                            updateSuggestions([]);
                            showSkeletonLoaders(10);
                        }
                    } else {
                        // If no suggestionWords available, clear list and show 10 skeletons
                        updateSuggestions([]);
                        showSkeletonLoaders(10);
                    }
                    
                    // Capture localSuggestions for use in async callback
                    const currentLocalSuggestions = [...localSuggestions];
                    
                    // Debounce API call (wait 300ms after user stops typing)
                    apiCallTimer = setTimeout(async () => {
                        // Only make API call if query hasn't changed
                        if (searchBoxElement.value.toLowerCase() === valueLower) {
                            lastApiQuery = valueLower;
                            console.log('Fetching AI suggestions for:', valueLower);
                            
                            const aiSuggestions = await fetchAISuggestions(valueLower);
                            
                            // Only update if query hasn't changed during API call
                            if (searchBoxElement.value.toLowerCase() === valueLower) {
                                if (aiSuggestions.length > 0) {
                                    console.log('AI suggestions received:', aiSuggestions);
                                    
                                    // Track AI suggestions for icon assignment
                                    aiSuggestions.forEach(aiSuggestion => {
                                        aiSuggestionsSet.add(aiSuggestion.toLowerCase());
                                    });
                                    
                                    // Merge local and AI suggestions, removing duplicates
                                    const allSuggestions = [...currentLocalSuggestions];
                                    aiSuggestions.forEach(aiSuggestion => {
                                        const aiLower = aiSuggestion.toLowerCase();
                                        // Only add if not already in local suggestions
                                        if (!allSuggestions.some(s => s.toLowerCase() === aiLower)) {
                                            allSuggestions.push(aiSuggestion);
                                        }
                                    });
                                    
                                    // Limit to 10 total suggestions
                                    const mergedSuggestions = allSuggestions.slice(0, 10);
                                    console.log('Merged suggestions (local + AI):', mergedSuggestions);
                                    // updateSuggestions will remove skeletons and replace with new suggestions
                                    updateSuggestions(mergedSuggestions);
                                } else {
                                    // No AI suggestions - update with just local suggestions
                                    // This will remove skeletons and show local suggestions
                                    console.log('No AI suggestions, using local:', currentLocalSuggestions);
                                    if (currentLocalSuggestions.length > 0) {
                                        const localCount = Math.min(currentLocalSuggestions.length, 10);
                                        updateSuggestions(currentLocalSuggestions.slice(0, localCount));
                                    } else {
                                        // No suggestions at all - remove skeletons and clear list
                                        removeSkeletons();
                                        updateSuggestions([]);
                                    }
                                }
                            }
                        }
                    }, 300);
                }

                // Reset to default suggestions when field is empty
                if (!value.trim()) {
                    console.log('Field is empty, resetting to default suggestions');
                    // Clear AI suggestions tracking when field is empty
                    aiSuggestionsSet.clear();
                    updateSuggestions([
                        'hoka',
                        'macbook',
                        '13 in macbook air',
                        'Coffee machines for sale',
                        'taylor swift',
                        'coffee grinder',
                        'gmail'
                    ]);
                    return;
                }
                
                console.log('No suggestions updated, continuing...');
            });
        }

        const overlayScrollTarget = searchContainer;
        if (overlayScrollTarget) {
            const handleOverlayScrollWheel = (event) => {
                const maxScroll = overlayScrollTarget.scrollHeight - overlayScrollTarget.clientHeight;
                if (maxScroll <= 0) {
                    return;
                }

                const currentScroll = overlayScrollTarget.scrollTop;
                const nextScroll = currentScroll + event.deltaY;

                if ((event.deltaY < 0 && currentScroll <= 0) || (event.deltaY > 0 && currentScroll >= maxScroll)) {
                    return;
                }

                event.preventDefault();
                overlayScrollTarget.scrollTop = Math.min(Math.max(nextScroll, 0), maxScroll);
            };

            const previewArea = document.querySelector('.search-suggestions-preview');
            if (previewArea) {
                previewArea.addEventListener('wheel', handleOverlayScrollWheel, { passive: false });
            }

            overlayScrollTarget.addEventListener('wheel', handleOverlayScrollWheel, { passive: false });
        }

        const bottomPane = document.querySelector('.pane--bottom');
        if (bottomPane && topOverlay) {
            const handleOverlayPosition = () => {
                if (topOverlay.classList.contains('is-focused')) {
                    return;
                }
                bottomOverlay.style.top = `${Math.max(130, 130 + bottomPane.scrollTop)}px`;
            };
            bottomPane.addEventListener('scroll', handleOverlayPosition, { passive: true });
        }
    </script>
</body>
</html>
